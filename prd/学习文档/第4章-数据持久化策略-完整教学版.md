# ğŸ—ƒï¸ ç¬¬4ç« ï¼šæ•°æ®æŒä¹…åŒ–ç­–ç•¥ - å®Œæ•´æ•™å­¦ç‰ˆ

> **ä»æ•°æ®åº“è®¾è®¡åˆ°ORMå®è·µ** - æ„å»ºé«˜æ•ˆã€å¯ç»´æŠ¤çš„æ•°æ®å±‚æ¶æ„

## ğŸ“‹ ç« èŠ‚æ¦‚è¿°

### ğŸ¯ å­¦ä¹ ç›®æ ‡
é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæ‚¨å°†èƒ½å¤Ÿï¼š
- æ·±å…¥ç†è§£ORMè®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³å’Œå®ç°åŸç†
- ç†Ÿç»ƒæŒæ¡TypeORMçš„é…ç½®ã€ä½¿ç”¨å’Œæœ€ä½³å®è·µ
- è®¾è®¡åˆç†çš„æ•°æ®æ¨¡å‹å’Œå®ä½“å…³ç³»æ˜ å°„
- å®ç°é«˜æ•ˆçš„æ•°æ®æŸ¥è¯¢å’Œæ“ä½œç­–ç•¥
- æŒæ¡æ•°æ®åº“è¿ç§»å’Œç‰ˆæœ¬æ§åˆ¶æ–¹æ³•
- ç†è§£å¹¶åº”ç”¨æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### â° å­¦ä¹ æ—¶é—´å®‰æ’
- **æ€»å­¦ä¹ æ—¶é•¿**ï¼š4-6å°æ—¶
- **ç†è®ºå­¦ä¹ **ï¼š2å°æ—¶
- **å®è·µç¼–ç¨‹**ï¼š2-3å°æ—¶
- **é¡¹ç›®ç»ƒä¹ **ï¼š1å°æ—¶

### ğŸ“ éš¾åº¦ç­‰çº§
â­â­â­â˜†â˜† (ä¸­ç­‰éš¾åº¦)

### ğŸ“š å‰ç½®çŸ¥è¯†è¦æ±‚
- âœ… æ•°æ®åº“åŸºç¡€æ¦‚å¿µå’ŒSQLè¯­è¨€
- âœ… TypeScriptåŸºç¡€è¯­æ³•
- âœ… NestJSæ¨¡å—ç³»ç»Ÿå’Œä¾èµ–æ³¨å…¥
- âœ… è£…é¥°å™¨æ¨¡å¼çš„åŸºæœ¬ç†è§£

### ğŸ† å­¦ä¹ æˆæœ
å®Œæˆæœ¬ç« å­¦ä¹ åï¼Œæ‚¨å°†å…·å¤‡ï¼š
- ä¼ä¸šçº§æ•°æ®å±‚æ¶æ„è®¾è®¡èƒ½åŠ›
- TypeORMé«˜çº§ç‰¹æ€§åº”ç”¨æŠ€èƒ½
- æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–å®è·µç»éªŒ
- æ•°æ®è¿ç§»å’Œç‰ˆæœ¬ç®¡ç†èƒ½åŠ›

## ğŸ¨ çŸ¥è¯†æ¶æ„å›¾

```mermaid
mindmap
  root((æ•°æ®æŒä¹…åŒ–ç­–ç•¥))
    ORMè®¾è®¡æ¨¡å¼
      å¯¹è±¡å…³ç³»æ˜ å°„
      Active Record
      Data Mapper
      Repositoryæ¨¡å¼
    TypeORMæ ¸å¿ƒ
      å®ä½“å®šä¹‰
      å…³ç³»æ˜ å°„
      æŸ¥è¯¢æ„å»ºå™¨
      äº‹åŠ¡å¤„ç†
    æ•°æ®å»ºæ¨¡
      å®ä½“è®¾è®¡
      å…³ç³»è®¾è®¡
      çº¦æŸå®šä¹‰
      ç´¢å¼•ä¼˜åŒ–
    é«˜çº§ç‰¹æ€§
      æ•°æ®è¿ç§»
      è¿æ¥æ± 
      ç¼“å­˜ç­–ç•¥
      æ€§èƒ½ç›‘æ§
    æœ€ä½³å®è·µ
      ä»£ç ç»„ç»‡
      é”™è¯¯å¤„ç†
      æµ‹è¯•ç­–ç•¥
      éƒ¨ç½²é…ç½®
```

## ğŸ¯ ç¬¬ä¸€èŠ‚ï¼šORMè®¾è®¡æ¨¡å¼æ·±åº¦è§£æ

### ğŸ“– 1.1 ä»€ä¹ˆæ˜¯ORMï¼Ÿ

#### ğŸ¯ ä¸€å¥è¯æ¦‚æ‹¬
**ORMï¼ˆObject-Relational Mappingï¼‰æ˜¯è¿æ¥é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€å’Œå…³ç³»å‹æ•°æ®åº“çš„æ¡¥æ¢ã€‚**

#### ğŸ—ï¸ ç”Ÿæ´»ç±»æ¯”ç†è§£
æƒ³è±¡æ‚¨æ˜¯ä¸€ä½ç¿»è¯‘å®˜ï¼š
- **å¯¹è±¡ä¸–ç•Œ** = ä¸­æ–‡ä¸–ç•Œï¼ˆç¨‹åºå‘˜ç†Ÿæ‚‰çš„è¯­è¨€ï¼‰
- **å…³ç³»æ•°æ®åº“** = è‹±æ–‡ä¸–ç•Œï¼ˆæ•°æ®åº“çš„è¯­è¨€ï¼‰
- **ORM** = ç¿»è¯‘å®˜ï¼ˆè‡ªåŠ¨åœ¨ä¸¤ç§è¯­è¨€é—´è½¬æ¢ï¼‰

```typescript
// ç¨‹åºå‘˜çœ‹åˆ°çš„ï¼ˆå¯¹è±¡ä¸–ç•Œï¼‰
const user = new User();
user.name = "å¼ ä¸‰";
user.email = "zhangsan@example.com";
await user.save();

// æ•°æ®åº“æ‰§è¡Œçš„ï¼ˆSQLä¸–ç•Œï¼‰
// INSERT INTO users (name, email) VALUES ('å¼ ä¸‰', 'zhangsan@example.com');
```

#### ğŸ” ORMè§£å†³çš„æ ¸å¿ƒé—®é¢˜

**1. é˜»æŠ—ä¸åŒ¹é…é—®é¢˜**
```typescript
// å¯¹è±¡æ¨¡å‹ï¼šç»§æ‰¿ã€å°è£…ã€å¤šæ€
class User {
  private id: number;
  private profile: UserProfile;
  
  public getFullName(): string {
    return `${this.profile.firstName} ${this.profile.lastName}`;
  }
}

// å…³ç³»æ¨¡å‹ï¼šè¡¨ã€è¡Œã€åˆ—
// usersè¡¨: id, first_name, last_name, email
// user_profilesè¡¨: user_id, bio, avatar_url
```

**2. é‡å¤æ€§ä»£ç é—®é¢˜**
```typescript
// æ²¡æœ‰ORMæ—¶çš„é‡å¤ä»£ç 
class UserRepository {
  async findById(id: number): Promise<User> {
    const sql = 'SELECT * FROM users WHERE id = ?';
    const result = await this.db.query(sql, [id]);
    return this.mapRowToUser(result[0]); // æ‰‹åŠ¨æ˜ å°„
  }
  
  async save(user: User): Promise<void> {
    const sql = 'INSERT INTO users (name, email) VALUES (?, ?)';
    await this.db.query(sql, [user.name, user.email]);
  }
  
  // æ¯ä¸ªå®ä½“éƒ½éœ€è¦ç±»ä¼¼çš„CRUDä»£ç ...
}

// ä½¿ç”¨ORMå
@Entity()
class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  name: string;
  
  @Column()
  email: string;
}

// è‡ªåŠ¨è·å¾—æ‰€æœ‰CRUDæ“ä½œ
const userRepository = getRepository(User);
const user = await userRepository.findOne(1);
await userRepository.save(user);
```

### ğŸ›ï¸ 1.2 ORMæ¶æ„æ¨¡å¼å¯¹æ¯”

#### ğŸ¯ Active Record æ¨¡å¼

**æ ¸å¿ƒæ€æƒ³**ï¼šæ•°æ®å’Œè¡Œä¸ºåˆå¹¶åœ¨ä¸€ä¸ªå¯¹è±¡ä¸­

```typescript
// Active Record ç¤ºä¾‹
class User extends ActiveRecord {
  @Column()
  name: string;
  
  @Column()
  email: string;
  
  // æ•°æ®æ“ä½œæ–¹æ³•ç›´æ¥åœ¨å®ä½“ä¸Š
  async save(): Promise<void> {
    return super.save();
  }
  
  async delete(): Promise<void> {
    return super.delete();
  }
  
  // ä¸šåŠ¡é€»è¾‘ä¹Ÿåœ¨å®ä½“ä¸Š
  isAdmin(): boolean {
    return this.role === 'admin';
  }
  
  sendWelcomeEmail(): void {
    // å‘é€é‚®ä»¶é€»è¾‘
  }
}

// ä½¿ç”¨æ–¹å¼
const user = new User();
user.name = "å¼ ä¸‰";
await user.save(); // ç›´æ¥è°ƒç”¨å®ä½“æ–¹æ³•
```

**ä¼˜ç‚¹**ï¼š
- ç®€å•ç›´è§‚ï¼Œå®¹æ˜“ç†è§£
- ä»£ç é‡å°‘ï¼Œå¼€å‘å¿«é€Ÿ
- é€‚åˆç®€å•çš„CRUDæ“ä½œ

**ç¼ºç‚¹**ï¼š
- è¿åå•ä¸€èŒè´£åŸåˆ™
- éš¾ä»¥è¿›è¡Œå•å…ƒæµ‹è¯•
- ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®è®¿é—®è€¦åˆ

#### ğŸ¯ Data Mapper æ¨¡å¼

**æ ¸å¿ƒæ€æƒ³**ï¼šæ•°æ®å’Œè¡Œä¸ºåˆ†ç¦»ï¼Œé€šè¿‡æ˜ å°„å™¨æ“ä½œæ•°æ®

```typescript
// Data Mapper ç¤ºä¾‹
@Entity()
class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  name: string;
  
  @Column()
  email: string;
  
  @Column()
  role: string;
  
  // åªåŒ…å«ä¸šåŠ¡é€»è¾‘ï¼Œä¸åŒ…å«æ•°æ®æ“ä½œ
  isAdmin(): boolean {
    return this.role === 'admin';
  }
  
  getDisplayName(): string {
    return this.name.toUpperCase();
  }
}

// æ•°æ®è®¿é—®é€šè¿‡Repository
@Injectable()
class UserRepository {
  constructor(
    @InjectRepository(User)
    private repository: Repository<User>,
  ) {}
  
  async findById(id: number): Promise<User> {
    return this.repository.findOne({ where: { id } });
  }
  
  async save(user: User): Promise<User> {
    return this.repository.save(user);
  }
  
  async findAdmins(): Promise<User[]> {
    return this.repository.find({ where: { role: 'admin' } });
  }
}

// ä½¿ç”¨æ–¹å¼
const user = new User();
user.name = "å¼ ä¸‰";
const savedUser = await userRepository.save(user);
```

**ä¼˜ç‚¹**ï¼š
- èŒè´£åˆ†ç¦»ï¼Œæ˜“äºæµ‹è¯•
- ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®è®¿é—®è§£è€¦
- æ›´å¥½çš„å¯ç»´æŠ¤æ€§

**ç¼ºç‚¹**ï¼š
- ä»£ç é‡ç›¸å¯¹è¾ƒå¤š
- å­¦ä¹ æ›²çº¿è¾ƒé™¡å³­

#### ğŸ† TypeORMçš„é€‰æ‹©ï¼šData Mapper + Repository

TypeORMé‡‡ç”¨Data Mapperæ¨¡å¼ï¼Œå¹¶æä¾›Repositoryæ¨¡å¼æ¥ç®¡ç†æ•°æ®è®¿é—®ï¼š

```typescript
// TypeORMçš„æœ€ä½³å®è·µ
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ unique: true })
  username: string;
  
  @Column({ unique: true })
  email: string;
  
  @Column()
  passwordHash: string;
  
  @CreateDateColumn()
  createdAt: Date;
  
  @UpdateDateColumn()
  updatedAt: Date;
  
  // åªåŒ…å«ä¸šåŠ¡é€»è¾‘
  validatePassword(password: string): boolean {
    return bcrypt.compareSync(password, this.passwordHash);
  }
  
  toJSON() {
    const { passwordHash, ...result } = this;
    return result;
  }
}

@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
  ) {}
  
  async createUser(userData: CreateUserDto): Promise<User> {
    const user = this.userRepository.create(userData);
    return this.userRepository.save(user);
  }
  
  async findByEmail(email: string): Promise<User> {
    return this.userRepository.findOne({ where: { email } });
  }
}
```

### ğŸ”§ 1.3 TypeORMæ ¸å¿ƒæ¦‚å¿µ

#### ğŸ“Š å®ä½“ (Entity)
å®ä½“æ˜¯æ•°æ®åº“è¡¨åœ¨ä»£ç ä¸­çš„æ˜ å°„ï¼š

```typescript
@Entity('users') // æŒ‡å®šè¡¨å
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ 
    type: 'varchar', 
    length: 50, 
    unique: true,
    comment: 'ç”¨æˆ·å'
  })
  username: string;
  
  @Column({
    type: 'varchar',
    length: 100,
    unique: true
  })
  email: string;
  
  @Column({ select: false }) // æŸ¥è¯¢æ—¶é»˜è®¤ä¸é€‰æ‹©æ­¤å­—æ®µ
  passwordHash: string;
  
  @Column({
    type: 'enum',
    enum: ['admin', 'user', 'moderator'],
    default: 'user'
  })
  role: string;
  
  @Column({ default: true })
  isActive: boolean;
  
  @CreateDateColumn()
  createdAt: Date;
  
  @UpdateDateColumn()
  updatedAt: Date;
  
  @DeleteDateColumn() // è½¯åˆ é™¤
  deletedAt?: Date;
}
```

#### ğŸ”— å…³ç³»æ˜ å°„ (Relations)

**ä¸€å¯¹ä¸€å…³ç³»**ï¼š
```typescript
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  username: string;
  
  @OneToOne(() => UserProfile, profile => profile.user, { cascade: true })
  @JoinColumn()
  profile: UserProfile;
}

@Entity()
export class UserProfile {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ nullable: true })
  bio: string;
  
  @Column({ nullable: true })
  avatarUrl: string;
  
  @OneToOne(() => User, user => user.profile)
  user: User;
}
```

**ä¸€å¯¹å¤šå…³ç³»**ï¼š
```typescript
@Entity()
export class Category {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  name: string;
  
  @OneToMany(() => Article, article => article.category)
  articles: Article[];
}

@Entity()
export class Article {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  title: string;
  
  @ManyToOne(() => Category, category => category.articles)
  category: Category;
  
  @ManyToOne(() => User, user => user.articles)
  author: User;
}
```

**å¤šå¯¹å¤šå…³ç³»**ï¼š
```typescript
@Entity()
export class Article {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  title: string;
  
  @ManyToMany(() => Tag, tag => tag.articles, { cascade: true })
  @JoinTable({
    name: 'article_tags',
    joinColumn: { name: 'article_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'tag_id', referencedColumnName: 'id' }
  })
  tags: Tag[];
}

@Entity()
export class Tag {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ unique: true })
  name: string;
  
  @ManyToMany(() => Article, article => article.tags)
  articles: Article[];
}
```

## ğŸ› ï¸ ç¬¬äºŒèŠ‚ï¼šTypeORMå®æˆ˜é…ç½®

### âš™ï¸ 2.1 é¡¹ç›®åˆå§‹åŒ–å’Œé…ç½®

#### ğŸ“¦ å®‰è£…ä¾èµ–
```bash
# å®‰è£…TypeORMå’Œç›¸å…³ä¾èµ–
npm install @nestjs/typeorm typeorm

# å®‰è£…æ•°æ®åº“é©±åŠ¨ï¼ˆé€‰æ‹©ä¸€ä¸ªï¼‰
npm install pg @types/pg          # PostgreSQL
npm install mysql2                # MySQL
npm install sqlite3               # SQLite
npm install mongodb               # MongoDB
```

#### ğŸ”§ æ•°æ®åº“é…ç½®

**æ–¹å¼1ï¼šç›´æ¥é…ç½®**
```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { Article } from './entities/article.entity';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      username: 'postgres',
      password: 'password',
      database: 'blog_db',
      entities: [User, Article],
      synchronize: true, // å¼€å‘ç¯å¢ƒä½¿ç”¨ï¼Œç”Ÿäº§ç¯å¢ƒç¦ç”¨
      logging: true,     // å¼€å‘ç¯å¢ƒæŸ¥çœ‹SQLæ—¥å¿—
    }),
  ],
})
export class AppModule {}
```

**æ–¹å¼2ï¼šé…ç½®æ–‡ä»¶**
```typescript
// config/database.config.ts
import { TypeOrmModuleOptions } from '@nestjs/typeorm';
import { ConfigService } from '@nestjs/config';

export const getDatabaseConfig = (
  configService: ConfigService,
): TypeOrmModuleOptions => ({
  type: 'postgres',
  host: configService.get('DB_HOST', 'localhost'),
  port: configService.get('DB_PORT', 5432),
  username: configService.get('DB_USERNAME', 'postgres'),
  password: configService.get('DB_PASSWORD', 'password'),
  database: configService.get('DB_NAME', 'blog_db'),
  entities: [__dirname + '/../**/*.entity{.ts,.js}'],
  migrations: [__dirname + '/../migrations/*{.ts,.js}'],
  synchronize: configService.get('NODE_ENV') !== 'production',
  logging: configService.get('NODE_ENV') === 'development',
  ssl: configService.get('NODE_ENV') === 'production' ? { rejectUnauthorized: false } : false,
});

// app.module.ts
@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: getDatabaseConfig,
      inject: [ConfigService],
    }),
  ],
})
export class AppModule {}
```

**ç¯å¢ƒå˜é‡é…ç½®**ï¼š
```bash
# .env
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=password
DB_NAME=blog_db
NODE_ENV=development
```

### ğŸ—ï¸ 2.2 å®ä½“è®¾è®¡æœ€ä½³å®è·µ

#### ğŸ“‹ åŸºç¡€å®ä½“ç±»
```typescript
// entities/base.entity.ts
import {
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  DeleteDateColumn,
  VersionColumn,
} from 'typeorm';

export abstract class BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;
  
  @CreateDateColumn({
    type: 'timestamp',
    default: () => 'CURRENT_TIMESTAMP(6)',
  })
  createdAt: Date;
  
  @UpdateDateColumn({
    type: 'timestamp',
    default: () => 'CURRENT_TIMESTAMP(6)',
    onUpdate: 'CURRENT_TIMESTAMP(6)',
  })
  updatedAt: Date;
  
  @DeleteDateColumn()
  deletedAt?: Date;
  
  @VersionColumn()
  version: number;
}
```

#### ğŸ‘¤ ç”¨æˆ·å®ä½“è®¾è®¡
```typescript
// entities/user.entity.ts
import { Entity, Column, OneToMany, OneToOne, Index } from 'typeorm';
import { BaseEntity } from './base.entity';
import { Article } from './article.entity';
import { UserProfile } from './user-profile.entity';
import { Exclude } from 'class-transformer';

export enum UserRole {
  ADMIN = 'admin',
  AUTHOR = 'author',
  READER = 'reader',
}

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
}

@Entity('users')
@Index(['email']) // ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
@Index(['username'])
export class User extends BaseEntity {
  @Column({
    type: 'varchar',
    length: 50,
    unique: true,
    comment: 'ç”¨æˆ·åï¼Œå…¨å±€å”¯ä¸€',
  })
  username: string;
  
  @Column({
    type: 'varchar',
    length: 100,
    unique: true,
    comment: 'é‚®ç®±åœ°å€ï¼Œå…¨å±€å”¯ä¸€',
  })
  email: string;
  
  @Column({
    type: 'varchar',
    length: 255,
    select: false, // é»˜è®¤æŸ¥è¯¢æ—¶ä¸åŒ…å«å¯†ç 
    comment: 'å¯†ç å“ˆå¸Œå€¼',
  })
  @Exclude() // åºåˆ—åŒ–æ—¶æ’é™¤
  passwordHash: string;
  
  @Column({
    type: 'enum',
    enum: UserRole,
    default: UserRole.READER,
    comment: 'ç”¨æˆ·è§’è‰²',
  })
  role: UserRole;
  
  @Column({
    type: 'enum',
    enum: UserStatus,
    default: UserStatus.ACTIVE,
    comment: 'ç”¨æˆ·çŠ¶æ€',
  })
  status: UserStatus;
  
  @Column({
    type: 'timestamp',
    nullable: true,
    comment: 'æœ€åç™»å½•æ—¶é—´',
  })
  lastLoginAt?: Date;
  
  @Column({
    type: 'varchar',
    length: 45,
    nullable: true,
    comment: 'æœ€åç™»å½•IP',
  })
  lastLoginIp?: string;
  
  @Column({
    type: 'boolean',
    default: false,
    comment: 'é‚®ç®±æ˜¯å¦å·²éªŒè¯',
  })
  emailVerified: boolean;
  
  @Column({
    type: 'varchar',
    length: 255,
    nullable: true,
    comment: 'é‚®ç®±éªŒè¯ä»¤ç‰Œ',
  })
  emailVerificationToken?: string;
  
  // å…³ç³»æ˜ å°„
  @OneToOne(() => UserProfile, profile => profile.user, {
    cascade: true,
    eager: false, // ä¸è‡ªåŠ¨åŠ è½½å…³è”æ•°æ®
  })
  profile: UserProfile;
  
  @OneToMany(() => Article, article => article.author)
  articles: Article[];
  
  // ä¸šåŠ¡æ–¹æ³•
  isAdmin(): boolean {
    return this.role === UserRole.ADMIN;
  }
  
  isActive(): boolean {
    return this.status === UserStatus.ACTIVE;
  }
  
  updateLastLogin(ip: string): void {
    this.lastLoginAt = new Date();
    this.lastLoginIp = ip;
  }
  
  // åºåˆ—åŒ–æ§åˆ¶
  toJSON() {
    const { passwordHash, emailVerificationToken, ...result } = this;
    return result;
  }
}
```

#### ğŸ“ æ–‡ç« å®ä½“è®¾è®¡
```typescript
// entities/article.entity.ts
import {
  Entity,
  Column,
  ManyToOne,
  ManyToMany,
  JoinTable,
  Index,
  BeforeInsert,
  BeforeUpdate,
} from 'typeorm';
import { BaseEntity } from './base.entity';
import { User } from './user.entity';
import { Category } from './category.entity';
import { Tag } from './tag.entity';

export enum ArticleStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
}

@Entity('articles')
@Index(['status', 'publishedAt']) // å¤åˆç´¢å¼•
@Index(['authorId', 'status'])
export class Article extends BaseEntity {
  @Column({
    type: 'varchar',
    length: 200,
    comment: 'æ–‡ç« æ ‡é¢˜',
  })
  title: string;
  
  @Column({
    type: 'varchar',
    length: 500,
    nullable: true,
    comment: 'æ–‡ç« æ‘˜è¦',
  })
  summary?: string;
  
  @Column({
    type: 'text',
    comment: 'æ–‡ç« å†…å®¹',
  })
  content: string;
  
  @Column({
    type: 'varchar',
    length: 200,
    unique: true,
    comment: 'URLå‹å¥½çš„æ ‡è¯†ç¬¦',
  })
  slug: string;
  
  @Column({
    type: 'varchar',
    length: 500,
    nullable: true,
    comment: 'å°é¢å›¾ç‰‡URL',
  })
  coverImage?: string;
  
  @Column({
    type: 'enum',
    enum: ArticleStatus,
    default: ArticleStatus.DRAFT,
    comment: 'æ–‡ç« çŠ¶æ€',
  })
  status: ArticleStatus;
  
  @Column({
    type: 'timestamp',
    nullable: true,
    comment: 'å‘å¸ƒæ—¶é—´',
  })
  publishedAt?: Date;
  
  @Column({
    type: 'int',
    default: 0,
    comment: 'é˜…è¯»æ¬¡æ•°',
  })
  viewCount: number;
  
  @Column({
    type: 'int',
    default: 0,
    comment: 'ç‚¹èµæ¬¡æ•°',
  })
  likeCount: number;
  
  @Column({
    type: 'int',
    default: 0,
    comment: 'è¯„è®ºæ¬¡æ•°',
  })
  commentCount: number;
  
  @Column({
    type: 'json',
    nullable: true,
    comment: 'SEOå…ƒæ•°æ®',
  })
  seoMeta?: {
    metaTitle?: string;
    metaDescription?: string;
    keywords?: string[];
  };
  
  // å…³ç³»æ˜ å°„
  @ManyToOne(() => User, user => user.articles, {
    nullable: false,
    onDelete: 'CASCADE',
  })
  author: User;
  
  @Column()
  authorId: number; // å¤–é”®å­—æ®µï¼Œä¾¿äºæŸ¥è¯¢
  
  @ManyToOne(() => Category, category => category.articles, {
    nullable: true,
    onDelete: 'SET NULL',
  })
  category?: Category;
  
  @Column({ nullable: true })
  categoryId?: number;
  
  @ManyToMany(() => Tag, tag => tag.articles, {
    cascade: true,
  })
  @JoinTable({
    name: 'article_tags',
    joinColumn: { name: 'article_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'tag_id', referencedColumnName: 'id' },
  })
  tags: Tag[];
  
  // ç”Ÿå‘½å‘¨æœŸé’©å­
  @BeforeInsert()
  @BeforeUpdate()
  generateSlug() {
    if (!this.slug && this.title) {
      this.slug = this.title
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim();
    }
  }
  
  @BeforeInsert()
  setPublishedAt() {
    if (this.status === ArticleStatus.PUBLISHED && !this.publishedAt) {
      this.publishedAt = new Date();
    }
  }
  
  // ä¸šåŠ¡æ–¹æ³•
  isPublished(): boolean {
    return this.status === ArticleStatus.PUBLISHED;
  }
  
  incrementViewCount(): void {
    this.viewCount += 1;
  }
  
  publish(): void {
    this.status = ArticleStatus.PUBLISHED;
    this.publishedAt = new Date();
  }
  
  archive(): void {
    this.status = ArticleStatus.ARCHIVED;
  }
}
```

### ğŸ”„ 2.3 Repositoryæ¨¡å¼å®ç°

#### ğŸ“š åŸºç¡€RepositoryæœåŠ¡
```typescript
// services/base-repository.service.ts
import { Repository, FindOptionsWhere, FindManyOptions } from 'typeorm';
import { BaseEntity } from '../entities/base.entity';

export abstract class BaseRepositoryService<T extends BaseEntity> {
  constructor(protected readonly repository: Repository<T>) {}
  
  async findById(id: number): Promise<T | null> {
    return this.repository.findOne({ where: { id } as FindOptionsWhere<T> });
  }
  
  async findAll(options?: FindManyOptions<T>): Promise<T[]> {
    return this.repository.find(options);
  }
  
  async create(entityData: Partial<T>): Promise<T> {
    const entity = this.repository.create(entityData);
    return this.repository.save(entity);
  }
  
  async update(id: number, updateData: Partial<T>): Promise<T | null> {
    await this.repository.update(id, updateData);
    return this.findById(id);
  }
  
  async delete(id: number): Promise<boolean> {
    const result = await this.repository.delete(id);
    return result.affected > 0;
  }
  
  async softDelete(id: number): Promise<boolean> {
    const result = await this.repository.softDelete(id);
    return result.affected > 0;
  }
  
  async count(options?: FindManyOptions<T>): Promise<number> {
    return this.repository.count(options);
  }
  
  async exists(where: FindOptionsWhere<T>): Promise<boolean> {
    const count = await this.repository.count({ where });
    return count > 0;
  }
}
```

#### ğŸ‘¤ ç”¨æˆ·RepositoryæœåŠ¡
```typescript
// services/user-repository.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User, UserRole, UserStatus } from '../entities/user.entity';
import { BaseRepositoryService } from './base-repository.service';

@Injectable()
export class UserRepositoryService extends BaseRepositoryService<User> {
  constructor(
    @InjectRepository(User)
    repository: Repository<User>,
  ) {
    super(repository);
  }
  
  async findByEmail(email: string): Promise<User | null> {
    return this.repository.findOne({
      where: { email },
      select: ['id', 'username', 'email', 'role', 'status', 'passwordHash'],
    });
  }
  
  async findByUsername(username: string): Promise<User | null> {
    return this.repository.findOne({
      where: { username },
    });
  }
  
  async findByEmailOrUsername(emailOrUsername: string): Promise<User | null> {
    return this.repository.findOne({
      where: [
        { email: emailOrUsername },
        { username: emailOrUsername },
      ],
      select: ['id', 'username', 'email', 'role', 'status', 'passwordHash'],
    });
  }
  
  async findActiveUsers(): Promise<User[]> {
    return this.repository.find({
      where: { status: UserStatus.ACTIVE },
    });
  }
  
  async findUsersByRole(role: UserRole): Promise<User[]> {
    return this.repository.find({
      where: { role },
    });
  }
  
  async updateLastLogin(userId: number, ip: string): Promise<void> {
    await this.repository.update(userId, {
      lastLoginAt: new Date(),
      lastLoginIp: ip,
    });
  }
  
  async verifyEmail(userId: number): Promise<void> {
    await this.repository.update(userId, {
      emailVerified: true,
      emailVerificationToken: null,
    });
  }
  
  async changePassword(userId: number, passwordHash: string): Promise<void> {
    await this.repository.update(userId, { passwordHash });
  }
  
  async getUserStats(): Promise<{
    total: number;
    active: number;
    inactive: number;
    byRole: Record<UserRole, number>;
  }> {
    const [total, active, inactive] = await Promise.all([
      this.repository.count(),
      this.repository.count({ where: { status: UserStatus.ACTIVE } }),
      this.repository.count({ where: { status: UserStatus.INACTIVE } }),
    ]);
    
    const byRole = {} as Record<UserRole, number>;
    for (const role of Object.values(UserRole)) {
      byRole[role] = await this.repository.count({ where: { role } });
    }
    
    return { total, active, inactive, byRole };
  }
}
```

---

> **ğŸ¯ ç¬¬ä¸€éƒ¨åˆ†æ€»ç»“**ï¼š
> 
> æˆ‘ä»¬å·²ç»å­¦ä¹ äº†ï¼š
> 1. ORMè®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³å’Œä¼˜åŠ¿
> 2. Active Record vs Data Mapperæ¨¡å¼å¯¹æ¯”
> 3. TypeORMçš„åŸºç¡€é…ç½®å’Œé¡¹ç›®åˆå§‹åŒ–
> 4. å®ä½“è®¾è®¡çš„æœ€ä½³å®è·µ
> 5. Repositoryæ¨¡å¼çš„å®ç°æ–¹æ³•
> 
> **ä¸‹ä¸€éƒ¨åˆ†é¢„å‘Š**ï¼šæˆ‘ä»¬å°†æ·±å…¥å­¦ä¹ æŸ¥è¯¢æ„å»ºå™¨ã€äº‹åŠ¡å¤„ç†ã€æ•°æ®è¿ç§»ç­‰é«˜çº§ç‰¹æ€§ã€‚

**ğŸš€ ç»§ç»­å­¦ä¹ ç¬¬äºŒéƒ¨åˆ†ï¼ŒæŒæ¡TypeORMçš„é«˜çº§ç‰¹æ€§å’Œæ€§èƒ½ä¼˜åŒ–æŠ€å·§ï¼**

## ğŸ” ç¬¬ä¸‰èŠ‚ï¼šé«˜çº§æŸ¥è¯¢æŠ€æœ¯

### ğŸ› ï¸ 3.1 æŸ¥è¯¢æ„å»ºå™¨ (Query Builder)

#### ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦æŸ¥è¯¢æ„å»ºå™¨ï¼Ÿ

å½“ç®€å•çš„Repositoryæ–¹æ³•æ— æ³•æ»¡è¶³å¤æ‚æŸ¥è¯¢éœ€æ±‚æ—¶ï¼ŒæŸ¥è¯¢æ„å»ºå™¨æä¾›äº†æ›´çµæ´»çš„è§£å†³æ–¹æ¡ˆï¼š

```typescript
// ç®€å•æŸ¥è¯¢ï¼šRepositoryæ–¹æ³•è¶³å¤Ÿ
const users = await userRepository.find({ where: { status: 'active' } });

// å¤æ‚æŸ¥è¯¢ï¼šéœ€è¦æŸ¥è¯¢æ„å»ºå™¨
const result = await userRepository
  .createQueryBuilder('user')
  .leftJoinAndSelect('user.profile', 'profile')
  .leftJoinAndSelect('user.articles', 'article')
  .where('user.status = :status', { status: 'active' })
  .andWhere('article.publishedAt > :date', { date: new Date('2023-01-01') })
  .groupBy('user.id')
  .having('COUNT(article.id) > :count', { count: 5 })
  .orderBy('user.createdAt', 'DESC')
  .limit(10)
  .getMany();
```

#### ğŸ”§ åŸºç¡€æŸ¥è¯¢æ„å»º

```typescript
// services/article-query.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, SelectQueryBuilder } from 'typeorm';
import { Article, ArticleStatus } from '../entities/article.entity';

export interface ArticleQueryOptions {
  status?: ArticleStatus;
  authorId?: number;
  categoryId?: number;
  tags?: string[];
  search?: string;
  dateFrom?: Date;
  dateTo?: Date;
  page?: number;
  limit?: number;
  sortBy?: 'createdAt' | 'publishedAt' | 'viewCount' | 'likeCount';
  sortOrder?: 'ASC' | 'DESC';
}

@Injectable()
export class ArticleQueryService {
  constructor(
    @InjectRepository(Article)
    private articleRepository: Repository<Article>,
  ) {}
  
  private createBaseQuery(): SelectQueryBuilder<Article> {
    return this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags');
  }
  
  async findArticles(options: ArticleQueryOptions = {}) {
    const {
      status,
      authorId,
      categoryId,
      tags,
      search,
      dateFrom,
      dateTo,
      page = 1,
      limit = 10,
      sortBy = 'createdAt',
      sortOrder = 'DESC',
    } = options;
    
    let query = this.createBaseQuery();
    
    // çŠ¶æ€ç­›é€‰
    if (status) {
      query = query.andWhere('article.status = :status', { status });
    }
    
    // ä½œè€…ç­›é€‰
    if (authorId) {
      query = query.andWhere('article.authorId = :authorId', { authorId });
    }
    
    // åˆ†ç±»ç­›é€‰
    if (categoryId) {
      query = query.andWhere('article.categoryId = :categoryId', { categoryId });
    }
    
    // æ ‡ç­¾ç­›é€‰
    if (tags && tags.length > 0) {
      query = query.andWhere('tags.name IN (:...tags)', { tags });
    }
    
    // å…¨æ–‡æœç´¢
    if (search) {
      query = query.andWhere(
        '(article.title ILIKE :search OR article.content ILIKE :search OR article.summary ILIKE :search)',
        { search: `%${search}%` }
      );
    }
    
    // æ—¥æœŸèŒƒå›´ç­›é€‰
    if (dateFrom) {
      query = query.andWhere('article.publishedAt >= :dateFrom', { dateFrom });
    }
    if (dateTo) {
      query = query.andWhere('article.publishedAt <= :dateTo', { dateTo });
    }
    
    // æ’åº
    const sortField = `article.${sortBy}`;
    query = query.orderBy(sortField, sortOrder);
    
    // åˆ†é¡µ
    const offset = (page - 1) * limit;
    query = query.skip(offset).take(limit);
    
    // æ‰§è¡ŒæŸ¥è¯¢
    const [articles, total] = await query.getManyAndCount();
    
    return {
      articles,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1,
      },
    };
  }
  
  async getPopularArticles(limit: number = 10): Promise<Article[]> {
    return this.createBaseQuery()
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .orderBy('article.viewCount', 'DESC')
      .addOrderBy('article.likeCount', 'DESC')
      .limit(limit)
      .getMany();
  }
  
  async getArticlesByTag(tagName: string): Promise<Article[]> {
    return this.createBaseQuery()
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .andWhere('tags.name = :tagName', { tagName })
      .orderBy('article.publishedAt', 'DESC')
      .getMany();
  }
  
  async getArticleStats() {
    const result = await this.articleRepository
      .createQueryBuilder('article')
      .select([
        'COUNT(*) as total',
        'COUNT(CASE WHEN article.status = :published THEN 1 END) as published',
        'COUNT(CASE WHEN article.status = :draft THEN 1 END) as draft',
        'AVG(article.viewCount) as avgViews',
        'SUM(article.viewCount) as totalViews',
      ])
      .setParameters({
        published: ArticleStatus.PUBLISHED,
        draft: ArticleStatus.DRAFT,
      })
      .getRawOne();
    
    return {
      total: parseInt(result.total),
      published: parseInt(result.published),
      draft: parseInt(result.draft),
      avgViews: parseFloat(result.avgviews) || 0,
      totalViews: parseInt(result.totalviews) || 0,
    };
  }
}
```

#### ğŸ”— å¤æ‚å…³è”æŸ¥è¯¢

```typescript
// æŸ¥è¯¢ç”¨æˆ·åŠå…¶æ–‡ç« ç»Ÿè®¡ä¿¡æ¯
async getUsersWithArticleStats() {
  return this.userRepository
    .createQueryBuilder('user')
    .leftJoin('user.articles', 'article')
    .select([
      'user.id',
      'user.username',
      'user.email',
      'user.role',
      'COUNT(article.id) as articleCount',
      'COUNT(CASE WHEN article.status = :published THEN 1 END) as publishedCount',
      'SUM(article.viewCount) as totalViews',
      'AVG(article.viewCount) as avgViews',
    ])
    .where('user.status = :status', { status: UserStatus.ACTIVE })
    .setParameter('published', ArticleStatus.PUBLISHED)
    .groupBy('user.id')
    .orderBy('publishedCount', 'DESC')
    .getRawMany();
}

// æŸ¥è¯¢çƒ­é—¨æ ‡ç­¾
async getPopularTags(limit: number = 20) {
  return this.tagRepository
    .createQueryBuilder('tag')
    .leftJoin('tag.articles', 'article')
    .select([
      'tag.id',
      'tag.name',
      'COUNT(article.id) as articleCount',
    ])
    .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
    .groupBy('tag.id')
    .orderBy('articleCount', 'DESC')
    .limit(limit)
    .getRawMany();
}

// å­æŸ¥è¯¢ç¤ºä¾‹
async getAuthorsWithRecentArticles() {
  const subQuery = this.articleRepository
    .createQueryBuilder('article')
    .select('article.authorId')
    .where('article.publishedAt > :date', { date: new Date('2023-01-01') })
    .andWhere('article.status = :status', { status: ArticleStatus.PUBLISHED })
    .getQuery();
  
  return this.userRepository
    .createQueryBuilder('user')
    .where(`user.id IN (${subQuery})`)
    .setParameters({ date: new Date('2023-01-01'), status: ArticleStatus.PUBLISHED })
    .getMany();
}
```

### ğŸ’¾ 3.2 äº‹åŠ¡å¤„ç†

#### ğŸ¯ äº‹åŠ¡çš„é‡è¦æ€§

**ç”Ÿæ´»ç±»æ¯”**ï¼šäº‹åŠ¡å°±åƒé“¶è¡Œè½¬è´¦ï¼Œè¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥ï¼Œä¸èƒ½å‡ºç°é’±ä»Aè´¦æˆ·æ‰£äº†ä½†æ²¡åˆ°Bè´¦æˆ·çš„æƒ…å†µã€‚

```typescript
// æ²¡æœ‰äº‹åŠ¡çš„å±é™©æ“ä½œ
async transferPoints(fromUserId: number, toUserId: number, points: number) {
  // âŒ å¦‚æœç¬¬äºŒæ­¥å¤±è´¥ï¼Œç¬¬ä¸€æ­¥å·²ç»æ‰§è¡Œï¼Œæ•°æ®ä¸ä¸€è‡´
  await this.userRepository.decrement({ id: fromUserId }, 'points', points);
  await this.userRepository.increment({ id: toUserId }, 'points', points);
}

// ä½¿ç”¨äº‹åŠ¡çš„å®‰å…¨æ“ä½œ
async transferPointsSafely(fromUserId: number, toUserId: number, points: number) {
  return this.dataSource.transaction(async manager => {
    // âœ… è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å›æ»š
    await manager.decrement(User, { id: fromUserId }, 'points', points);
    await manager.increment(User, { id: toUserId }, 'points', points);
    
    // è®°å½•è½¬è´¦æ—¥å¿—
    await manager.save(PointsTransfer, {
      fromUserId,
      toUserId,
      points,
      createdAt: new Date(),
    });
  });
}
```

#### ğŸ”§ äº‹åŠ¡å®ç°æ–¹å¼

**æ–¹å¼1ï¼šä½¿ç”¨DataSourceäº‹åŠ¡**
```typescript
import { Injectable } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { User } from '../entities/user.entity';
import { Article } from '../entities/article.entity';

@Injectable()
export class ArticleService {
  constructor(private dataSource: DataSource) {}
  
  async publishArticle(articleId: number, authorId: number) {
    return this.dataSource.transaction(async manager => {
      // 1. æ›´æ–°æ–‡ç« çŠ¶æ€
      const article = await manager.findOne(Article, { 
        where: { id: articleId, authorId } 
      });
      
      if (!article) {
        throw new Error('Article not found');
      }
      
      article.status = ArticleStatus.PUBLISHED;
      article.publishedAt = new Date();
      await manager.save(article);
      
      // 2. æ›´æ–°ç”¨æˆ·æ–‡ç« è®¡æ•°
      await manager.increment(User, { id: authorId }, 'publishedArticleCount', 1);
      
      // 3. å¦‚æœæ˜¯ç”¨æˆ·ç¬¬ä¸€ç¯‡æ–‡ç« ï¼Œå‡çº§è§’è‰²
      const user = await manager.findOne(User, { where: { id: authorId } });
      if (user.publishedArticleCount === 1 && user.role === UserRole.READER) {
        user.role = UserRole.AUTHOR;
        await manager.save(user);
      }
      
      return article;
    });
  }
}
```

**æ–¹å¼2ï¼šä½¿ç”¨Repositoryäº‹åŠ¡**
```typescript
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(UserProfile)
    private profileRepository: Repository<UserProfile>,
  ) {}
  
  async createUserWithProfile(userData: CreateUserDto, profileData: CreateProfileDto) {
    const queryRunner = this.userRepository.manager.connection.createQueryRunner();
    
    await queryRunner.connect();
    await queryRunner.startTransaction();
    
    try {
      // 1. åˆ›å»ºç”¨æˆ·
      const user = queryRunner.manager.create(User, userData);
      const savedUser = await queryRunner.manager.save(user);
      
      // 2. åˆ›å»ºç”¨æˆ·èµ„æ–™
      const profile = queryRunner.manager.create(UserProfile, {
        ...profileData,
        userId: savedUser.id,
      });
      await queryRunner.manager.save(profile);
      
      // 3. å‘é€æ¬¢è¿é‚®ä»¶ï¼ˆå¦‚æœå¤±è´¥ä¸å½±å“ç”¨æˆ·åˆ›å»ºï¼‰
      try {
        await this.emailService.sendWelcomeEmail(savedUser.email);
      } catch (error) {
        console.warn('Failed to send welcome email:', error);
        // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸äº‹åŠ¡ç»§ç»­
      }
      
      await queryRunner.commitTransaction();
      return savedUser;
      
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }
}
```

**æ–¹å¼3ï¼šä½¿ç”¨è£…é¥°å™¨äº‹åŠ¡**
```typescript
import { Injectable } from '@nestjs/common';
import { InjectDataSource } from '@nestjs/typeorm';
import { DataSource } from 'typeorm';
import { Transactional } from 'typeorm-transactional';

@Injectable()
export class OrderService {
  constructor(
    @InjectDataSource()
    private dataSource: DataSource,
  ) {}
  
  @Transactional()
  async createOrder(orderData: CreateOrderDto) {
    // è¿™ä¸ªæ–¹æ³•ä¼šè‡ªåŠ¨åŒ…è£…åœ¨äº‹åŠ¡ä¸­
    const order = await this.orderRepository.save(orderData);
    
    // å‡å°‘åº“å­˜
    await this.productService.decreaseStock(orderData.productId, orderData.quantity);
    
    // åˆ›å»ºæ”¯ä»˜è®°å½•
    await this.paymentService.createPayment(order.id, orderData.amount);
    
    return order;
  }
}
```

#### ğŸ”’ äº‹åŠ¡éš”ç¦»çº§åˆ«

```typescript
// è®¾ç½®äº‹åŠ¡éš”ç¦»çº§åˆ«
async performCriticalOperation() {
  return this.dataSource.transaction(
    'SERIALIZABLE', // æœ€é«˜éš”ç¦»çº§åˆ«
    async manager => {
      // æ‰§è¡Œéœ€è¦é«˜ä¸€è‡´æ€§çš„æ“ä½œ
      const account = await manager.findOne(Account, { where: { id: 1 } });
      
      if (account.balance < 100) {
        throw new Error('Insufficient balance');
      }
      
      account.balance -= 100;
      await manager.save(account);
    }
  );
}

// ä¸åŒéš”ç¦»çº§åˆ«çš„ä½¿ç”¨åœºæ™¯
async readCommittedExample() {
  return this.dataSource.transaction(
    'READ COMMITTED', // é€‚åˆå¤§å¤šæ•°ä¸šåŠ¡åœºæ™¯
    async manager => {
      // æ‰§è¡Œä¸€èˆ¬çš„ä¸šåŠ¡æ“ä½œ
    }
  );
}
```

### ğŸ”„ 3.3 æ•°æ®è¿ç§»ç®¡ç†

#### ğŸ¯ ä»€ä¹ˆæ˜¯æ•°æ®è¿ç§»ï¼Ÿ

**ç”Ÿæ´»ç±»æ¯”**ï¼šæ•°æ®è¿ç§»å°±åƒæˆ¿å±‹è£…ä¿®ï¼Œéœ€è¦æœ‰è®¡åˆ’åœ°æ”¹å˜æ•°æ®åº“ç»“æ„ï¼ŒåŒæ—¶ä¿è¯æ•°æ®ä¸ä¸¢å¤±ã€‚

#### ğŸ“‹ è¿ç§»é…ç½®

```typescript
// config/migration.config.ts
import { DataSource } from 'typeorm';
import { ConfigService } from '@nestjs/config';

const configService = new ConfigService();

export const AppDataSource = new DataSource({
  type: 'postgres',
  host: configService.get('DB_HOST'),
  port: configService.get('DB_PORT'),
  username: configService.get('DB_USERNAME'),
  password: configService.get('DB_PASSWORD'),
  database: configService.get('DB_NAME'),
  entities: ['src/**/*.entity.ts'],
  migrations: ['src/migrations/*.ts'],
  synchronize: false, // ç”Ÿäº§ç¯å¢ƒå¿…é¡»ä¸ºfalse
  logging: true,
});
```

#### ğŸ› ï¸ åˆ›å»ºè¿ç§»æ–‡ä»¶

```bash
# ç”Ÿæˆè¿ç§»æ–‡ä»¶
npm run typeorm migration:generate -- src/migrations/CreateUserTable

# åˆ›å»ºç©ºç™½è¿ç§»æ–‡ä»¶
npm run typeorm migration:create -- src/migrations/AddUserIndexes

# è¿è¡Œè¿ç§»
npm run typeorm migration:run

# å›æ»šè¿ç§»
npm run typeorm migration:revert
```

#### ğŸ“ è¿ç§»æ–‡ä»¶ç¤ºä¾‹

```typescript
// migrations/1640995200000-CreateUserTable.ts
import { MigrationInterface, QueryRunner, Table, Index } from 'typeorm';

export class CreateUserTable1640995200000 implements MigrationInterface {
  name = 'CreateUserTable1640995200000';
  
  public async up(queryRunner: QueryRunner): Promise<void> {
    // åˆ›å»ºç”¨æˆ·è¡¨
    await queryRunner.createTable(
      new Table({
        name: 'users',
        columns: [
          {
            name: 'id',
            type: 'int',
            isPrimary: true,
            isGenerated: true,
            generationStrategy: 'increment',
          },
          {
            name: 'username',
            type: 'varchar',
            length: '50',
            isUnique: true,
          },
          {
            name: 'email',
            type: 'varchar',
            length: '100',
            isUnique: true,
          },
          {
            name: 'password_hash',
            type: 'varchar',
            length: '255',
          },
          {
            name: 'role',
            type: 'enum',
            enum: ['admin', 'author', 'reader'],
            default: "'reader'",
          },
          {
            name: 'status',
            type: 'enum',
            enum: ['active', 'inactive', 'suspended'],
            default: "'active'",
          },
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            onUpdate: 'CURRENT_TIMESTAMP',
          },
        ],
      }),
      true,
    );
    
    // åˆ›å»ºç´¢å¼•
    await queryRunner.createIndex(
      'users',
      new Index({
        name: 'IDX_USER_EMAIL',
        columnNames: ['email'],
      }),
    );
    
    await queryRunner.createIndex(
      'users',
      new Index({
        name: 'IDX_USER_USERNAME',
        columnNames: ['username'],
      }),
    );
  }
  
  public async down(queryRunner: QueryRunner): Promise<void> {
    // åˆ é™¤ç´¢å¼•
    await queryRunner.dropIndex('users', 'IDX_USER_EMAIL');
    await queryRunner.dropIndex('users', 'IDX_USER_USERNAME');
    
    // åˆ é™¤è¡¨
    await queryRunner.dropTable('users');
  }
}
```

```typescript
// migrations/1641000000000-AddUserProfileTable.ts
import { MigrationInterface, QueryRunner, Table, ForeignKey } from 'typeorm';

export class AddUserProfileTable1641000000000 implements MigrationInterface {
  name = 'AddUserProfileTable1641000000000';
  
  public async up(queryRunner: QueryRunner): Promise<void> {
    // åˆ›å»ºç”¨æˆ·èµ„æ–™è¡¨
    await queryRunner.createTable(
      new Table({
        name: 'user_profiles',
        columns: [
          {
            name: 'id',
            type: 'int',
            isPrimary: true,
            isGenerated: true,
            generationStrategy: 'increment',
          },
          {
            name: 'user_id',
            type: 'int',
            isUnique: true,
          },
          {
            name: 'first_name',
            type: 'varchar',
            length: '50',
            isNullable: true,
          },
          {
            name: 'last_name',
            type: 'varchar',
            length: '50',
            isNullable: true,
          },
          {
            name: 'bio',
            type: 'text',
            isNullable: true,
          },
          {
            name: 'avatar_url',
            type: 'varchar',
            length: '255',
            isNullable: true,
          },
          {
            name: 'birth_date',
            type: 'date',
            isNullable: true,
          },
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            onUpdate: 'CURRENT_TIMESTAMP',
          },
        ],
      }),
      true,
    );
    
    // åˆ›å»ºå¤–é”®çº¦æŸ
    await queryRunner.createForeignKey(
      'user_profiles',
      new ForeignKey({
        columnNames: ['user_id'],
        referencedColumnNames: ['id'],
        referencedTableName: 'users',
        onDelete: 'CASCADE',
      }),
    );
  }
  
  public async down(queryRunner: QueryRunner): Promise<void> {
    const table = await queryRunner.getTable('user_profiles');
    const foreignKey = table.foreignKeys.find(fk => fk.columnNames.indexOf('user_id') !== -1);
    await queryRunner.dropForeignKey('user_profiles', foreignKey);
    await queryRunner.dropTable('user_profiles');
  }
}
```

#### ğŸ”„ æ•°æ®è¿ç§»æœ€ä½³å®è·µ

```typitten
// migrations/1641100000000-MigrateUserData.ts
import { MigrationInterface, QueryRunner } from 'typeorm';

export class MigrateUserData1641100000000 implements MigrationInterface {
  name = 'MigrateUserData1641100000000';
  
  public async up(queryRunner: QueryRunner): Promise<void> {
    // æ·»åŠ æ–°å­—æ®µ
    await queryRunner.query(`
      ALTER TABLE users 
      ADD COLUMN full_name VARCHAR(100)
    `);
    
    // è¿ç§»ç°æœ‰æ•°æ®
    await queryRunner.query(`
      UPDATE users 
      SET full_name = CONCAT(first_name, ' ', last_name)
      WHERE first_name IS NOT NULL AND last_name IS NOT NULL
    `);
    
    // ä¸ºæ–°ç”¨æˆ·è®¾ç½®é»˜è®¤å€¼
    await queryRunner.query(`
      UPDATE users 
      SET full_name = username 
      WHERE full_name IS NULL
    `);
    
    // è®¾ç½®å­—æ®µä¸ºéç©º
    await queryRunner.query(`
      ALTER TABLE users 
      ALTER COLUMN full_name SET NOT NULL
    `);
  }
  
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`
      ALTER TABLE users 
      DROP COLUMN full_name
    `);
  }
}
```

## âš¡ ç¬¬å››èŠ‚ï¼šæ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ğŸ¯ 4.1 æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

#### ğŸ“Š N+1æŸ¥è¯¢é—®é¢˜è§£å†³

```typescript
// âŒ N+1æŸ¥è¯¢é—®é¢˜
async getBadArticleList() {
  const articles = await this.articleRepository.find(); // 1æ¬¡æŸ¥è¯¢
  
  for (const article of articles) {
    article.author = await this.userRepository.findOne({ 
      where: { id: article.authorId } 
    }); // Næ¬¡æŸ¥è¯¢
  }
  
  return articles;
}

// âœ… ä½¿ç”¨å…³è”æŸ¥è¯¢è§£å†³
async getGoodArticleList() {
  return this.articleRepository.find({
    relations: ['author', 'category', 'tags'], // 1æ¬¡æŸ¥è¯¢è§£å†³æ‰€æœ‰å…³è”
  });
}

// âœ… ä½¿ç”¨æŸ¥è¯¢æ„å»ºå™¨ä¼˜åŒ–
async getOptimizedArticleList() {
  return this.articleRepository
    .createQueryBuilder('article')
    .leftJoinAndSelect('article.author', 'author')
    .leftJoinAndSelect('article.category', 'category')
    .leftJoinAndSelect('article.tags', 'tags')
    .select([
      'article.id',
      'article.title',
      'article.summary',
      'article.publishedAt',
      'author.id',
      'author.username',
      'category.id',
      'category.name',
      'tags.id',
      'tags.name',
    ])
    .getMany();
}
```

#### ğŸ” ç´¢å¼•ä¼˜åŒ–ç­–ç•¥

```typescript
// å®ä½“ä¸­å®šä¹‰ç´¢å¼•
@Entity()
@Index(['status', 'publishedAt']) // å¤åˆç´¢å¼•
@Index(['authorId'])
@Index(['categoryId'])
export class Article extends BaseEntity {
  @Column()
  @Index() // å•å­—æ®µç´¢å¼•
  slug: string;
  
  @Column()
  status: ArticleStatus;
  
  @Column()
  publishedAt: Date;
  
  @Column()
  authorId: number;
  
  @Column()
  categoryId: number;
}

// æŸ¥è¯¢æ—¶åˆ©ç”¨ç´¢å¼•
async findArticlesByStatusAndDate(status: ArticleStatus, fromDate: Date) {
  return this.articleRepository
    .createQueryBuilder('article')
    .where('article.status = :status', { status })
    .andWhere('article.publishedAt >= :fromDate', { fromDate })
    .orderBy('article.publishedAt', 'DESC') // åˆ©ç”¨å¤åˆç´¢å¼•
    .getMany();
}
```

#### ğŸ“ˆ åˆ†é¡µä¼˜åŒ–

```typescript
// âŒ æ·±åº¦åˆ†é¡µæ€§èƒ½é—®é¢˜
async getBadPagination(page: number, limit: number) {
  const offset = (page - 1) * limit;
  return this.articleRepository.find({
    skip: offset, // å½“pageå¾ˆå¤§æ—¶ï¼Œæ€§èƒ½å¾ˆå·®
    take: limit,
  });
}

// âœ… æ¸¸æ ‡åˆ†é¡µä¼˜åŒ–
async getCursorPagination(cursor?: number, limit: number = 10) {
  const query = this.articleRepository
    .createQueryBuilder('article')
    .orderBy('article.id', 'DESC')
    .limit(limit + 1); // å¤šæŸ¥ä¸€æ¡åˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€é¡µ
  
  if (cursor) {
    query.where('article.id < :cursor', { cursor });
  }
  
  const articles = await query.getMany();
  const hasNext = articles.length > limit;
  
  if (hasNext) {
    articles.pop(); // ç§»é™¤å¤šæŸ¥çš„é‚£ä¸€æ¡
  }
  
  return {
    articles,
    hasNext,
    nextCursor: hasNext ? articles[articles.length - 1].id : null,
  };
}
```

### ğŸ—„ï¸ 4.2 ç¼“å­˜ç­–ç•¥

#### ğŸ’¾ æŸ¥è¯¢ç»“æœç¼“å­˜

```typescript
import { Injectable } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { CACHE_MANAGER, Inject } from '@nestjs/common';

@Injectable()
export class CachedArticleService {
  constructor(
    @InjectRepository(Article)
    private articleRepository: Repository<Article>,
    @Inject(CACHE_MANAGER)
    private cacheManager: Cache,
  ) {}
  
  async getPopularArticles(limit: number = 10): Promise<Article[]> {
    const cacheKey = `popular_articles_${limit}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    let articles = await this.cacheManager.get<Article[]>(cacheKey);
    
    if (!articles) {
      // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
      articles = await this.articleRepository
        .createQueryBuilder('article')
        .leftJoinAndSelect('article.author', 'author')
        .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
        .orderBy('article.viewCount', 'DESC')
        .limit(limit)
        .getMany();
      
      // å­˜å…¥ç¼“å­˜ï¼ŒTTLä¸º5åˆ†é’Ÿ
      await this.cacheManager.set(cacheKey, articles, 300);
    }
    
    return articles;
  }
  
  async invalidateArticleCache(articleId: number): Promise<void> {
    // æ–‡ç« æ›´æ–°æ—¶æ¸…é™¤ç›¸å…³ç¼“å­˜
    const keys = [
      `article_${articleId}`,
      'popular_articles_*',
      'recent_articles_*',
    ];
    
    for (const key of keys) {
      await this.cacheManager.del(key);
    }
  }
}
```

#### ğŸ”„ äºŒçº§ç¼“å­˜é…ç½®

```typescript
// app.module.ts
import { CacheModule } from '@nestjs/cache-manager';
import * as redisStore from 'cache-manager-redis-store';

@Module({
  imports: [
    CacheModule.register({
      store: redisStore,
      host: 'localhost',
      port: 6379,
      ttl: 600, // é»˜è®¤TTL 10åˆ†é’Ÿ
    }),
    TypeOrmModule.forRoot({
      // ... å…¶ä»–é…ç½®
      cache: {
        type: 'redis',
        options: {
          host: 'localhost',
          port: 6379,
        },
        duration: 30000, // 30ç§’
      },
    }),
  ],
})
export class AppModule {}

// ä½¿ç”¨æŸ¥è¯¢ç¼“å­˜
async getCachedArticles() {
  return this.articleRepository
    .createQueryBuilder('article')
    .cache(true) // å¯ç”¨æŸ¥è¯¢ç¼“å­˜
    .getMany();
}

// è‡ªå®šä¹‰ç¼“å­˜é”®å’Œæ—¶é—´
async getCachedArticlesByCategory(categoryId: number) {
  return this.articleRepository
    .createQueryBuilder('article')
    .where('article.categoryId = :categoryId', { categoryId })
    .cache(`articles_category_${categoryId}`, 60000) // ç¼“å­˜1åˆ†é’Ÿ
    .getMany();
}
```

### ğŸ”§ 4.3 è¿æ¥æ± ä¼˜åŒ–

```typescript
// è¿æ¥æ± é…ç½®
TypeOrmModule.forRoot({
  type: 'postgres',
  host: 'localhost',
  port: 5432,
  username: 'postgres',
  password: 'password',
  database: 'blog_db',
  
  // è¿æ¥æ± é…ç½®
  extra: {
    connectionLimit: 10,        // æœ€å¤§è¿æ¥æ•°
    acquireTimeout: 60000,      // è·å–è¿æ¥è¶…æ—¶æ—¶é—´
    timeout: 60000,             // æŸ¥è¯¢è¶…æ—¶æ—¶é—´
    reconnect: true,            // è‡ªåŠ¨é‡è¿
    reconnectTries: 3,          // é‡è¿æ¬¡æ•°
    reconnectInterval: 2000,    // é‡è¿é—´éš”
  },
  
  // è¿æ¥æ± ç›‘æ§
  logging: ['query', 'error', 'schema', 'warn', 'info', 'log'],
  logger: 'advanced-console',
}),
```

### ğŸ“Š 4.4 æ€§èƒ½ç›‘æ§

```typescript
// æŸ¥è¯¢æ€§èƒ½ç›‘æ§è£…é¥°å™¨
import { Injectable } from '@nestjs/common';
import { performance } from 'perf_hooks';

export function QueryPerformance(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value;
  
  descriptor.value = async function (...args: any[]) {
    const start = performance.now();
    
    try {
      const result = await method.apply(this, args);
      const end = performance.now();
      const duration = end - start;
      
      if (duration > 1000) { // è¶…è¿‡1ç§’çš„æŸ¥è¯¢è®°å½•è­¦å‘Š
        console.warn(`Slow query detected: ${propertyName} took ${duration.toFixed(2)}ms`);
      }
      
      return result;
    } catch (error) {
      const end = performance.now();
      const duration = end - start;
      console.error(`Query failed: ${propertyName} took ${duration.toFixed(2)}ms`, error);
      throw error;
    }
  };
}

// ä½¿ç”¨ç¤ºä¾‹
@Injectable()
export class ArticleService {
  @QueryPerformance
  async findComplexArticles() {
    return this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags')
      .getMany();
  }
}
```

---

> **ğŸ¯ ç¬¬äºŒéƒ¨åˆ†æ€»ç»“**ï¼š
> 
> æˆ‘ä»¬æ·±å…¥å­¦ä¹ äº†ï¼š
> 1. æŸ¥è¯¢æ„å»ºå™¨çš„é«˜çº§ç”¨æ³•å’Œå¤æ‚æŸ¥è¯¢æŠ€å·§
> 2. äº‹åŠ¡å¤„ç†çš„å¤šç§å®ç°æ–¹å¼å’Œæœ€ä½³å®è·µ
> 3. æ•°æ®è¿ç§»çš„å®Œæ•´æµç¨‹å’Œç‰ˆæœ¬æ§åˆ¶
> 4. æ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒç­–ç•¥å’Œç›‘æ§æ–¹æ³•
> 
> **ä¸‹ä¸€éƒ¨åˆ†é¢„å‘Š**ï¼šæˆ‘ä»¬å°†é€šè¿‡å®æˆ˜é¡¹ç›®æ•´åˆæ‰€æœ‰çŸ¥è¯†ç‚¹ï¼Œæ„å»ºä¸€ä¸ªå®Œæ•´çš„åšå®¢ç³»ç»Ÿæ•°æ®å±‚ã€‚

**ğŸš€ ç»§ç»­å­¦ä¹ ç¬¬ä¸‰éƒ¨åˆ†ï¼Œé€šè¿‡å®æˆ˜é¡¹ç›®å·©å›ºæ‰€å­¦çŸ¥è¯†ï¼**

## ğŸ¯ ç¬¬äº”èŠ‚ï¼šå®æˆ˜é¡¹ç›® - åšå®¢ç³»ç»Ÿæ•°æ®å±‚

### ğŸ“‹ 5.1 é¡¹ç›®éœ€æ±‚åˆ†æ

#### ğŸ¯ åŠŸèƒ½éœ€æ±‚
- **ç”¨æˆ·ç®¡ç†**ï¼šæ³¨å†Œã€ç™»å½•ã€ä¸ªäººèµ„æ–™ç®¡ç†
- **æ–‡ç« ç®¡ç†**ï¼šåˆ›å»ºã€ç¼–è¾‘ã€å‘å¸ƒã€åˆ é™¤æ–‡ç« 
- **åˆ†ç±»ç®¡ç†**ï¼šæ–‡ç« åˆ†ç±»ç»„ç»‡
- **æ ‡ç­¾ç³»ç»Ÿ**ï¼šæ–‡ç« æ ‡ç­¾ç®¡ç†
- **è¯„è®ºç³»ç»Ÿ**ï¼šæ–‡ç« è¯„è®ºåŠŸèƒ½
- **æœç´¢åŠŸèƒ½**ï¼šå…¨æ–‡æœç´¢å’Œç­›é€‰

#### ğŸ“Š æ•°æ®æ¨¡å‹è®¾è®¡

```mermaid
erDiagram
    USER {
        int id PK
        string username UK
        string email UK
        string password_hash
        enum role
        enum status
        timestamp created_at
        timestamp updated_at
    }
    
    USER_PROFILE {
        int id PK
        int user_id FK
        string first_name
        string last_name
        text bio
        string avatar_url
        date birth_date
    }
    
    ARTICLE {
        int id PK
        string title
        string slug UK
        text content
        string summary
        enum status
        int author_id FK
        int category_id FK
        int view_count
        int like_count
        timestamp published_at
        timestamp created_at
        timestamp updated_at
    }
    
    CATEGORY {
        int id PK
        string name UK
        string description
        string slug UK
        int parent_id FK
    }
    
    TAG {
        int id PK
        string name UK
        string color
    }
    
    ARTICLE_TAG {
        int article_id FK
        int tag_id FK
    }
    
    COMMENT {
        int id PK
        int article_id FK
        int user_id FK
        int parent_id FK
        text content
        enum status
        timestamp created_at
    }
    
    USER ||--|| USER_PROFILE : has
    USER ||--o{ ARTICLE : writes
    USER ||--o{ COMMENT : makes
    CATEGORY ||--o{ ARTICLE : contains
    CATEGORY ||--o{ CATEGORY : parent_of
    ARTICLE }o--o{ TAG : tagged_with
    ARTICLE ||--o{ COMMENT : has
    COMMENT ||--o{ COMMENT : replies_to
```

### ğŸ—ï¸ 5.2 å®Œæ•´å®ä½“å®ç°

#### ğŸ“ è¯„è®ºå®ä½“
```typescript
// entities/comment.entity.ts
import {
  Entity,
  Column,
  ManyToOne,
  OneToMany,
  Tree,
  TreeParent,
  TreeChildren,
  Index,
} from 'typeorm';
import { BaseEntity } from './base.entity';
import { User } from './user.entity';
import { Article } from './article.entity';

export enum CommentStatus {
  PENDING = 'pending',
  APPROVED = 'approved',
  REJECTED = 'rejected',
  SPAM = 'spam',
}

@Entity('comments')
@Tree('materialized-path')
@Index(['articleId', 'status'])
@Index(['userId'])
export class Comment extends BaseEntity {
  @Column({
    type: 'text',
    comment: 'è¯„è®ºå†…å®¹',
  })
  content: string;
  
  @Column({
    type: 'enum',
    enum: CommentStatus,
    default: CommentStatus.PENDING,
    comment: 'è¯„è®ºçŠ¶æ€',
  })
  status: CommentStatus;
  
  @Column({
    type: 'varchar',
    length: 45,
    nullable: true,
    comment: 'è¯„è®ºè€…IPåœ°å€',
  })
  ipAddress?: string;
  
  @Column({
    type: 'varchar',
    length: 500,
    nullable: true,
    comment: 'User Agent',
  })
  userAgent?: string;
  
  // å…³ç³»æ˜ å°„
  @ManyToOne(() => Article, article => article.comments, {
    onDelete: 'CASCADE',
  })
  article: Article;
  
  @Column()
  articleId: number;
  
  @ManyToOne(() => User, user => user.comments, {
    onDelete: 'CASCADE',
  })
  user: User;
  
  @Column()
  userId: number;
  
  // æ ‘å½¢ç»“æ„æ”¯æŒ
  @TreeParent()
  parent?: Comment;
  
  @TreeChildren()
  children: Comment[];
  
  // ä¸šåŠ¡æ–¹æ³•
  isApproved(): boolean {
    return this.status === CommentStatus.APPROVED;
  }
  
  approve(): void {
    this.status = CommentStatus.APPROVED;
  }
  
  reject(): void {
    this.status = CommentStatus.REJECTED;
  }
  
  markAsSpam(): void {
    this.status = CommentStatus.SPAM;
  }
}
```

#### ğŸ·ï¸ åˆ†ç±»å®ä½“ï¼ˆæ”¯æŒå±‚çº§ï¼‰
```typescript
// entities/category.entity.ts
import {
  Entity,
  Column,
  OneToMany,
  Tree,
  TreeParent,
  TreeChildren,
  Index,
} from 'typeorm';
import { BaseEntity } from './base.entity';
import { Article } from './article.entity';

@Entity('categories')
@Tree('nested-set')
@Index(['slug'])
export class Category extends BaseEntity {
  @Column({
    type: 'varchar',
    length: 100,
    unique: true,
    comment: 'åˆ†ç±»åç§°',
  })
  name: string;
  
  @Column({
    type: 'varchar',
    length: 100,
    unique: true,
    comment: 'URLå‹å¥½æ ‡è¯†ç¬¦',
  })
  slug: string;
  
  @Column({
    type: 'text',
    nullable: true,
    comment: 'åˆ†ç±»æè¿°',
  })
  description?: string;
  
  @Column({
    type: 'varchar',
    length: 7,
    default: '#007bff',
    comment: 'åˆ†ç±»é¢œè‰²',
  })
  color: string;
  
  @Column({
    type: 'varchar',
    length: 255,
    nullable: true,
    comment: 'åˆ†ç±»å›¾æ ‡',
  })
  icon?: string;
  
  @Column({
    type: 'int',
    default: 0,
    comment: 'æ’åºæƒé‡',
  })
  sortOrder: number;
  
  @Column({
    type: 'boolean',
    default: true,
    comment: 'æ˜¯å¦å¯ç”¨',
  })
  isActive: boolean;
  
  // æ ‘å½¢ç»“æ„
  @TreeParent()
  parent?: Category;
  
  @TreeChildren()
  children: Category[];
  
  // å…³ç³»æ˜ å°„
  @OneToMany(() => Article, article => article.category)
  articles: Article[];
  
  // ä¸šåŠ¡æ–¹æ³•
  getFullPath(): string {
    const path = [this.name];
    let current = this.parent;
    
    while (current) {
      path.unshift(current.name);
      current = current.parent;
    }
    
    return path.join(' > ');
  }
  
  isRoot(): boolean {
    return !this.parent;
  }
  
  hasChildren(): boolean {
    return this.children && this.children.length > 0;
  }
}
```

### ğŸ”§ 5.3 é«˜çº§æœåŠ¡å±‚å®ç°

#### ğŸ“Š æ–‡ç« ç»Ÿè®¡æœåŠ¡
```typescript
// services/article-statistics.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article, ArticleStatus } from '../entities/article.entity';
import { User } from '../entities/user.entity';
import { Category } from '../entities/category.entity';

export interface ArticleStats {
  totalArticles: number;
  publishedArticles: number;
  draftArticles: number;
  totalViews: number;
  averageViews: number;
  topAuthors: Array<{
    userId: number;
    username: string;
    articleCount: number;
    totalViews: number;
  }>;
  topCategories: Array<{
    categoryId: number;
    categoryName: string;
    articleCount: number;
  }>;
  monthlyStats: Array<{
    month: string;
    articleCount: number;
    viewCount: number;
  }>;
}

@Injectable()
export class ArticleStatisticsService {
  constructor(
    @InjectRepository(Article)
    private articleRepository: Repository<Article>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(Category)
    private categoryRepository: Repository<Category>,
  ) {}
  
  async getArticleStatistics(): Promise<ArticleStats> {
    const [
      basicStats,
      topAuthors,
      topCategories,
      monthlyStats,
    ] = await Promise.all([
      this.getBasicStats(),
      this.getTopAuthors(),
      this.getTopCategories(),
      this.getMonthlyStats(),
    ]);
    
    return {
      ...basicStats,
      topAuthors,
      topCategories,
      monthlyStats,
    };
  }
  
  private async getBasicStats() {
    const result = await this.articleRepository
      .createQueryBuilder('article')
      .select([
        'COUNT(*) as total_articles',
        'COUNT(CASE WHEN article.status = :published THEN 1 END) as published_articles',
        'COUNT(CASE WHEN article.status = :draft THEN 1 END) as draft_articles',
        'COALESCE(SUM(article.viewCount), 0) as total_views',
        'COALESCE(AVG(article.viewCount), 0) as average_views',
      ])
      .setParameters({
        published: ArticleStatus.PUBLISHED,
        draft: ArticleStatus.DRAFT,
      })
      .getRawOne();
    
    return {
      totalArticles: parseInt(result.total_articles),
      publishedArticles: parseInt(result.published_articles),
      draftArticles: parseInt(result.draft_articles),
      totalViews: parseInt(result.total_views),
      averageViews: parseFloat(result.average_views),
    };
  }
  
  private async getTopAuthors(limit: number = 10) {
    return this.articleRepository
      .createQueryBuilder('article')
      .innerJoin('article.author', 'user')
      .select([
        'user.id as userId',
        'user.username as username',
        'COUNT(article.id) as articleCount',
        'COALESCE(SUM(article.viewCount), 0) as totalViews',
      ])
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .groupBy('user.id, user.username')
      .orderBy('articleCount', 'DESC')
      .addOrderBy('totalViews', 'DESC')
      .limit(limit)
      .getRawMany();
  }
  
  private async getTopCategories(limit: number = 10) {
    return this.articleRepository
      .createQueryBuilder('article')
      .innerJoin('article.category', 'category')
      .select([
        'category.id as categoryId',
        'category.name as categoryName',
        'COUNT(article.id) as articleCount',
      ])
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .groupBy('category.id, category.name')
      .orderBy('articleCount', 'DESC')
      .limit(limit)
      .getRawMany();
  }
  
  private async getMonthlyStats(months: number = 12) {
    return this.articleRepository
      .createQueryBuilder('article')
      .select([
        "TO_CHAR(article.publishedAt, 'YYYY-MM') as month",
        'COUNT(article.id) as articleCount',
        'COALESCE(SUM(article.viewCount), 0) as viewCount',
      ])
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .andWhere('article.publishedAt >= :startDate', {
        startDate: new Date(Date.now() - months * 30 * 24 * 60 * 60 * 1000),
      })
      .groupBy("TO_CHAR(article.publishedAt, 'YYYY-MM')")
      .orderBy('month', 'DESC')
      .getRawMany();
  }
}
```

#### ğŸ” å…¨æ–‡æœç´¢æœåŠ¡
```typescript
// services/search.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article, ArticleStatus } from '../entities/article.entity';

export interface SearchOptions {
  query: string;
  categoryId?: number;
  tags?: string[];
  authorId?: number;
  dateFrom?: Date;
  dateTo?: Date;
  page?: number;
  limit?: number;
}

export interface SearchResult {
  articles: Article[];
  total: number;
  page: number;
  totalPages: number;
  suggestions?: string[];
}

@Injectable()
export class SearchService {
  constructor(
    @InjectRepository(Article)
    private articleRepository: Repository<Article>,
  ) {}
  
  async searchArticles(options: SearchOptions): Promise<SearchResult> {
    const {
      query,
      categoryId,
      tags,
      authorId,
      dateFrom,
      dateTo,
      page = 1,
      limit = 10,
    } = options;
    
    let queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags')
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED });
    
    // å…¨æ–‡æœç´¢
    if (query) {
      queryBuilder = queryBuilder.andWhere(
        `(
          to_tsvector('english', article.title) @@ plainto_tsquery('english', :query) OR
          to_tsvector('english', article.content) @@ plainto_tsquery('english', :query) OR
          to_tsvector('english', article.summary) @@ plainto_tsquery('english', :query)
        )`,
        { query }
      );
      
      // æ·»åŠ ç›¸å…³æ€§æ’åº
      queryBuilder = queryBuilder.addSelect(
        `(
          ts_rank(to_tsvector('english', article.title), plainto_tsquery('english', :query)) * 3 +
          ts_rank(to_tsvector('english', article.summary), plainto_tsquery('english', :query)) * 2 +
          ts_rank(to_tsvector('english', article.content), plainto_tsquery('english', :query))
        )`,
        'relevance'
      );
    }
    
    // å…¶ä»–ç­›é€‰æ¡ä»¶
    if (categoryId) {
      queryBuilder = queryBuilder.andWhere('article.categoryId = :categoryId', { categoryId });
    }
    
    if (tags && tags.length > 0) {
      queryBuilder = queryBuilder.andWhere('tags.name IN (:...tags)', { tags });
    }
    
    if (authorId) {
      queryBuilder = queryBuilder.andWhere('article.authorId = :authorId', { authorId });
    }
    
    if (dateFrom) {
      queryBuilder = queryBuilder.andWhere('article.publishedAt >= :dateFrom', { dateFrom });
    }
    
    if (dateTo) {
      queryBuilder = queryBuilder.andWhere('article.publishedAt <= :dateTo', { dateTo });
    }
    
    // æ’åº
    if (query) {
      queryBuilder = queryBuilder.orderBy('relevance', 'DESC');
    } else {
      queryBuilder = queryBuilder.orderBy('article.publishedAt', 'DESC');
    }
    
    // åˆ†é¡µ
    const offset = (page - 1) * limit;
    queryBuilder = queryBuilder.skip(offset).take(limit);
    
    const [articles, total] = await queryBuilder.getManyAndCount();
    
    return {
      articles,
      total,
      page,
      totalPages: Math.ceil(total / limit),
      suggestions: await this.getSearchSuggestions(query),
    };
  }
  
  private async getSearchSuggestions(query: string): Promise<string[]> {
    if (!query || query.length < 3) {
      return [];
    }
    
    const suggestions = await this.articleRepository
      .createQueryBuilder('article')
      .select('DISTINCT article.title')
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .andWhere('article.title ILIKE :query', { query: `%${query}%` })
      .limit(5)
      .getRawMany();
    
    return suggestions.map(s => s.title);
  }
}
```

### ğŸ§ª 5.4 æµ‹è¯•å®ç°

#### ğŸ”¬ å•å…ƒæµ‹è¯•ç¤ºä¾‹
```typescript
// tests/services/article.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ArticleService } from '../src/services/article.service';
import { Article, ArticleStatus } from '../src/entities/article.entity';
import { User, UserRole } from '../src/entities/user.entity';

describe('ArticleService', () => {
  let service: ArticleService;
  let articleRepository: Repository<Article>;
  
  const mockArticleRepository = {
    create: jest.fn(),
    save: jest.fn(),
    findOne: jest.fn(),
    find: jest.fn(),
    createQueryBuilder: jest.fn(),
  };
  
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ArticleService,
        {
          provide: getRepositoryToken(Article),
          useValue: mockArticleRepository,
        },
      ],
    }).compile();
    
    service = module.get<ArticleService>(ArticleService);
    articleRepository = module.get<Repository<Article>>(getRepositoryToken(Article));
  });
  
  describe('createArticle', () => {
    it('should create a new article', async () => {
      const createArticleDto = {
        title: 'Test Article',
        content: 'Test content',
        summary: 'Test summary',
      };
      
      const user = {
        id: 1,
        username: 'testuser',
        role: UserRole.AUTHOR,
      } as User;
      
      const expectedArticle = {
        id: 1,
        ...createArticleDto,
        author: user,
        status: ArticleStatus.DRAFT,
        createdAt: new Date(),
      } as Article;
      
      mockArticleRepository.create.mockReturnValue(expectedArticle);
      mockArticleRepository.save.mockResolvedValue(expectedArticle);
      
      const result = await service.createArticle(createArticleDto, user);
      
      expect(mockArticleRepository.create).toHaveBeenCalledWith({
        ...createArticleDto,
        author: user,
        status: ArticleStatus.DRAFT,
      });
      expect(mockArticleRepository.save).toHaveBeenCalledWith(expectedArticle);
      expect(result).toEqual(expectedArticle);
    });
  });
  
  describe('publishArticle', () => {
    it('should publish a draft article', async () => {
      const articleId = 1;
      const userId = 1;
      
      const article = {
        id: articleId,
        status: ArticleStatus.DRAFT,
        authorId: userId,
        publish: jest.fn(),
      } as any;
      
      mockArticleRepository.findOne.mockResolvedValue(article);
      mockArticleRepository.save.mockResolvedValue({
        ...article,
        status: ArticleStatus.PUBLISHED,
        publishedAt: new Date(),
      });
      
      const result = await service.publishArticle(articleId, userId);
      
      expect(article.publish).toHaveBeenCalled();
      expect(mockArticleRepository.save).toHaveBeenCalledWith(article);
      expect(result.status).toBe(ArticleStatus.PUBLISHED);
    });
    
    it('should throw error if article not found', async () => {
      mockArticleRepository.findOne.mockResolvedValue(null);
      
      await expect(service.publishArticle(1, 1)).rejects.toThrow('Article not found');
    });
  });
});
```

## ğŸ“š ç¬¬å…­èŠ‚ï¼šæœ€ä½³å®è·µæ€»ç»“

### ğŸ¯ 6.1 ä»£ç ç»„ç»‡æœ€ä½³å®è·µ

#### ğŸ“ ç›®å½•ç»“æ„å»ºè®®
```
src/
â”œâ”€â”€ entities/           # å®ä½“å®šä¹‰
â”‚   â”œâ”€â”€ base.entity.ts
â”‚   â”œâ”€â”€ user.entity.ts
â”‚   â”œâ”€â”€ article.entity.ts
â”‚   â””â”€â”€ ...
â”œâ”€â”€ repositories/       # è‡ªå®šä¹‰Repository
â”‚   â”œâ”€â”€ user.repository.ts
â”‚   â””â”€â”€ article.repository.ts
â”œâ”€â”€ services/          # ä¸šåŠ¡é€»è¾‘æœåŠ¡
â”‚   â”œâ”€â”€ user.service.ts
â”‚   â”œâ”€â”€ article.service.ts
â”‚   â””â”€â”€ search.service.ts
â”œâ”€â”€ dto/               # æ•°æ®ä¼ è¾“å¯¹è±¡
â”‚   â”œâ”€â”€ create-user.dto.ts
â”‚   â””â”€â”€ update-article.dto.ts
â”œâ”€â”€ migrations/        # æ•°æ®åº“è¿ç§»
â”‚   â””â”€â”€ 1640995200000-CreateUserTable.ts
â”œâ”€â”€ seeds/            # æ•°æ®ç§å­
â”‚   â””â”€â”€ user.seed.ts
â””â”€â”€ config/           # é…ç½®æ–‡ä»¶
    â””â”€â”€ database.config.ts
```

#### ğŸ”§ é…ç½®ç®¡ç†æœ€ä½³å®è·µ
```typescript
// config/database.config.ts
import { TypeOrmModuleOptions } from '@nestjs/typeorm';
import { ConfigService } from '@nestjs/config';

export const getDatabaseConfig = (configService: ConfigService): TypeOrmModuleOptions => {
  const isProduction = configService.get('NODE_ENV') === 'production';
  
  return {
    type: 'postgres',
    host: configService.get('DB_HOST'),
    port: configService.get('DB_PORT'),
    username: configService.get('DB_USERNAME'),
    password: configService.get('DB_PASSWORD'),
    database: configService.get('DB_NAME'),
    
    // å®ä½“å’Œè¿ç§»
    entities: [__dirname + '/../**/*.entity{.ts,.js}'],
    migrations: [__dirname + '/../migrations/*{.ts,.js}'],
    
    // ç¯å¢ƒç›¸å…³é…ç½®
    synchronize: !isProduction, // ç”Ÿäº§ç¯å¢ƒç¦ç”¨
    logging: !isProduction,
    dropSchema: false,
    
    // è¿æ¥æ± é…ç½®
    extra: {
      connectionLimit: configService.get('DB_CONNECTION_LIMIT', 10),
      acquireTimeout: 60000,
      timeout: 60000,
    },
    
    // SSLé…ç½®ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    ssl: isProduction ? { rejectUnauthorized: false } : false,
    
    // ç¼“å­˜é…ç½®
    cache: {
      type: 'redis',
      options: {
        host: configService.get('REDIS_HOST'),
        port: configService.get('REDIS_PORT'),
      },
      duration: 30000,
    },
  };
};
```

### âš ï¸ 6.2 å¸¸è§é™·é˜±å’Œè§£å†³æ–¹æ¡ˆ

#### ğŸš« é¿å…çš„å¸¸è§é”™è¯¯

**1. N+1æŸ¥è¯¢é—®é¢˜**
```typescript
// âŒ é”™è¯¯åšæ³•
async getBadArticleList() {
  const articles = await this.articleRepository.find();
  for (const article of articles) {
    article.author = await this.userRepository.findOne({ where: { id: article.authorId } });
  }
  return articles;
}

// âœ… æ­£ç¡®åšæ³•
async getGoodArticleList() {
  return this.articleRepository.find({
    relations: ['author', 'category'],
  });
}
```

**2. äº‹åŠ¡ä½¿ç”¨ä¸å½“**
```typescript
// âŒ é”™è¯¯åšæ³•ï¼šæ²¡æœ‰ä½¿ç”¨äº‹åŠ¡
async transferPoints(fromUserId: number, toUserId: number, points: number) {
  await this.userRepository.decrement({ id: fromUserId }, 'points', points);
  await this.userRepository.increment({ id: toUserId }, 'points', points);
}

// âœ… æ­£ç¡®åšæ³•ï¼šä½¿ç”¨äº‹åŠ¡
async transferPoints(fromUserId: number, toUserId: number, points: number) {
  return this.dataSource.transaction(async manager => {
    await manager.decrement(User, { id: fromUserId }, 'points', points);
    await manager.increment(User, { id: toUserId }, 'points', points);
  });
}
```

**3. ç¼ºå°‘ç´¢å¼•ä¼˜åŒ–**
```typescript
// âŒ é”™è¯¯åšæ³•ï¼šæ²¡æœ‰ç´¢å¼•çš„æŸ¥è¯¢
@Entity()
export class Article {
  @Column()
  status: string; // ç»å¸¸æŸ¥è¯¢ä½†æ²¡æœ‰ç´¢å¼•
  
  @Column()
  authorId: number; // ç»å¸¸æŸ¥è¯¢ä½†æ²¡æœ‰ç´¢å¼•
}

// âœ… æ­£ç¡®åšæ³•ï¼šæ·»åŠ å¿…è¦ç´¢å¼•
@Entity()
@Index(['status'])
@Index(['authorId'])
@Index(['status', 'publishedAt']) // å¤åˆç´¢å¼•
export class Article {
  @Column()
  status: string;
  
  @Column()
  authorId: number;
}
```

### ğŸ”’ 6.3 å®‰å…¨æœ€ä½³å®è·µ

#### ğŸ›¡ï¸ æ•°æ®éªŒè¯å’Œæ¸…ç†
```typescript
// dto/create-article.dto.ts
import { IsString, IsOptional, Length, IsEnum } from 'class-validator';
import { Transform } from 'class-transformer';
import { ArticleStatus } from '../entities/article.entity';

export class CreateArticleDto {
  @IsString()
  @Length(1, 200)
  @Transform(({ value }) => value.trim()) // æ¸…ç†ç©ºç™½å­—ç¬¦
  title: string;
  
  @IsString()
  @Length(1, 10000)
  content: string;
  
  @IsOptional()
  @IsString()
  @Length(0, 500)
  summary?: string;
  
  @IsOptional()
  @IsEnum(ArticleStatus)
  status?: ArticleStatus = ArticleStatus.DRAFT;
}
```

#### ğŸ” æ•æ„Ÿæ•°æ®å¤„ç†
```typescript
@Entity()
export class User {
  @Column({ select: false }) // é»˜è®¤æŸ¥è¯¢æ—¶ä¸åŒ…å«
  @Exclude() // åºåˆ—åŒ–æ—¶æ’é™¤
  passwordHash: string;
  
  @Column({ select: false })
  @Exclude()
  emailVerificationToken?: string;
  
  // å®‰å…¨çš„åºåˆ—åŒ–æ–¹æ³•
  toJSON() {
    const { passwordHash, emailVerificationToken, ...result } = this;
    return result;
  }
}
```

### ğŸ“Š 6.4 æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜

#### ğŸ“ˆ æŸ¥è¯¢æ€§èƒ½ç›‘æ§
```typescript
// interceptors/query-performance.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class QueryPerformanceInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const start = Date.now();
    
    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - start;
        if (duration > 1000) { // è¶…è¿‡1ç§’è®°å½•è­¦å‘Š
          console.warn(`Slow operation detected: ${duration.toFixed(2)}ms`);
        }
      }),
    );
  }
}
```

## ğŸ“ ç« èŠ‚æ€»ç»“ä¸æ£€éªŒ

### âœ… å­¦ä¹ æˆæœæ£€éªŒ

#### ğŸ“‹ çŸ¥è¯†ç‚¹æ£€æŸ¥æ¸…å•
- [ ] ç†è§£ORMè®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒæ€æƒ³
- [ ] æŒæ¡TypeORMå®ä½“å®šä¹‰å’Œå…³ç³»æ˜ å°„
- [ ] ç†Ÿç»ƒä½¿ç”¨æŸ¥è¯¢æ„å»ºå™¨è¿›è¡Œå¤æ‚æŸ¥è¯¢
- [ ] ç†è§£å¹¶èƒ½æ­£ç¡®ä½¿ç”¨äº‹åŠ¡å¤„ç†
- [ ] æŒæ¡æ•°æ®è¿ç§»çš„åˆ›å»ºå’Œç®¡ç†
- [ ] äº†è§£æ€§èƒ½ä¼˜åŒ–çš„åŸºæœ¬ç­–ç•¥
- [ ] èƒ½å¤Ÿè®¾è®¡åˆç†çš„æ•°æ®åº“æ¶æ„

#### ğŸ§ª å®è·µèƒ½åŠ›æµ‹è¯•

**æµ‹è¯•1ï¼šå®ä½“è®¾è®¡**
è®¾è®¡ä¸€ä¸ªç”µå•†ç³»ç»Ÿçš„æ ¸å¿ƒå®ä½“ï¼ˆç”¨æˆ·ã€å•†å“ã€è®¢å•ã€è®¢å•é¡¹ï¼‰ï¼ŒåŒ…å«é€‚å½“çš„å…³ç³»æ˜ å°„å’Œçº¦æŸã€‚

**æµ‹è¯•2ï¼šå¤æ‚æŸ¥è¯¢**
ç¼–å†™æŸ¥è¯¢è·å–ï¼š
- æ¯ä¸ªåˆ†ç±»ä¸‹çš„å•†å“æ•°é‡å’Œå¹³å‡ä»·æ ¼
- æœ€è¿‘30å¤©çš„é”€å”®ç»Ÿè®¡
- ç”¨æˆ·çš„è´­ä¹°å†å²å’Œåå¥½åˆ†æ

**æµ‹è¯•3ï¼šäº‹åŠ¡å¤„ç†**
å®ç°ä¸€ä¸ªå®Œæ•´çš„ä¸‹å•æµç¨‹ï¼ŒåŒ…æ‹¬ï¼š
- åˆ›å»ºè®¢å•
- å‡å°‘åº“å­˜
- åˆ›å»ºæ”¯ä»˜è®°å½•
- å‘é€é€šçŸ¥

### ğŸš€ ä¸‹ä¸€æ­¥å­¦ä¹ å»ºè®®

1. **æ·±å…¥å­¦ä¹ **ï¼š
   - ç ”ç©¶TypeORMçš„é«˜çº§ç‰¹æ€§
   - å­¦ä¹ æ•°æ®åº“æ€§èƒ½è°ƒä¼˜
   - äº†è§£åˆ†å¸ƒå¼æ•°æ®åº“è®¾è®¡

2. **å®è·µé¡¹ç›®**ï¼š
   - å®Œæˆåšå®¢ç³»ç»Ÿçš„å®Œæ•´å®ç°
   - å°è¯•æ„å»ºæ›´å¤æ‚çš„ä¸šåŠ¡ç³»ç»Ÿ
   - å‚ä¸å¼€æºé¡¹ç›®è´¡çŒ®

3. **æ‰©å±•çŸ¥è¯†**ï¼š
   - å­¦ä¹ NoSQLæ•°æ®åº“çš„ä½¿ç”¨
   - äº†è§£æ•°æ®åº“é›†ç¾¤å’Œåˆ†ç‰‡
   - ç ”ç©¶ç¼“å­˜ç­–ç•¥å’Œå®ç°

---

> **ğŸ¯ ç¬¬4ç« å­¦ä¹ æ€»ç»“**ï¼š
> 
> é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œæ‚¨å·²ç»æŒæ¡äº†ï¼š
> 1. **ORMè®¾è®¡æ¨¡å¼**çš„æ ¸å¿ƒæ€æƒ³å’Œä¼˜åŠ¿
> 2. **TypeORM**çš„é…ç½®ã€ä½¿ç”¨å’Œæœ€ä½³å®è·µ
> 3. **å®ä½“å…³ç³»æ˜ å°„**çš„è®¾è®¡å’Œå®ç°æ–¹æ³•
> 4. **æŸ¥è¯¢æ„å»ºå™¨**çš„é«˜çº§ç”¨æ³•å’Œä¼˜åŒ–æŠ€å·§
> 5. **äº‹åŠ¡å¤„ç†**çš„å¤šç§å®ç°æ–¹å¼
> 6. **æ•°æ®è¿ç§»**çš„ç®¡ç†å’Œç‰ˆæœ¬æ§åˆ¶
> 7. **æ€§èƒ½ä¼˜åŒ–**çš„ç­–ç•¥å’Œç›‘æ§æ–¹æ³•
> 8. **ä¼ä¸šçº§é¡¹ç›®**çš„æ•°æ®å±‚æ¶æ„è®¾è®¡
> 
> **æ­å–œæ‚¨ï¼** ç°åœ¨æ‚¨å·²ç»å…·å¤‡äº†æ„å»ºä¼ä¸šçº§NestJSåº”ç”¨æ•°æ®å±‚çš„èƒ½åŠ›ã€‚

**ğŸ‰ å‡†å¤‡å¥½è¿æ¥ä¸‹ä¸€ä¸ªæŒ‘æˆ˜äº†å—ï¼Ÿè®©æˆ‘ä»¬ç»§ç»­å­¦ä¹ ç¬¬5ç« ï¼šAPIè®¾è®¡å“²å­¦ä¸å®è·µï¼** 