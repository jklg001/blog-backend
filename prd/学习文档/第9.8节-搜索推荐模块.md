# ç¬¬9.8èŠ‚ æœç´¢æ¨èæ¨¡å—

> **æ™ºèƒ½å‘ç°** - æ„å»ºé«˜æ•ˆçš„å†…å®¹æœç´¢ä¸æ¨èç³»ç»Ÿ

## ğŸ“š æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

### ğŸ¯ çŸ¥è¯†ç›®æ ‡
- [ ] **æŒæ¡å…¨æ–‡æœç´¢å®ç°**ï¼šå­¦ä¼šä½¿ç”¨MySQLå…¨æ–‡ç´¢å¼•å’ŒElasticsearch
- [ ] **ç†è§£æ¨èç®—æ³•åŸç†**ï¼šæŒæ¡ååŒè¿‡æ»¤å’Œå†…å®¹æ¨èç®—æ³•
- [ ] **å­¦ä¼šçƒ­é—¨å†…å®¹ç»Ÿè®¡**ï¼šå®ç°åŸºäºç”¨æˆ·è¡Œä¸ºçš„çƒ­é—¨æ’åº
- [ ] **æŒæ¡æœç´¢ä¼˜åŒ–æŠ€æœ¯**ï¼šæå‡æœç´¢æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒ

### ğŸ› ï¸ æŠ€èƒ½ç›®æ ‡
- [ ] èƒ½å¤Ÿå®ç°é«˜æ•ˆçš„å…¨æ–‡æœç´¢åŠŸèƒ½
- [ ] èƒ½å¤Ÿè®¾è®¡æ™ºèƒ½æ¨èç³»ç»Ÿ
- [ ] èƒ½å¤Ÿç»Ÿè®¡å’Œåˆ†æçƒ­é—¨å†…å®¹
- [ ] èƒ½å¤Ÿä¼˜åŒ–æœç´¢ç»“æœå’Œæ€§èƒ½

### â° å­¦ä¹ æ—¶é•¿
- **ç†è®ºå­¦ä¹ **ï¼š2-3å°æ—¶
- **å®è·µå¼€å‘**ï¼š4-6å°æ—¶
- **æ€»è®¡æ—¶é•¿**ï¼š6-9å°æ—¶

---

## 9.8.1 å…¨æ–‡æœç´¢å®ç°

### ğŸ” MySQLå…¨æ–‡ç´¢å¼•

#### ğŸ“Š æœç´¢ç´¢å¼•è®¾è®¡

**æ›´æ–°æ–‡ç« è¡¨æ·»åŠ å…¨æ–‡ç´¢å¼•**ï¼š
```sql
-- ä¸ºæ–‡ç« è¡¨æ·»åŠ å…¨æ–‡ç´¢å¼•
ALTER TABLE articles 
ADD FULLTEXT INDEX ft_title_content (title, content);

-- ä¸ºæ ‡ç­¾è¡¨æ·»åŠ å…¨æ–‡ç´¢å¼•
ALTER TABLE tags 
ADD FULLTEXT INDEX ft_name_description (name, description);

-- ä¸ºåˆ†ç±»è¡¨æ·»åŠ å…¨æ–‡ç´¢å¼•
ALTER TABLE categories 
ADD FULLTEXT INDEX ft_name_description (name, description);
```

#### ğŸ› ï¸ æœç´¢æœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/search/search.service.ts**ï¼š
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article, ArticleStatus } from '../article/entities/article.entity';
import { Tag } from '../article/entities/tag.entity';
import { Category } from '../article/entities/category.entity';
import { User } from '../user/entities/user.entity';

export interface SearchResult {
  articles: Article[];
  tags: Tag[];
  categories: Category[];
  users: User[];
  total: number;
}

@Injectable()
export class SearchService {
  constructor(
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
    @InjectRepository(Tag)
    private readonly tagRepository: Repository<Tag>,
    @InjectRepository(Category)
    private readonly categoryRepository: Repository<Category>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  /**
   * å…¨æ–‡æœç´¢
   */
  async search(
    query: string,
    page: number = 1,
    limit: number = 20,
    type?: 'article' | 'tag' | 'category' | 'user',
  ): Promise<SearchResult> {
    const results: SearchResult = {
      articles: [],
      tags: [],
      categories: [],
      users: [],
      total: 0,
    };

    if (!query.trim()) {
      return results;
    }

    const searchTerm = this.prepareSearchTerm(query);

    if (!type || type === 'article') {
      results.articles = await this.searchArticles(searchTerm, page, limit);
    }

    if (!type || type === 'tag') {
      results.tags = await this.searchTags(searchTerm, page, limit);
    }

    if (!type || type === 'category') {
      results.categories = await this.searchCategories(searchTerm, page, limit);
    }

    if (!type || type === 'user') {
      results.users = await this.searchUsers(searchTerm, page, limit);
    }

    results.total = results.articles.length + results.tags.length + 
                   results.categories.length + results.users.length;

    return results;
  }

  /**
   * æœç´¢æ–‡ç« 
   */
  private async searchArticles(searchTerm: string, page: number, limit: number) {
    const queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags')
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED });

    // ä½¿ç”¨MySQLå…¨æ–‡æœç´¢
    queryBuilder.andWhere(
      'MATCH(article.title, article.content) AGAINST(:searchTerm IN NATURAL LANGUAGE MODE)',
      { searchTerm }
    );

    // æŒ‰ç›¸å…³æ€§æ’åº
    queryBuilder
      .addSelect(
        'MATCH(article.title, article.content) AGAINST(:searchTerm IN NATURAL LANGUAGE MODE)',
        'relevance'
      )
      .orderBy('relevance', 'DESC')
      .addOrderBy('article.createdAt', 'DESC');

    const skip = (page - 1) * limit;
    return queryBuilder.skip(skip).take(limit).getMany();
  }

  /**
   * æœç´¢æ ‡ç­¾
   */
  private async searchTags(searchTerm: string, page: number, limit: number) {
    return this.tagRepository
      .createQueryBuilder('tag')
      .where('tag.name LIKE :searchTerm OR tag.description LIKE :searchTerm', {
        searchTerm: `%${searchTerm}%`,
      })
      .orderBy('tag.usageCount', 'DESC')
      .skip((page - 1) * limit)
      .take(limit)
      .getMany();
  }

  /**
   * æœç´¢åˆ†ç±»
   */
  private async searchCategories(searchTerm: string, page: number, limit: number) {
    return this.categoryRepository
      .createQueryBuilder('category')
      .where('category.name LIKE :searchTerm OR category.description LIKE :searchTerm', {
        searchTerm: `%${searchTerm}%`,
      })
      .orderBy('category.articleCount', 'DESC')
      .skip((page - 1) * limit)
      .take(limit)
      .getMany();
  }

  /**
   * æœç´¢ç”¨æˆ·
   */
  private async searchUsers(searchTerm: string, page: number, limit: number) {
    return this.userRepository
      .createQueryBuilder('user')
      .leftJoinAndSelect('user.profile', 'profile')
      .where('user.username LIKE :searchTerm OR profile.displayName LIKE :searchTerm', {
        searchTerm: `%${searchTerm}%`,
      })
      .orderBy('user.createdAt', 'DESC')
      .skip((page - 1) * limit)
      .take(limit)
      .getMany();
  }

  /**
   * å‡†å¤‡æœç´¢è¯
   */
  private prepareSearchTerm(query: string): string {
    return query.trim().replace(/[+\-><()~*\"@]+/g, ' ');
  }

  /**
   * æœç´¢å»ºè®®
   */
  async getSearchSuggestions(query: string, limit: number = 10) {
    if (!query.trim()) {
      return [];
    }

    const searchTerm = `%${query}%`;
    
    const [articleTitles, tagNames, categoryNames] = await Promise.all([
      this.articleRepository
        .createQueryBuilder('article')
        .select('article.title')
        .where('article.title LIKE :searchTerm', { searchTerm })
        .andWhere('article.status = :status', { status: ArticleStatus.PUBLISHED })
        .orderBy('article.viewCount', 'DESC')
        .limit(limit)
        .getMany(),
      
      this.tagRepository
        .createQueryBuilder('tag')
        .select('tag.name')
        .where('tag.name LIKE :searchTerm', { searchTerm })
        .orderBy('tag.usageCount', 'DESC')
        .limit(limit)
        .getMany(),
      
      this.categoryRepository
        .createQueryBuilder('category')
        .select('category.name')
        .where('category.name LIKE :searchTerm', { searchTerm })
        .orderBy('category.articleCount', 'DESC')
        .limit(limit)
        .getMany(),
    ]);

    const suggestions = [
      ...articleTitles.map(a => a.title),
      ...tagNames.map(t => t.name),
      ...categoryNames.map(c => c.name),
    ];

    return [...new Set(suggestions)].slice(0, limit);
  }
}
```

---

## 9.8.2 æ™ºèƒ½æ¨èç®—æ³•

### ğŸ¯ æ¨èç³»ç»Ÿè®¾è®¡

#### ğŸ“Š ç”¨æˆ·è¡Œä¸ºå®ä½“

**åˆ›å»ºsrc/modules/recommendation/entities/user-behavior.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  Index,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';
import { Article } from '../../article/entities/article.entity';

export enum BehaviorType {
  VIEW = 'view',
  LIKE = 'like',
  BOOKMARK = 'bookmark',
  COMMENT = 'comment',
  SHARE = 'share',
}

@Entity('user_behaviors')
export class UserBehavior {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({
    type: 'enum',
    enum: BehaviorType,
  })
  @Index()
  type: BehaviorType;

  @Column({ type: 'decimal', precision: 3, scale: 2, default: 1.0 })
  weight: number;

  @Column({ type: 'json', nullable: true })
  metadata: any;

  @CreateDateColumn({ name: 'created_at' })
  @Index()
  createdAt: Date;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  @Index()
  user: User;

  @ManyToOne(() => Article, { onDelete: 'CASCADE' })
  @Index()
  article: Article;
}
```

#### ğŸ› ï¸ æ¨èæœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/recommendation/recommendation.service.ts**ï¼š
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article, ArticleStatus } from '../article/entities/article.entity';
import { UserBehavior, BehaviorType } from './entities/user-behavior.entity';
import { Tag } from '../article/entities/tag.entity';
import { Category } from '../article/entities/category.entity';

@Injectable()
export class RecommendationService {
  constructor(
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
    @InjectRepository(UserBehavior)
    private readonly behaviorRepository: Repository<UserBehavior>,
    @InjectRepository(Tag)
    private readonly tagRepository: Repository<Tag>,
    @InjectRepository(Category)
    private readonly categoryRepository: Repository<Category>,
  ) {}

  /**
   * è·å–ä¸ªæ€§åŒ–æ¨è
   */
  async getPersonalizedRecommendations(
    userId: string,
    limit: number = 20,
  ): Promise<Article[]> {
    // è·å–ç”¨æˆ·å…´è¶£æ ‡ç­¾
    const userInterests = await this.getUserInterests(userId);
    
    if (userInterests.length === 0) {
      // æ–°ç”¨æˆ·è¿”å›çƒ­é—¨æ–‡ç« 
      return this.getPopularArticles(limit);
    }

    // åŸºäºå†…å®¹çš„æ¨è
    const contentBasedRecommendations = await this.getContentBasedRecommendations(
      userInterests,
      userId,
      limit,
    );

    // ååŒè¿‡æ»¤æ¨è
    const collaborativeRecommendations = await this.getCollaborativeRecommendations(
      userId,
      limit,
    );

    // åˆå¹¶å’Œå»é‡æ¨èç»“æœ
    const recommendations = this.mergeRecommendations(
      contentBasedRecommendations,
      collaborativeRecommendations,
      limit,
    );

    return recommendations;
  }

  /**
   * è·å–ç”¨æˆ·å…´è¶£æ ‡ç­¾
   */
  private async getUserInterests(userId: string) {
    const behaviors = await this.behaviorRepository
      .createQueryBuilder('behavior')
      .leftJoinAndSelect('behavior.article', 'article')
      .leftJoinAndSelect('article.tags', 'tags')
      .leftJoinAndSelect('article.category', 'category')
      .where('behavior.user.id = :userId', { userId })
      .andWhere('behavior.createdAt > :date', {
        date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // æœ€è¿‘30å¤©
      })
      .getMany();

    const tagScores = new Map<string, number>();
    const categoryScores = new Map<string, number>();

    behaviors.forEach(behavior => {
      const weight = this.getBehaviorWeight(behavior.type);
      
      // ç»Ÿè®¡æ ‡ç­¾å…´è¶£
      behavior.article.tags?.forEach(tag => {
        const currentScore = tagScores.get(tag.id) || 0;
        tagScores.set(tag.id, currentScore + weight);
      });

      // ç»Ÿè®¡åˆ†ç±»å…´è¶£
      if (behavior.article.category) {
        const currentScore = categoryScores.get(behavior.article.category.id) || 0;
        categoryScores.set(behavior.article.category.id, currentScore + weight);
      }
    });

    return {
      tags: Array.from(tagScores.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([tagId]) => tagId),
      categories: Array.from(categoryScores.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([categoryId]) => categoryId),
    };
  }

  /**
   * åŸºäºå†…å®¹çš„æ¨è
   */
  private async getContentBasedRecommendations(
    userInterests: { tags: string[]; categories: string[] },
    userId: string,
    limit: number,
  ) {
    const queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags')
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .andWhere('article.author.id != :userId', { userId });

    // åŸºäºæ ‡ç­¾æ¨è
    if (userInterests.tags.length > 0) {
      queryBuilder.andWhere('tags.id IN (:...tagIds)', {
        tagIds: userInterests.tags,
      });
    }

    // åŸºäºåˆ†ç±»æ¨è
    if (userInterests.categories.length > 0) {
      queryBuilder.orWhere('category.id IN (:...categoryIds)', {
        categoryIds: userInterests.categories,
      });
    }

    return queryBuilder
      .orderBy('article.likeCount', 'DESC')
      .addOrderBy('article.viewCount', 'DESC')
      .take(limit)
      .getMany();
  }

  /**
   * ååŒè¿‡æ»¤æ¨è
   */
  private async getCollaborativeRecommendations(
    userId: string,
    limit: number,
  ) {
    // æ‰¾åˆ°ç›¸ä¼¼ç”¨æˆ·
    const similarUsers = await this.findSimilarUsers(userId, 10);
    
    if (similarUsers.length === 0) {
      return [];
    }

    // è·å–ç›¸ä¼¼ç”¨æˆ·å–œæ¬¢çš„æ–‡ç« 
    const recommendations = await this.behaviorRepository
      .createQueryBuilder('behavior')
      .leftJoinAndSelect('behavior.article', 'article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .where('behavior.user.id IN (:...userIds)', {
        userIds: similarUsers.map(u => u.id),
      })
      .andWhere('behavior.type IN (:...types)', {
        types: [BehaviorType.LIKE, BehaviorType.BOOKMARK],
      })
      .andWhere('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .andWhere('article.author.id != :userId', { userId })
      .groupBy('article.id')
      .orderBy('COUNT(behavior.id)', 'DESC')
      .take(limit)
      .getMany();

    return recommendations.map(behavior => behavior.article);
  }

  /**
   * æ‰¾åˆ°ç›¸ä¼¼ç”¨æˆ·
   */
  private async findSimilarUsers(userId: string, limit: number) {
    // è·å–å½“å‰ç”¨æˆ·çš„è¡Œä¸º
    const userBehaviors = await this.behaviorRepository.find({
      where: { user: { id: userId } },
      relations: ['article'],
    });

    const userArticleIds = userBehaviors.map(b => b.article.id);

    if (userArticleIds.length === 0) {
      return [];
    }

    // æ‰¾åˆ°æœ‰ç›¸ä¼¼è¡Œä¸ºçš„ç”¨æˆ·
    const similarUsers = await this.behaviorRepository
      .createQueryBuilder('behavior')
      .select('behavior.user.id', 'userId')
      .addSelect('COUNT(behavior.id)', 'commonBehaviors')
      .where('behavior.article.id IN (:...articleIds)', {
        articleIds: userArticleIds,
      })
      .andWhere('behavior.user.id != :userId', { userId })
      .groupBy('behavior.user.id')
      .having('COUNT(behavior.id) >= :minCommon', { minCommon: 2 })
      .orderBy('COUNT(behavior.id)', 'DESC')
      .limit(limit)
      .getRawMany();

    return similarUsers.map(u => ({ id: u.userId }));
  }

  /**
   * åˆå¹¶æ¨èç»“æœ
   */
  private mergeRecommendations(
    contentBased: Article[],
    collaborative: Article[],
    limit: number,
  ): Article[] {
    const seen = new Set<string>();
    const merged: Article[] = [];

    // äº¤æ›¿æ·»åŠ ä¸¤ç§æ¨èç»“æœ
    const maxLength = Math.max(contentBased.length, collaborative.length);
    
    for (let i = 0; i < maxLength && merged.length < limit; i++) {
      if (i < contentBased.length && !seen.has(contentBased[i].id)) {
        merged.push(contentBased[i]);
        seen.add(contentBased[i].id);
      }
      
      if (i < collaborative.length && !seen.has(collaborative[i].id) && merged.length < limit) {
        merged.push(collaborative[i]);
        seen.add(collaborative[i].id);
      }
    }

    return merged;
  }

  /**
   * è·å–è¡Œä¸ºæƒé‡
   */
  private getBehaviorWeight(type: BehaviorType): number {
    const weights = {
      [BehaviorType.VIEW]: 1,
      [BehaviorType.LIKE]: 3,
      [BehaviorType.BOOKMARK]: 5,
      [BehaviorType.COMMENT]: 4,
      [BehaviorType.SHARE]: 6,
    };
    
    return weights[type] || 1;
  }

  /**
   * è·å–çƒ­é—¨æ–‡ç« 
   */
  async getPopularArticles(limit: number = 20): Promise<Article[]> {
    return this.articleRepository.find({
      where: { status: ArticleStatus.PUBLISHED },
      relations: ['author', 'category', 'tags'],
      order: {
        viewCount: 'DESC',
        likeCount: 'DESC',
        createdAt: 'DESC',
      },
      take: limit,
    });
  }

  /**
   * è®°å½•ç”¨æˆ·è¡Œä¸º
   */
  async recordBehavior(
    userId: string,
    articleId: string,
    type: BehaviorType,
    metadata?: any,
  ) {
    const behavior = this.behaviorRepository.create({
      user: { id: userId },
      article: { id: articleId },
      type,
      weight: this.getBehaviorWeight(type),
      metadata,
    });

    return this.behaviorRepository.save(behavior);
  }
}
```

---

## 9.8.3 çƒ­é—¨å†…å®¹ç»Ÿè®¡

### ğŸ“Š çƒ­é—¨ç»Ÿè®¡æœåŠ¡

**åˆ›å»ºsrc/modules/analytics/analytics.service.ts**ï¼š
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article, ArticleStatus } from '../article/entities/article.entity';
import { Tag } from '../article/entities/tag.entity';
import { Category } from '../article/entities/category.entity';
import { UserBehavior, BehaviorType } from '../recommendation/entities/user-behavior.entity';

@Injectable()
export class AnalyticsService {
  constructor(
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
    @InjectRepository(Tag)
    private readonly tagRepository: Repository<Tag>,
    @InjectRepository(Category)
    private readonly categoryRepository: Repository<Category>,
    @InjectRepository(UserBehavior)
    private readonly behaviorRepository: Repository<UserBehavior>,
  ) {}

  /**
   * è·å–çƒ­é—¨æ–‡ç« 
   */
  async getHotArticles(
    period: 'day' | 'week' | 'month' | 'year' = 'week',
    limit: number = 20,
  ) {
    const startDate = this.getStartDate(period);
    
    const queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags')
      .where('article.status = :status', { status: ArticleStatus.PUBLISHED })
      .andWhere('article.publishedAt >= :startDate', { startDate });

    // è®¡ç®—çƒ­åº¦åˆ†æ•°
    queryBuilder
      .addSelect(
        '(article.viewCount * 1 + article.likeCount * 3 + article.commentCount * 5)',
        'hotScore'
      )
      .orderBy('hotScore', 'DESC')
      .addOrderBy('article.publishedAt', 'DESC');

    return queryBuilder.take(limit).getMany();
  }

  /**
   * è·å–çƒ­é—¨æ ‡ç­¾
   */
  async getHotTags(
    period: 'day' | 'week' | 'month' | 'year' = 'week',
    limit: number = 20,
  ) {
    const startDate = this.getStartDate(period);

    return this.behaviorRepository
      .createQueryBuilder('behavior')
      .leftJoin('behavior.article', 'article')
      .leftJoin('article.tags', 'tags')
      .select('tags.id', 'tagId')
      .addSelect('tags.name', 'tagName')
      .addSelect('tags.color', 'tagColor')
      .addSelect('COUNT(behavior.id)', 'behaviorCount')
      .addSelect('SUM(behavior.weight)', 'totalWeight')
      .where('behavior.createdAt >= :startDate', { startDate })
      .andWhere('tags.id IS NOT NULL')
      .groupBy('tags.id')
      .orderBy('totalWeight', 'DESC')
      .addOrderBy('behaviorCount', 'DESC')
      .limit(limit)
      .getRawMany();
  }

  /**
   * è·å–çƒ­é—¨åˆ†ç±»
   */
  async getHotCategories(
    period: 'day' | 'week' | 'month' | 'year' = 'week',
    limit: number = 10,
  ) {
    const startDate = this.getStartDate(period);

    return this.behaviorRepository
      .createQueryBuilder('behavior')
      .leftJoin('behavior.article', 'article')
      .leftJoin('article.category', 'category')
      .select('category.id', 'categoryId')
      .addSelect('category.name', 'categoryName')
      .addSelect('COUNT(behavior.id)', 'behaviorCount')
      .addSelect('SUM(behavior.weight)', 'totalWeight')
      .where('behavior.createdAt >= :startDate', { startDate })
      .andWhere('category.id IS NOT NULL')
      .groupBy('category.id')
      .orderBy('totalWeight', 'DESC')
      .addOrderBy('behaviorCount', 'DESC')
      .limit(limit)
      .getRawMany();
  }

  /**
   * è·å–è¶‹åŠ¿æ•°æ®
   */
  async getTrendingData(period: 'day' | 'week' | 'month' = 'week') {
    const startDate = this.getStartDate(period);
    const intervals = this.getIntervals(period);

    const trendData = [];

    for (const interval of intervals) {
      const data = await this.behaviorRepository
        .createQueryBuilder('behavior')
        .select('COUNT(behavior.id)', 'count')
        .addSelect('behavior.type', 'type')
        .where('behavior.createdAt >= :start', { start: interval.start })
        .andWhere('behavior.createdAt < :end', { end: interval.end })
        .groupBy('behavior.type')
        .getRawMany();

      trendData.push({
        period: interval.label,
        data: data.reduce((acc, item) => {
          acc[item.type] = parseInt(item.count);
          return acc;
        }, {}),
      });
    }

    return trendData;
  }

  /**
   * è·å–æœç´¢çƒ­è¯
   */
  async getHotSearchTerms(limit: number = 20) {
    // è¿™é‡Œéœ€è¦è®°å½•æœç´¢æ—¥å¿—ï¼Œæš‚æ—¶è¿”å›çƒ­é—¨æ ‡ç­¾ä½œä¸ºç¤ºä¾‹
    return this.tagRepository
      .createQueryBuilder('tag')
      .orderBy('tag.usageCount', 'DESC')
      .take(limit)
      .getMany();
  }

  private getStartDate(period: string): Date {
    const now = new Date();
    switch (period) {
      case 'day':
        return new Date(now.getTime() - 24 * 60 * 60 * 1000);
      case 'week':
        return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      case 'month':
        return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
      case 'year':
        return new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
      default:
        return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    }
  }

  private getIntervals(period: string) {
    const now = new Date();
    const intervals = [];

    switch (period) {
      case 'day':
        for (let i = 23; i >= 0; i--) {
          const start = new Date(now.getTime() - (i + 1) * 60 * 60 * 1000);
          const end = new Date(now.getTime() - i * 60 * 60 * 1000);
          intervals.push({
            start,
            end,
            label: start.getHours() + ':00',
          });
        }
        break;
      case 'week':
        for (let i = 6; i >= 0; i--) {
          const start = new Date(now.getTime() - (i + 1) * 24 * 60 * 60 * 1000);
          const end = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
          intervals.push({
            start,
            end,
            label: start.toLocaleDateString(),
          });
        }
        break;
      case 'month':
        for (let i = 29; i >= 0; i--) {
          const start = new Date(now.getTime() - (i + 1) * 24 * 60 * 60 * 1000);
          const end = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
          intervals.push({
            start,
            end,
            label: start.toLocaleDateString(),
          });
        }
        break;
    }

    return intervals;
  }
}
```

---

## ğŸ“Š æœ¬èŠ‚æ€»ç»“

### ğŸ¯ å…³é”®è¦ç‚¹å›é¡¾

1. **å…¨æ–‡æœç´¢è¦é«˜æ•ˆå‡†ç¡®**
   - MySQLå…¨æ–‡ç´¢å¼•ä¼˜åŒ–
   - æœç´¢ç»“æœç›¸å…³æ€§æ’åº
   - æœç´¢å»ºè®®å’Œè‡ªåŠ¨è¡¥å…¨

2. **æ¨èç®—æ³•è¦ä¸ªæ€§åŒ–**
   - åŸºäºå†…å®¹çš„æ¨è
   - ååŒè¿‡æ»¤ç®—æ³•
   - ç”¨æˆ·è¡Œä¸ºåˆ†æ

3. **çƒ­é—¨ç»Ÿè®¡è¦å®æ—¶å‡†ç¡®**
   - å¤šç»´åº¦çƒ­åº¦è®¡ç®—
   - è¶‹åŠ¿æ•°æ®åˆ†æ
   - çƒ­é—¨å†…å®¹æ’è¡Œ

4. **æœç´¢ä½“éªŒè¦ç”¨æˆ·å‹å¥½**
   - å¿«é€Ÿå“åº”æ—¶é—´
   - æ™ºèƒ½æœç´¢å»ºè®®
   - å¤šç±»å‹å†…å®¹æœç´¢

### ğŸ“ å®è·µç»ƒä¹ 

#### ç»ƒä¹ 1ï¼šæœç´¢åŠŸèƒ½å®ç°
**ä»»åŠ¡**ï¼šå®ç°å®Œæ•´çš„æœç´¢åŠŸèƒ½
**è¦æ±‚**ï¼š
- å®ç°å…¨æ–‡æœç´¢
- æ·»åŠ æœç´¢å»ºè®®
- å®ç°æœç´¢ç»“æœæ’åº
- æ·»åŠ æœç´¢ç»Ÿè®¡

#### ç»ƒä¹ 2ï¼šæ¨èç³»ç»Ÿè®¾è®¡
**ä»»åŠ¡**ï¼šå®ç°æ™ºèƒ½æ¨èç³»ç»Ÿ
**è¦æ±‚**ï¼š
- å®ç°ç”¨æˆ·è¡Œä¸ºè®°å½•
- è®¾è®¡æ¨èç®—æ³•
- å®ç°ä¸ªæ€§åŒ–æ¨è
- æ·»åŠ æ¨èæ•ˆæœè¯„ä¼°

### ğŸ” è‡ªæˆ‘æ£€æµ‹

- [ ] æˆ‘èƒ½å¤Ÿå®ç°é«˜æ•ˆçš„å…¨æ–‡æœç´¢
- [ ] æˆ‘ç†è§£æ¨èç®—æ³•çš„åŸºæœ¬åŸç†
- [ ] æˆ‘æŒæ¡äº†çƒ­é—¨å†…å®¹ç»Ÿè®¡æ–¹æ³•
- [ ] æˆ‘äº†è§£æœç´¢ä¼˜åŒ–çš„æŠ€æœ¯è¦ç‚¹

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ 

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… å…¨æ–‡æœç´¢å®ç°
- âœ… æ™ºèƒ½æ¨èç®—æ³•
- âœ… çƒ­é—¨å†…å®¹ç»Ÿè®¡
- âœ… æœç´¢ç»“æœä¼˜åŒ–

**å‡†å¤‡å¥½è¿›å…¥ç¬¬9.9èŠ‚äº†å—ï¼Ÿ** ğŸš€

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å»ºè®¾æµ‹è¯•ä½“ç³»ï¼ŒåŒ…æ‹¬ï¼š
- ğŸ§ª å•å…ƒæµ‹è¯•ç¼–å†™
- ğŸ”„ é›†æˆæµ‹è¯•è®¾è®¡
- ğŸ“Š æµ‹è¯•è¦†ç›–ç‡åˆ†æ
- ğŸš€ è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹ 