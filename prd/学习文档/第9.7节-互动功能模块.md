# ç¬¬9.7èŠ‚ äº’åŠ¨åŠŸèƒ½æ¨¡å—

> **è¿æ¥ç”¨æˆ·** - æ„å»ºæ´»è·ƒçš„ç¤¾åŒºäº’åŠ¨ä½“ç³»

## ğŸ“š æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

### ğŸ¯ çŸ¥è¯†ç›®æ ‡
- [ ] **æŒæ¡è¯„è®ºç³»ç»Ÿè®¾è®¡**ï¼šå­¦ä¼šå®ç°å¤šå±‚çº§è¯„è®ºå’Œå›å¤åŠŸèƒ½
- [ ] **ç†è§£ç‚¹èµæ”¶è—æœºåˆ¶**ï¼šæŒæ¡ç”¨æˆ·äº’åŠ¨è¡Œä¸ºçš„æ•°æ®è®¾è®¡
- [ ] **å­¦ä¼šå…³æ³¨ç³»ç»Ÿå®ç°**ï¼šå»ºç«‹ç”¨æˆ·ä¹‹é—´çš„ç¤¾äº¤å…³ç³»
- [ ] **æŒæ¡é€šçŸ¥æœºåˆ¶è®¾è®¡**ï¼šå®ç°å®æ—¶çš„ç”¨æˆ·é€šçŸ¥ç³»ç»Ÿ

### ğŸ› ï¸ æŠ€èƒ½ç›®æ ‡
- [ ] èƒ½å¤Ÿå®ç°å®Œæ•´çš„è¯„è®ºç³»ç»Ÿ
- [ ] èƒ½å¤Ÿè®¾è®¡ç‚¹èµå’Œæ”¶è—åŠŸèƒ½
- [ ] èƒ½å¤Ÿå»ºç«‹ç”¨æˆ·å…³æ³¨å…³ç³»
- [ ] èƒ½å¤Ÿå®ç°é€šçŸ¥æ¨é€æœºåˆ¶

### â° å­¦ä¹ æ—¶é•¿
- **ç†è®ºå­¦ä¹ **ï¼š2-3å°æ—¶
- **å®è·µå¼€å‘**ï¼š4-5å°æ—¶
- **æ€»è®¡æ—¶é•¿**ï¼š6-8å°æ—¶

---

## 9.7.1 è¯„è®ºç³»ç»Ÿå®ç°

### ğŸ’¬ è¯„è®ºå®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/comment/entities/comment.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  OneToMany,
  Tree,
  TreeChildren,
  TreeParent,
  Index,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';
import { Article } from '../../article/entities/article.entity';

export enum CommentStatus {
  PUBLISHED = 'published',
  PENDING = 'pending',
  SPAM = 'spam',
  DELETED = 'deleted',
}

@Entity('comments')
@Tree('closure-table')
export class Comment {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ type: 'text' })
  content: string;

  @Column({
    type: 'enum',
    enum: CommentStatus,
    default: CommentStatus.PUBLISHED,
  })
  @Index()
  status: CommentStatus;

  @Column({ name: 'like_count', default: 0 })
  likeCount: number;

  @Column({ name: 'reply_count', default: 0 })
  replyCount: number;

  @Column({ name: 'ip_address', nullable: true })
  ipAddress: string;

  @Column({ name: 'user_agent', type: 'text', nullable: true })
  userAgent: string;

  @CreateDateColumn({ name: 'created_at' })
  @Index()
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // å…³è”å…³ç³»
  @ManyToOne(() => Article, article => article.comments, { onDelete: 'CASCADE' })
  @Index()
  article: Article;

  @ManyToOne(() => User, user => user.comments)
  author: User;

  // æ ‘å½¢ç»“æ„ï¼ˆæ”¯æŒå¤šå±‚çº§å›å¤ï¼‰
  @TreeParent()
  parent: Comment;

  @TreeChildren()
  children: Comment[];
}
```

### ğŸ“ è¯„è®ºDTOè®¾è®¡

**åˆ›å»ºsrc/modules/comment/dto/create-comment.dto.ts**ï¼š
```typescript
import {
  IsString,
  IsUUID,
  IsOptional,
  MinLength,
  MaxLength,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateCommentDto {
  @ApiProperty({ description: 'è¯„è®ºå†…å®¹' })
  @IsString()
  @MinLength(1, { message: 'è¯„è®ºå†…å®¹ä¸èƒ½ä¸ºç©º' })
  @MaxLength(1000, { message: 'è¯„è®ºå†…å®¹ä¸èƒ½è¶…è¿‡1000ä¸ªå­—ç¬¦' })
  content: string;

  @ApiProperty({ description: 'æ–‡ç« ID' })
  @IsUUID('4', { message: 'æ–‡ç« IDæ ¼å¼ä¸æ­£ç¡®' })
  articleId: string;

  @ApiProperty({ description: 'çˆ¶è¯„è®ºID', required: false })
  @IsOptional()
  @IsUUID('4', { message: 'çˆ¶è¯„è®ºIDæ ¼å¼ä¸æ­£ç¡®' })
  parentId?: string;
}
```

### ğŸ› ï¸ è¯„è®ºæœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/comment/comment.service.ts**ï¼š
```typescript
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Comment, CommentStatus } from './entities/comment.entity';
import { Article } from '../article/entities/article.entity';
import { CreateCommentDto } from './dto/create-comment.dto';
import { QueryCommentDto } from './dto/query-comment.dto';

@Injectable()
export class CommentService {
  constructor(
    @InjectRepository(Comment)
    private readonly commentRepository: Repository<Comment>,
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
  ) {}

  /**
   * åˆ›å»ºè¯„è®º
   */
  async create(
    createCommentDto: CreateCommentDto,
    userId: string,
    ipAddress: string,
    userAgent: string,
  ) {
    const { articleId, parentId, content } = createCommentDto;

    // éªŒè¯æ–‡ç« æ˜¯å¦å­˜åœ¨
    const article = await this.articleRepository.findOne({
      where: { id: articleId },
    });

    if (!article) {
      throw new NotFoundException('æ–‡ç« ä¸å­˜åœ¨');
    }

    // éªŒè¯çˆ¶è¯„è®ºï¼ˆå¦‚æœæ˜¯å›å¤ï¼‰
    let parent = null;
    if (parentId) {
      parent = await this.commentRepository.findOne({
        where: { id: parentId, article: { id: articleId } },
      });

      if (!parent) {
        throw new NotFoundException('çˆ¶è¯„è®ºä¸å­˜åœ¨');
      }
    }

    const comment = this.commentRepository.create({
      content,
      article,
      parent,
      author: { id: userId },
      ipAddress,
      userAgent,
      status: CommentStatus.PUBLISHED,
    });

    const savedComment = await this.commentRepository.save(comment);

    // æ›´æ–°æ–‡ç« è¯„è®ºæ•°
    await this.articleRepository.increment({ id: articleId }, 'commentCount', 1);

    // æ›´æ–°çˆ¶è¯„è®ºå›å¤æ•°
    if (parent) {
      await this.commentRepository.increment({ id: parentId }, 'replyCount', 1);
    }

    return savedComment;
  }

  /**
   * è·å–æ–‡ç« è¯„è®ºåˆ—è¡¨
   */
  async findByArticle(articleId: string, queryDto: QueryCommentDto) {
    const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'DESC' } = queryDto;

    const queryBuilder = this.commentRepository
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.author', 'author')
      .leftJoinAndSelect('comment.children', 'children')
      .leftJoinAndSelect('children.author', 'childrenAuthor')
      .where('comment.article.id = :articleId', { articleId })
      .andWhere('comment.status = :status', { status: CommentStatus.PUBLISHED })
      .andWhere('comment.parent IS NULL') // åªè·å–é¡¶çº§è¯„è®º
      .orderBy(`comment.${sortBy}`, sortOrder as 'ASC' | 'DESC');

    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * è·å–è¯„è®ºå›å¤
   */
  async findReplies(commentId: string, queryDto: QueryCommentDto) {
    const { page = 1, limit = 10 } = queryDto;

    const queryBuilder = this.commentRepository
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.author', 'author')
      .where('comment.parent.id = :commentId', { commentId })
      .andWhere('comment.status = :status', { status: CommentStatus.PUBLISHED })
      .orderBy('comment.createdAt', 'ASC');

    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * åˆ é™¤è¯„è®º
   */
  async remove(id: string, userId: string) {
    const comment = await this.commentRepository.findOne({
      where: { id },
      relations: ['author', 'article'],
    });

    if (!comment) {
      throw new NotFoundException('è¯„è®ºä¸å­˜åœ¨');
    }

    // æƒé™æ£€æŸ¥
    if (comment.author.id !== userId) {
      throw new ForbiddenException('æ— æƒé™åˆ é™¤æ­¤è¯„è®º');
    }

    // è½¯åˆ é™¤
    comment.status = CommentStatus.DELETED;
    await this.commentRepository.save(comment);

    // æ›´æ–°æ–‡ç« è¯„è®ºæ•°
    await this.articleRepository.decrement(
      { id: comment.article.id },
      'commentCount',
      1,
    );

    return { message: 'è¯„è®ºåˆ é™¤æˆåŠŸ' };
  }
}
```

---

## 9.7.2 ç‚¹èµæ”¶è—åŠŸèƒ½

### ğŸ‘ ç‚¹èµå®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/interaction/entities/like.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  Unique,
  Index,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';

export enum LikeTargetType {
  ARTICLE = 'article',
  COMMENT = 'comment',
}

@Entity('likes')
@Unique(['user', 'targetType', 'targetId'])
export class Like {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({
    type: 'enum',
    enum: LikeTargetType,
  })
  @Index()
  targetType: LikeTargetType;

  @Column({ name: 'target_id' })
  @Index()
  targetId: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  user: User;
}
```

### ğŸ“š æ”¶è—å®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/interaction/entities/bookmark.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  ManyToOne,
  Unique,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';
import { Article } from '../../article/entities/article.entity';

@Entity('bookmarks')
@Unique(['user', 'article'])
export class Bookmark {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  user: User;

  @ManyToOne(() => Article, { onDelete: 'CASCADE' })
  article: Article;
}
```

### ğŸ› ï¸ äº’åŠ¨æœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/interaction/interaction.service.ts**ï¼š
```typescript
import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Like, LikeTargetType } from './entities/like.entity';
import { Bookmark } from './entities/bookmark.entity';
import { Article } from '../article/entities/article.entity';
import { Comment } from '../comment/entities/comment.entity';

@Injectable()
export class InteractionService {
  constructor(
    @InjectRepository(Like)
    private readonly likeRepository: Repository<Like>,
    @InjectRepository(Bookmark)
    private readonly bookmarkRepository: Repository<Bookmark>,
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
    @InjectRepository(Comment)
    private readonly commentRepository: Repository<Comment>,
  ) {}

  /**
   * ç‚¹èµ/å–æ¶ˆç‚¹èµ
   */
  async toggleLike(
    userId: string,
    targetType: LikeTargetType,
    targetId: string,
  ) {
    // éªŒè¯ç›®æ ‡æ˜¯å¦å­˜åœ¨
    await this.validateTarget(targetType, targetId);

    const existingLike = await this.likeRepository.findOne({
      where: {
        user: { id: userId },
        targetType,
        targetId,
      },
    });

    if (existingLike) {
      // å–æ¶ˆç‚¹èµ
      await this.likeRepository.remove(existingLike);
      await this.updateLikeCount(targetType, targetId, -1);
      
      return {
        action: 'unliked',
        message: 'å–æ¶ˆç‚¹èµæˆåŠŸ',
      };
    } else {
      // ç‚¹èµ
      const like = this.likeRepository.create({
        user: { id: userId },
        targetType,
        targetId,
      });
      
      await this.likeRepository.save(like);
      await this.updateLikeCount(targetType, targetId, 1);
      
      return {
        action: 'liked',
        message: 'ç‚¹èµæˆåŠŸ',
      };
    }
  }

  /**
   * æ”¶è—/å–æ¶ˆæ”¶è—æ–‡ç« 
   */
  async toggleBookmark(userId: string, articleId: string) {
    // éªŒè¯æ–‡ç« æ˜¯å¦å­˜åœ¨
    const article = await this.articleRepository.findOne({
      where: { id: articleId },
    });

    if (!article) {
      throw new NotFoundException('æ–‡ç« ä¸å­˜åœ¨');
    }

    const existingBookmark = await this.bookmarkRepository.findOne({
      where: {
        user: { id: userId },
        article: { id: articleId },
      },
    });

    if (existingBookmark) {
      // å–æ¶ˆæ”¶è—
      await this.bookmarkRepository.remove(existingBookmark);
      
      return {
        action: 'unbookmarked',
        message: 'å–æ¶ˆæ”¶è—æˆåŠŸ',
      };
    } else {
      // æ”¶è—
      const bookmark = this.bookmarkRepository.create({
        user: { id: userId },
        article: { id: articleId },
      });
      
      await this.bookmarkRepository.save(bookmark);
      
      return {
        action: 'bookmarked',
        message: 'æ”¶è—æˆåŠŸ',
      };
    }
  }

  /**
   * è·å–ç”¨æˆ·æ”¶è—åˆ—è¡¨
   */
  async getUserBookmarks(userId: string, page: number = 1, limit: number = 20) {
    const queryBuilder = this.bookmarkRepository
      .createQueryBuilder('bookmark')
      .leftJoinAndSelect('bookmark.article', 'article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .where('bookmark.user.id = :userId', { userId })
      .orderBy('bookmark.createdAt', 'DESC');

    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items: items.map(bookmark => bookmark.article),
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²ç‚¹èµ/æ”¶è—
   */
  async checkUserInteractions(userId: string, targetType: LikeTargetType, targetId: string) {
    const [isLiked, isBookmarked] = await Promise.all([
      this.likeRepository.findOne({
        where: { user: { id: userId }, targetType, targetId },
      }),
      targetType === LikeTargetType.ARTICLE
        ? this.bookmarkRepository.findOne({
            where: { user: { id: userId }, article: { id: targetId } },
          })
        : Promise.resolve(null),
    ]);

    return {
      isLiked: !!isLiked,
      isBookmarked: !!isBookmarked,
    };
  }

  private async validateTarget(targetType: LikeTargetType, targetId: string) {
    if (targetType === LikeTargetType.ARTICLE) {
      const article = await this.articleRepository.findOne({
        where: { id: targetId },
      });
      if (!article) {
        throw new NotFoundException('æ–‡ç« ä¸å­˜åœ¨');
      }
    } else if (targetType === LikeTargetType.COMMENT) {
      const comment = await this.commentRepository.findOne({
        where: { id: targetId },
      });
      if (!comment) {
        throw new NotFoundException('è¯„è®ºä¸å­˜åœ¨');
      }
    }
  }

  private async updateLikeCount(
    targetType: LikeTargetType,
    targetId: string,
    increment: number,
  ) {
    if (targetType === LikeTargetType.ARTICLE) {
      await this.articleRepository.increment({ id: targetId }, 'likeCount', increment);
    } else if (targetType === LikeTargetType.COMMENT) {
      await this.commentRepository.increment({ id: targetId }, 'likeCount', increment);
    }
  }
}
```

---

## 9.7.3 ç”¨æˆ·å…³æ³¨ç³»ç»Ÿ

### ğŸ‘¥ å…³æ³¨å®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/follow/entities/follow.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  ManyToOne,
  Unique,
  Check,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';

@Entity('follows')
@Unique(['follower', 'following'])
@Check('follower_id != following_id')
export class Follow {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @ManyToOne(() => User, user => user.following, { onDelete: 'CASCADE' })
  follower: User;

  @ManyToOne(() => User, user => user.followers, { onDelete: 'CASCADE' })
  following: User;
}
```

### ğŸ› ï¸ å…³æ³¨æœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/follow/follow.service.ts**ï¼š
```typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Follow } from './entities/follow.entity';
import { User } from '../user/entities/user.entity';

@Injectable()
export class FollowService {
  constructor(
    @InjectRepository(Follow)
    private readonly followRepository: Repository<Follow>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  /**
   * å…³æ³¨/å–æ¶ˆå…³æ³¨ç”¨æˆ·
   */
  async toggleFollow(followerId: string, followingId: string) {
    // ä¸èƒ½å…³æ³¨è‡ªå·±
    if (followerId === followingId) {
      throw new BadRequestException('ä¸èƒ½å…³æ³¨è‡ªå·±');
    }

    // éªŒè¯è¢«å…³æ³¨ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const followingUser = await this.userRepository.findOne({
      where: { id: followingId },
    });

    if (!followingUser) {
      throw new NotFoundException('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    const existingFollow = await this.followRepository.findOne({
      where: {
        follower: { id: followerId },
        following: { id: followingId },
      },
    });

    if (existingFollow) {
      // å–æ¶ˆå…³æ³¨
      await this.followRepository.remove(existingFollow);
      
      return {
        action: 'unfollowed',
        message: 'å–æ¶ˆå…³æ³¨æˆåŠŸ',
      };
    } else {
      // å…³æ³¨
      const follow = this.followRepository.create({
        follower: { id: followerId },
        following: { id: followingId },
      });
      
      await this.followRepository.save(follow);
      
      return {
        action: 'followed',
        message: 'å…³æ³¨æˆåŠŸ',
      };
    }
  }

  /**
   * è·å–ç”¨æˆ·å…³æ³¨åˆ—è¡¨
   */
  async getFollowing(userId: string, page: number = 1, limit: number = 20) {
    const queryBuilder = this.followRepository
      .createQueryBuilder('follow')
      .leftJoinAndSelect('follow.following', 'following')
      .leftJoinAndSelect('following.profile', 'profile')
      .where('follow.follower.id = :userId', { userId })
      .orderBy('follow.createdAt', 'DESC');

    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items: items.map(follow => follow.following),
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * è·å–ç”¨æˆ·ç²‰ä¸åˆ—è¡¨
   */
  async getFollowers(userId: string, page: number = 1, limit: number = 20) {
    const queryBuilder = this.followRepository
      .createQueryBuilder('follow')
      .leftJoinAndSelect('follow.follower', 'follower')
      .leftJoinAndSelect('follower.profile', 'profile')
      .where('follow.following.id = :userId', { userId })
      .orderBy('follow.createdAt', 'DESC');

    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items: items.map(follow => follow.follower),
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * æ£€æŸ¥å…³æ³¨å…³ç³»
   */
  async checkFollowStatus(followerId: string, followingId: string) {
    const follow = await this.followRepository.findOne({
      where: {
        follower: { id: followerId },
        following: { id: followingId },
      },
    });

    return {
      isFollowing: !!follow,
    };
  }

  /**
   * è·å–ç”¨æˆ·ç»Ÿè®¡ä¿¡æ¯
   */
  async getUserStats(userId: string) {
    const [followingCount, followersCount] = await Promise.all([
      this.followRepository.count({
        where: { follower: { id: userId } },
      }),
      this.followRepository.count({
        where: { following: { id: userId } },
      }),
    ]);

    return {
      followingCount,
      followersCount,
    };
  }
}
```

---

## 9.7.4 é€šçŸ¥æœºåˆ¶è®¾è®¡

### ğŸ”” é€šçŸ¥å®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/notification/entities/notification.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  Index,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';

export enum NotificationType {
  COMMENT = 'comment',
  LIKE = 'like',
  FOLLOW = 'follow',
  ARTICLE_PUBLISHED = 'article_published',
  SYSTEM = 'system',
}

@Entity('notifications')
export class Notification {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({
    type: 'enum',
    enum: NotificationType,
  })
  @Index()
  type: NotificationType;

  @Column()
  title: string;

  @Column({ type: 'text' })
  content: string;

  @Column({ type: 'json', nullable: true })
  data: any;

  @Column({ default: false })
  @Index()
  isRead: boolean;

  @Column({ name: 'target_url', nullable: true })
  targetUrl: string;

  @CreateDateColumn({ name: 'created_at' })
  @Index()
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  @ManyToOne(() => User, { onDelete: 'CASCADE' })
  @Index()
  recipient: User;

  @ManyToOne(() => User, { nullable: true })
  sender: User;
}
```

### ğŸ› ï¸ é€šçŸ¥æœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/notification/notification.service.ts**ï¼š
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Notification, NotificationType } from './entities/notification.entity';

@Injectable()
export class NotificationService {
  constructor(
    @InjectRepository(Notification)
    private readonly notificationRepository: Repository<Notification>,
  ) {}

  /**
   * åˆ›å»ºé€šçŸ¥
   */
  async create(
    recipientId: string,
    type: NotificationType,
    title: string,
    content: string,
    data?: any,
    senderId?: string,
    targetUrl?: string,
  ) {
    const notification = this.notificationRepository.create({
      recipient: { id: recipientId },
      sender: senderId ? { id: senderId } : null,
      type,
      title,
      content,
      data,
      targetUrl,
    });

    return this.notificationRepository.save(notification);
  }

  /**
   * è·å–ç”¨æˆ·é€šçŸ¥åˆ—è¡¨
   */
  async getUserNotifications(
    userId: string,
    page: number = 1,
    limit: number = 20,
    unreadOnly: boolean = false,
  ) {
    const queryBuilder = this.notificationRepository
      .createQueryBuilder('notification')
      .leftJoinAndSelect('notification.sender', 'sender')
      .where('notification.recipient.id = :userId', { userId });

    if (unreadOnly) {
      queryBuilder.andWhere('notification.isRead = false');
    }

    queryBuilder.orderBy('notification.createdAt', 'DESC');

    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * æ ‡è®°é€šçŸ¥ä¸ºå·²è¯»
   */
  async markAsRead(notificationId: string, userId: string) {
    await this.notificationRepository.update(
      {
        id: notificationId,
        recipient: { id: userId },
      },
      { isRead: true },
    );
  }

  /**
   * æ ‡è®°æ‰€æœ‰é€šçŸ¥ä¸ºå·²è¯»
   */
  async markAllAsRead(userId: string) {
    await this.notificationRepository.update(
      {
        recipient: { id: userId },
        isRead: false,
      },
      { isRead: true },
    );
  }

  /**
   * è·å–æœªè¯»é€šçŸ¥æ•°é‡
   */
  async getUnreadCount(userId: string) {
    return this.notificationRepository.count({
      where: {
        recipient: { id: userId },
        isRead: false,
      },
    });
  }

  /**
   * åˆ›å»ºè¯„è®ºé€šçŸ¥
   */
  async createCommentNotification(
    articleAuthorId: string,
    commentAuthorId: string,
    articleTitle: string,
    articleId: string,
  ) {
    if (articleAuthorId === commentAuthorId) {
      return; // ä¸ç»™è‡ªå·±å‘é€šçŸ¥
    }

    await this.create(
      articleAuthorId,
      NotificationType.COMMENT,
      'æ–°è¯„è®º',
      `æœ‰äººè¯„è®ºäº†æ‚¨çš„æ–‡ç« ã€Š${articleTitle}ã€‹`,
      { articleId },
      commentAuthorId,
      `/articles/${articleId}`,
    );
  }

  /**
   * åˆ›å»ºç‚¹èµé€šçŸ¥
   */
  async createLikeNotification(
    targetOwnerId: string,
    likerId: string,
    targetType: string,
    targetId: string,
    targetTitle: string,
  ) {
    if (targetOwnerId === likerId) {
      return; // ä¸ç»™è‡ªå·±å‘é€šçŸ¥
    }

    await this.create(
      targetOwnerId,
      NotificationType.LIKE,
      'æ–°ç‚¹èµ',
      `æœ‰äººç‚¹èµäº†æ‚¨çš„${targetType === 'article' ? 'æ–‡ç« ' : 'è¯„è®º'}ã€Š${targetTitle}ã€‹`,
      { targetType, targetId },
      likerId,
      targetType === 'article' ? `/articles/${targetId}` : null,
    );
  }

  /**
   * åˆ›å»ºå…³æ³¨é€šçŸ¥
   */
  async createFollowNotification(followingId: string, followerId: string) {
    await this.create(
      followingId,
      NotificationType.FOLLOW,
      'æ–°å…³æ³¨',
      'æœ‰äººå…³æ³¨äº†æ‚¨',
      { followerId },
      followerId,
      `/users/${followerId}`,
    );
  }
}
```

---

## ğŸ“Š æœ¬èŠ‚æ€»ç»“

### ğŸ¯ å…³é”®è¦ç‚¹å›é¡¾

1. **è¯„è®ºç³»ç»Ÿè¦æ”¯æŒå¤šå±‚çº§**
   - æ ‘å½¢ç»“æ„è®¾è®¡
   - å›å¤å’ŒåµŒå¥—è¯„è®º
   - çŠ¶æ€ç®¡ç†å’Œæƒé™æ§åˆ¶

2. **äº’åŠ¨åŠŸèƒ½è¦ç”¨æˆ·å‹å¥½**
   - ç‚¹èµå’Œæ”¶è—æœºåˆ¶
   - é˜²é‡å¤æ“ä½œ
   - å®æ—¶è®¡æ•°æ›´æ–°

3. **å…³æ³¨ç³»ç»Ÿè¦å»ºç«‹ç¤¾äº¤å…³ç³»**
   - ç”¨æˆ·å…³æ³¨å’Œç²‰ä¸
   - å…³æ³¨çŠ¶æ€æ£€æŸ¥
   - ç»Ÿè®¡ä¿¡æ¯å±•ç¤º

4. **é€šçŸ¥æœºåˆ¶è¦åŠæ—¶å‡†ç¡®**
   - å¤šç§é€šçŸ¥ç±»å‹
   - å·²è¯»æœªè¯»çŠ¶æ€
   - é€šçŸ¥æ¨é€å’Œç®¡ç†

### ğŸ“ å®è·µç»ƒä¹ 

#### ç»ƒä¹ 1ï¼šå®Œæ•´è¯„è®ºç³»ç»Ÿ
**ä»»åŠ¡**ï¼šå®ç°å¤šå±‚çº§è¯„è®ºåŠŸèƒ½
**è¦æ±‚**ï¼š
- æ”¯æŒè¯„è®ºå’Œå›å¤
- å®ç°è¯„è®ºçŠ¶æ€ç®¡ç†
- æ·»åŠ è¯„è®ºæƒé™æ§åˆ¶
- å®ç°è¯„è®ºç»Ÿè®¡åŠŸèƒ½

#### ç»ƒä¹ 2ï¼šäº’åŠ¨åŠŸèƒ½å®ç°
**ä»»åŠ¡**ï¼šå®ç°ç‚¹èµå’Œæ”¶è—åŠŸèƒ½
**è¦æ±‚**ï¼š
- å®ç°ç‚¹èµåˆ‡æ¢åŠŸèƒ½
- å®ç°æ–‡ç« æ”¶è—åŠŸèƒ½
- æ·»åŠ é˜²é‡å¤æ“ä½œ
- å®ç°ç”¨æˆ·äº’åŠ¨è®°å½•

### ğŸ” è‡ªæˆ‘æ£€æµ‹

- [ ] æˆ‘èƒ½å¤Ÿå®ç°å¤šå±‚çº§è¯„è®ºç³»ç»Ÿ
- [ ] æˆ‘ç†è§£ç‚¹èµæ”¶è—çš„æ•°æ®è®¾è®¡
- [ ] æˆ‘æŒæ¡äº†ç”¨æˆ·å…³æ³¨ç³»ç»Ÿçš„å®ç°
- [ ] æˆ‘äº†è§£é€šçŸ¥æœºåˆ¶çš„è®¾è®¡åŸç†

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ 

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… è¯„è®ºç³»ç»Ÿå®ç°
- âœ… ç‚¹èµæ”¶è—åŠŸèƒ½
- âœ… ç”¨æˆ·å…³æ³¨ç³»ç»Ÿ
- âœ… é€šçŸ¥æœºåˆ¶è®¾è®¡

**å‡†å¤‡å¥½è¿›å…¥ç¬¬9.8èŠ‚äº†å—ï¼Ÿ** ğŸš€

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å®ç°æœç´¢æ¨èæ¨¡å—ï¼ŒåŒ…æ‹¬ï¼š
- ğŸ” å…¨æ–‡æœç´¢å®ç°
- ğŸ¯ æ™ºèƒ½æ¨èç®—æ³•
- ï¿½ï¿½ çƒ­é—¨å†…å®¹ç»Ÿè®¡
- ğŸ”¥ æœç´¢ç»“æœä¼˜åŒ– 