# ğŸ“š ç¬¬8ç« ï¼šä¸šåŠ¡æ¨¡å—è®¾è®¡ï¼ˆè¡¥å……å†…å®¹ï¼‰

> æœ¬æ–‡æ¡£æ˜¯ç¬¬8ç« çš„è¡¥å……å†…å®¹ï¼ŒåŒ…å«æ•°æ®æµè®¾è®¡ã€æ¨¡å—é€šä¿¡æœºåˆ¶ã€ä¾èµ–ç®¡ç†å’Œå®æˆ˜æ¡ˆä¾‹

## ğŸ“Š æ•°æ®æµè®¾è®¡

### ğŸ”„ æ•°æ®æµå»ºæ¨¡

```typescript
// æ•°æ®æµè®¾è®¡æ¡†æ¶
interface DataFlowDesignFramework {
  // æ•°æ®æµç±»å‹
  dataFlowTypes: {
    synchronousFlow: {
      description: 'åŒæ­¥æ•°æ®æµ';
      characteristics: ['å®æ—¶å¤„ç†', 'å¼ºä¸€è‡´æ€§', 'é˜»å¡è°ƒç”¨'];
      useCases: ['ç”¨æˆ·è®¤è¯', 'è®¢å•åˆ›å»º', 'æ”¯ä»˜å¤„ç†'];
      implementation: ['ç›´æ¥æ–¹æ³•è°ƒç”¨', 'HTTPåŒæ­¥è¯·æ±‚', 'æ•°æ®åº“äº‹åŠ¡'];
    };
    
    asynchronousFlow: {
      description: 'å¼‚æ­¥æ•°æ®æµ';
      characteristics: ['éé˜»å¡', 'æœ€ç»ˆä¸€è‡´æ€§', 'é«˜ååé‡'];
      useCases: ['é‚®ä»¶å‘é€', 'æ•°æ®åŒæ­¥', 'æ—¥å¿—è®°å½•'];
      implementation: ['æ¶ˆæ¯é˜Ÿåˆ—', 'äº‹ä»¶æ€»çº¿', 'å¼‚æ­¥ä»»åŠ¡'];
    };
    
    streamingFlow: {
      description: 'æµå¼æ•°æ®æµ';
      characteristics: ['è¿ç»­å¤„ç†', 'å®æ—¶å“åº”', 'å¤§æ•°æ®é‡'];
      useCases: ['å®æ—¶ç›‘æ§', 'æ•°æ®åˆ†æ', 'æ¨èç³»ç»Ÿ'];
      implementation: ['WebSocket', 'Server-Sent Events', 'æµå¤„ç†æ¡†æ¶'];
    };
  };
  
  // æ•°æ®æµæ¨¡å¼
  dataFlowPatterns: {
    requestResponse: {
      pattern: 'è¯·æ±‚-å“åº”æ¨¡å¼';
      description: 'å®¢æˆ·ç«¯å‘é€è¯·æ±‚ï¼ŒæœåŠ¡ç«¯è¿”å›å“åº”';
      advantages: ['ç®€å•ç›´è§‚', 'å¼ºä¸€è‡´æ€§', 'æ˜“äºè°ƒè¯•'];
      disadvantages: ['é˜»å¡ç­‰å¾…', 'è€¦åˆåº¦é«˜', 'æ€§èƒ½ç“¶é¢ˆ'];
    };
    
    publishSubscribe: {
      pattern: 'å‘å¸ƒ-è®¢é˜…æ¨¡å¼';
      description: 'å‘å¸ƒè€…å‘å¸ƒäº‹ä»¶ï¼Œè®¢é˜…è€…æ¥æ”¶å¤„ç†';
      advantages: ['è§£è€¦åˆ', 'å¯æ‰©å±•', 'å¼‚æ­¥å¤„ç†'];
      disadvantages: ['å¤æ‚æ€§é«˜', 'è°ƒè¯•å›°éš¾', 'æ¶ˆæ¯ä¸¢å¤±é£é™©'];
    };
    
    pipelineFilter: {
      pattern: 'ç®¡é“-è¿‡æ»¤å™¨æ¨¡å¼';
      description: 'æ•°æ®é€šè¿‡ä¸€ç³»åˆ—å¤„ç†æ­¥éª¤æµè½¬';
      advantages: ['æ¨¡å—åŒ–', 'å¯å¤ç”¨', 'æ˜“äºæ‰©å±•'];
      disadvantages: ['æ€§èƒ½å¼€é”€', 'é”™è¯¯ä¼ æ’­', 'è°ƒè¯•å¤æ‚'];
    };
    
    dataLake: {
      pattern: 'æ•°æ®æ¹–æ¨¡å¼';
      description: 'é›†ä¸­å­˜å‚¨å„ç§æ ¼å¼çš„åŸå§‹æ•°æ®';
      advantages: ['çµæ´»æ€§é«˜', 'æˆæœ¬ä½', 'æ”¯æŒå¤šç§åˆ†æ'];
      disadvantages: ['æ•°æ®è´¨é‡', 'æ²»ç†å¤æ‚', 'æŸ¥è¯¢æ€§èƒ½'];
    };
  };
}

// åšå®¢ç³»ç»Ÿæ•°æ®æµè®¾è®¡
class BlogSystemDataFlow {
  // ç”¨æˆ·æ³¨å†Œæ•°æ®æµ
  designUserRegistrationFlow(): DataFlowDefinition {
    return {
      name: 'ç”¨æˆ·æ³¨å†Œæ•°æ®æµ',
      type: 'synchronous',
      participants: ['å®¢æˆ·ç«¯', 'ç”¨æˆ·æœåŠ¡', 'é‚®ä»¶æœåŠ¡', 'æ•°æ®åº“'],
      
      steps: [
        {
          step: 1,
          from: 'å®¢æˆ·ç«¯',
          to: 'ç”¨æˆ·æœåŠ¡',
          data: 'RegisterUserDto',
          operation: 'POST /api/users/register',
          validation: ['é‚®ç®±æ ¼å¼éªŒè¯', 'å¯†ç å¼ºåº¦éªŒè¯', 'ç”¨æˆ·åå”¯ä¸€æ€§éªŒè¯'],
        },
        {
          step: 2,
          from: 'ç”¨æˆ·æœåŠ¡',
          to: 'æ•°æ®åº“',
          data: 'UserEntity',
          operation: 'INSERT INTO users',
          transaction: true,
        },
        {
          step: 3,
          from: 'ç”¨æˆ·æœåŠ¡',
          to: 'é‚®ä»¶æœåŠ¡',
          data: 'WelcomeEmailDto',
          operation: 'sendWelcomeEmail',
          async: true,
        },
        {
          step: 4,
          from: 'ç”¨æˆ·æœåŠ¡',
          to: 'å®¢æˆ·ç«¯',
          data: 'UserResponseDto',
          operation: 'HTTP 201 Created',
          transformation: 'è¿‡æ»¤æ•æ„Ÿä¿¡æ¯',
        },
      ],
      
      errorHandling: [
        {
          error: 'é‚®ç®±å·²å­˜åœ¨',
          handling: 'è¿”å›409å†²çªé”™è¯¯',
          rollback: false,
        },
        {
          error: 'æ•°æ®åº“è¿æ¥å¤±è´¥',
          handling: 'è¿”å›500æœåŠ¡å™¨é”™è¯¯',
          rollback: true,
        },
      ],
    };
  }
  
  // æ–‡ç« å‘å¸ƒæ•°æ®æµ
  designArticlePublishingFlow(): DataFlowDefinition {
    return {
      name: 'æ–‡ç« å‘å¸ƒæ•°æ®æµ',
      type: 'hybrid', // åŒæ­¥+å¼‚æ­¥
      participants: ['å®¢æˆ·ç«¯', 'æ–‡ç« æœåŠ¡', 'æœç´¢æœåŠ¡', 'ç¼“å­˜æœåŠ¡', 'é€šçŸ¥æœåŠ¡'],
      
      synchronousSteps: [
        {
          step: 1,
          from: 'å®¢æˆ·ç«¯',
          to: 'æ–‡ç« æœåŠ¡',
          data: 'PublishArticleDto',
          operation: 'POST /api/articles/:id/publish',
          validation: ['æ–‡ç« çŠ¶æ€éªŒè¯', 'ç”¨æˆ·æƒé™éªŒè¯'],
        },
        {
          step: 2,
          from: 'æ–‡ç« æœåŠ¡',
          to: 'æ•°æ®åº“',
          data: 'ArticleEntity',
          operation: 'UPDATE articles SET status = published',
          transaction: true,
        },
        {
          step: 3,
          from: 'æ–‡ç« æœåŠ¡',
          to: 'å®¢æˆ·ç«¯',
          data: 'ArticleResponseDto',
          operation: 'HTTP 200 OK',
        },
      ],
      
      asynchronousSteps: [
        {
          step: 'A1',
          trigger: 'ArticlePublishedEvent',
          from: 'æ–‡ç« æœåŠ¡',
          to: 'æœç´¢æœåŠ¡',
          data: 'ArticleIndexDto',
          operation: 'updateSearchIndex',
        },
        {
          step: 'A2',
          trigger: 'ArticlePublishedEvent',
          from: 'æ–‡ç« æœåŠ¡',
          to: 'ç¼“å­˜æœåŠ¡',
          data: 'CacheInvalidationDto',
          operation: 'invalidateCache',
        },
        {
          step: 'A3',
          trigger: 'ArticlePublishedEvent',
          from: 'æ–‡ç« æœåŠ¡',
          to: 'é€šçŸ¥æœåŠ¡',
          data: 'NotificationDto',
          operation: 'notifyFollowers',
        },
      ],
    };
  }
}

interface DataFlowDefinition {
  name: string;
  type: 'synchronous' | 'asynchronous' | 'hybrid';
  participants: string[];
  steps?: DataFlowStep[];
  synchronousSteps?: DataFlowStep[];
  asynchronousSteps?: DataFlowStep[];
  errorHandling?: ErrorHandlingStep[];
}

interface DataFlowStep {
  step: number | string;
  from: string;
  to: string;
  data: string;
  operation: string;
  validation?: string[];
  transformation?: string;
  transaction?: boolean;
  async?: boolean;
  trigger?: string;
}

interface ErrorHandlingStep {
  error: string;
  handling: string;
  rollback: boolean;
}
```

### ğŸ“ˆ æ•°æ®ä¸€è‡´æ€§è®¾è®¡

```typescript
// æ•°æ®ä¸€è‡´æ€§ç­–ç•¥
interface DataConsistencyStrategy {
  // å¼ºä¸€è‡´æ€§
  strongConsistency: {
    description: 'æ‰€æœ‰èŠ‚ç‚¹åœ¨åŒä¸€æ—¶åˆ»çœ‹åˆ°ç›¸åŒçš„æ•°æ®';
    implementation: ['ACIDäº‹åŠ¡', 'åˆ†å¸ƒå¼é”', 'ä¸¤é˜¶æ®µæäº¤'];
    useCases: ['é‡‘èäº¤æ˜“', 'åº“å­˜ç®¡ç†', 'ç”¨æˆ·è®¤è¯'];
    tradeoffs: ['æ€§èƒ½è¾ƒä½', 'å¯ç”¨æ€§å—é™', 'æ‰©å±•æ€§å·®'];
  };
  
  // æœ€ç»ˆä¸€è‡´æ€§
  eventualConsistency: {
    description: 'ç³»ç»Ÿåœ¨ä¸€æ®µæ—¶é—´åè¾¾åˆ°ä¸€è‡´çŠ¶æ€';
    implementation: ['äº‹ä»¶æº¯æº', 'CQRS', 'æ¶ˆæ¯é˜Ÿåˆ—'];
    useCases: ['å†…å®¹åˆ†å‘', 'æ•°æ®åŒæ­¥', 'ç¼“å­˜æ›´æ–°'];
    tradeoffs: ['å¤æ‚æ€§é«˜', 'è°ƒè¯•å›°éš¾', 'æ•°æ®å»¶è¿Ÿ'];
  };
  
  // å¼±ä¸€è‡´æ€§
  weakConsistency: {
    description: 'ä¸ä¿è¯ä½•æ—¶è¾¾åˆ°ä¸€è‡´æ€§';
    implementation: ['DNSç¼“å­˜', 'CDN', 'æœ¬åœ°ç¼“å­˜'];
    useCases: ['é™æ€å†…å®¹', 'é…ç½®ä¿¡æ¯', 'ç»Ÿè®¡æ•°æ®'];
    tradeoffs: ['æ•°æ®å¯èƒ½ä¸å‡†ç¡®', 'ç”¨æˆ·ä½“éªŒå½±å“'];
  };
}

// æ•°æ®ä¸€è‡´æ€§å®ç°
@Injectable()
export class DataConsistencyService {
  constructor(
    private readonly dataSource: DataSource,
    private readonly eventBus: EventBus,
    private readonly cacheService: CacheService,
  ) {}
  
  // å¼ºä¸€è‡´æ€§äº‹åŠ¡å¤„ç†
  async executeWithStrongConsistency<T>(
    operation: (manager: EntityManager) => Promise<T>,
  ): Promise<T> {
    return this.dataSource.transaction(async (manager) => {
      try {
        const result = await operation(manager);
        
        // äº‹åŠ¡æˆåŠŸæäº¤åå‘å¸ƒäº‹ä»¶
        await this.dataSource.manager.transaction(async () => {
          // åœ¨ç‹¬ç«‹äº‹åŠ¡ä¸­å‘å¸ƒäº‹ä»¶ï¼Œç¡®ä¿äº‹ä»¶å‘å¸ƒçš„ä¸€è‡´æ€§
          await this.eventBus.publishAll(this.getPendingEvents());
        });
        
        return result;
      } catch (error) {
        // äº‹åŠ¡è‡ªåŠ¨å›æ»š
        this.clearPendingEvents();
        throw error;
      }
    });
  }
  
  // æœ€ç»ˆä¸€è‡´æ€§äº‹ä»¶å¤„ç†
  async executeWithEventualConsistency<T>(
    operation: () => Promise<T>,
    events: DomainEvent[],
  ): Promise<T> {
    try {
      // æ‰§è¡Œä¸»è¦æ“ä½œ
      const result = await operation();
      
      // å¼‚æ­¥å‘å¸ƒäº‹ä»¶
      setImmediate(async () => {
        for (const event of events) {
          try {
            await this.eventBus.publish(event);
          } catch (error) {
            // è®°å½•äº‹ä»¶å‘å¸ƒå¤±è´¥ï¼Œåç»­é‡è¯•
            await this.recordFailedEvent(event, error);
          }
        }
      });
      
      return result;
    } catch (error) {
      // ä¸»æ“ä½œå¤±è´¥ï¼Œä¸å‘å¸ƒäº‹ä»¶
      throw error;
    }
  }
  
  // è¡¥å¿äº‹åŠ¡æ¨¡å¼ï¼ˆSagaï¼‰
  async executeSaga(sagaDefinition: SagaDefinition): Promise<void> {
    const executedSteps: SagaStep[] = [];
    
    try {
      for (const step of sagaDefinition.steps) {
        await this.executeSagaStep(step);
        executedSteps.push(step);
      }
    } catch (error) {
      // æ‰§è¡Œè¡¥å¿æ“ä½œ
      await this.compensate(executedSteps.reverse());
      throw error;
    }
  }
  
  private async executeSagaStep(step: SagaStep): Promise<void> {
    // æ‰§è¡Œæ­¥éª¤æ“ä½œ
    await step.execute();
    
    // è®°å½•æ‰§è¡ŒçŠ¶æ€
    await this.recordSagaStepExecution(step);
  }
  
  private async compensate(steps: SagaStep[]): Promise<void> {
    for (const step of steps) {
      try {
        if (step.compensate) {
          await step.compensate();
        }
      } catch (error) {
        // è®°å½•è¡¥å¿å¤±è´¥ï¼Œéœ€è¦äººå·¥å¹²é¢„
        await this.recordCompensationFailure(step, error);
      }
    }
  }
  
  // ç¼“å­˜ä¸€è‡´æ€§ç®¡ç†
  async updateWithCacheConsistency<T>(
    key: string,
    updateOperation: () => Promise<T>,
    cacheUpdateOperation?: (data: T) => Promise<void>,
  ): Promise<T> {
    // å…ˆåˆ é™¤ç¼“å­˜ï¼ˆCache-Asideæ¨¡å¼ï¼‰
    await this.cacheService.del(key);
    
    try {
      // æ‰§è¡Œæ›´æ–°æ“ä½œ
      const result = await updateOperation();
      
      // æ›´æ–°ç¼“å­˜
      if (cacheUpdateOperation) {
        await cacheUpdateOperation(result);
      } else {
        await this.cacheService.set(key, result);
      }
      
      return result;
    } catch (error) {
      // æ“ä½œå¤±è´¥ï¼Œç¡®ä¿ç¼“å­˜è¢«æ¸…é™¤
      await this.cacheService.del(key);
      throw error;
    }
  }
  
  private pendingEvents: DomainEvent[] = [];
  
  private getPendingEvents(): DomainEvent[] {
    return [...this.pendingEvents];
  }
  
  private clearPendingEvents(): void {
    this.pendingEvents = [];
  }
  
  private async recordFailedEvent(event: DomainEvent, error: Error): Promise<void> {
    // è®°å½•å¤±è´¥çš„äº‹ä»¶ï¼Œç”¨äºåç»­é‡è¯•
    console.error('Event publishing failed:', event, error);
  }
  
  private async recordSagaStepExecution(step: SagaStep): Promise<void> {
    // è®°å½•Sagaæ­¥éª¤æ‰§è¡ŒçŠ¶æ€
    console.log('Saga step executed:', step.name);
  }
  
  private async recordCompensationFailure(step: SagaStep, error: Error): Promise<void> {
    // è®°å½•è¡¥å¿å¤±è´¥ï¼Œéœ€è¦äººå·¥å¹²é¢„
    console.error('Compensation failed:', step.name, error);
  }
}

interface SagaDefinition {
  name: string;
  steps: SagaStep[];
}

interface SagaStep {
  name: string;
  execute: () => Promise<void>;
  compensate?: () => Promise<void>;
}

interface DomainEvent {
  eventType: string;
  aggregateId: string;
  eventData: any;
  occurredAt: Date;
}
```

## ğŸ”— æ¨¡å—é€šä¿¡æœºåˆ¶

### ğŸ’¬ é€šä¿¡æ¨¡å¼è®¾è®¡

```typescript
// æ¨¡å—é€šä¿¡æ¨¡å¼
interface ModuleCommunicationPatterns {
  // ç›´æ¥è°ƒç”¨æ¨¡å¼
  directInvocation: {
    description: 'æ¨¡å—é—´ç›´æ¥æ–¹æ³•è°ƒç”¨';
    advantages: ['ç®€å•ç›´æ¥', 'æ€§èƒ½é«˜', 'å¼ºç±»å‹'];
    disadvantages: ['ç´§è€¦åˆ', 'åŒæ­¥é˜»å¡', 'éš¾ä»¥æ‰©å±•'];
    implementation: ['ä¾èµ–æ³¨å…¥', 'æ¥å£è°ƒç”¨', 'å…±äº«åº“'];
    useCases: ['åŒä¸€è¿›ç¨‹å†…', 'æ ¸å¿ƒä¸šåŠ¡é€»è¾‘', 'å®æ—¶è¦æ±‚é«˜'];
  };
  
  // äº‹ä»¶é©±åŠ¨æ¨¡å¼
  eventDriven: {
    description: 'é€šè¿‡äº‹ä»¶è¿›è¡Œå¼‚æ­¥é€šä¿¡';
    advantages: ['æ¾è€¦åˆ', 'å¼‚æ­¥å¤„ç†', 'å¯æ‰©å±•'];
    disadvantages: ['å¤æ‚æ€§é«˜', 'è°ƒè¯•å›°éš¾', 'æœ€ç»ˆä¸€è‡´æ€§'];
    implementation: ['äº‹ä»¶æ€»çº¿', 'æ¶ˆæ¯é˜Ÿåˆ—', 'å‘å¸ƒè®¢é˜…'];
    useCases: ['è·¨æ¨¡å—é€šçŸ¥', 'æ•°æ®åŒæ­¥', 'å·¥ä½œæµç¨‹'];
  };
  
  // æ¶ˆæ¯ä¼ é€’æ¨¡å¼
  messagePasssing: {
    description: 'é€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œé€šä¿¡';
    advantages: ['è§£è€¦åˆ', 'å¯é æ€§', 'è´Ÿè½½å‡è¡¡'];
    disadvantages: ['å»¶è¿Ÿé«˜', 'å¤æ‚æ€§', 'æ¶ˆæ¯ä¸¢å¤±é£é™©'];
    implementation: ['RabbitMQ', 'Apache Kafka', 'Redis Pub/Sub'];
    useCases: ['å¾®æœåŠ¡é—´é€šä¿¡', 'æ‰¹é‡å¤„ç†', 'ç³»ç»Ÿé›†æˆ'];
  };
  
  // APIç½‘å…³æ¨¡å¼
  apiGateway: {
    description: 'é€šè¿‡APIç½‘å…³ç»Ÿä¸€å¯¹å¤–æ¥å£';
    advantages: ['ç»Ÿä¸€å…¥å£', 'æ¨ªåˆ‡å…³æ³¨ç‚¹', 'ç‰ˆæœ¬ç®¡ç†'];
    disadvantages: ['å•ç‚¹æ•…éšœ', 'æ€§èƒ½ç“¶é¢ˆ', 'å¤æ‚æ€§'];
    implementation: ['Kong', 'Zuul', 'Ambassador'];
    useCases: ['å¾®æœåŠ¡æ¶æ„', 'å¤–éƒ¨é›†æˆ', 'å®‰å…¨æ§åˆ¶'];
  };
}

// äº‹ä»¶é©±åŠ¨é€šä¿¡å®ç°
@Injectable()
export class EventDrivenCommunication {
  constructor(
    private readonly eventBus: EventBus,
    private readonly logger: Logger,
  ) {}
  
  // å‘å¸ƒäº‹ä»¶
  async publishEvent<T extends DomainEvent>(event: T): Promise<void> {
    try {
      await this.eventBus.publish(event);
      this.logger.log(`Event published: ${event.constructor.name}`, {
        eventId: event.eventId,
        aggregateId: event.aggregateId,
      });
    } catch (error) {
      this.logger.error(`Failed to publish event: ${event.constructor.name}`, error);
      throw error;
    }
  }
  
  // æ‰¹é‡å‘å¸ƒäº‹ä»¶
  async publishEvents(events: DomainEvent[]): Promise<void> {
    const publishPromises = events.map(event => this.publishEvent(event));
    await Promise.all(publishPromises);
  }
  
  // äº‹ä»¶å¤„ç†å™¨æ³¨å†Œ
  registerEventHandler<T extends DomainEvent>(
    eventType: new (...args: any[]) => T,
    handler: IEventHandler<T>,
  ): void {
    this.eventBus.subscribe(eventType, handler);
  }
}

// é¢†åŸŸäº‹ä»¶å®šä¹‰
export class UserRegisteredEvent implements DomainEvent {
  public readonly eventId: string;
  public readonly occurredAt: Date;
  
  constructor(
    public readonly aggregateId: string,
    public readonly userId: string,
    public readonly email: string,
    public readonly registrationData: any,
  ) {
    this.eventId = uuidv4();
    this.occurredAt = new Date();
  }
}

export class ArticlePublishedEvent implements DomainEvent {
  public readonly eventId: string;
  public readonly occurredAt: Date;
  
  constructor(
    public readonly aggregateId: string,
    public readonly articleId: string,
    public readonly authorId: string,
    public readonly title: string,
    public readonly publishedAt: Date,
  ) {
    this.eventId = uuidv4();
    this.occurredAt = new Date();
  }
}

// äº‹ä»¶å¤„ç†å™¨å®ç°
@EventsHandler(UserRegisteredEvent)
export class UserRegisteredHandler implements IEventHandler<UserRegisteredEvent> {
  constructor(
    private readonly emailService: EmailService,
    private readonly analyticsService: AnalyticsService,
    private readonly logger: Logger,
  ) {}
  
  async handle(event: UserRegisteredEvent): Promise<void> {
    try {
      // å‘é€æ¬¢è¿é‚®ä»¶
      await this.emailService.sendWelcomeEmail({
        to: event.email,
        userId: event.userId,
        registrationData: event.registrationData,
      });
      
      // è®°å½•ç”¨æˆ·æ³¨å†Œåˆ†ææ•°æ®
      await this.analyticsService.trackUserRegistration({
        userId: event.userId,
        email: event.email,
        registrationTime: event.occurredAt,
        source: event.registrationData.source,
      });
      
      this.logger.log(`User registration processed: ${event.userId}`);
    } catch (error) {
      this.logger.error(`Failed to process user registration: ${event.userId}`, error);
      // å¯ä»¥é€‰æ‹©é‡è¯•æˆ–è€…è®°å½•å¤±è´¥äº‹ä»¶
      throw error;
    }
  }
}

@EventsHandler(ArticlePublishedEvent)
export class ArticlePublishedHandler implements IEventHandler<ArticlePublishedEvent> {
  constructor(
    private readonly searchService: SearchService,
    private readonly cacheService: CacheService,
    private readonly notificationService: NotificationService,
    private readonly logger: Logger,
  ) {}
  
  async handle(event: ArticlePublishedEvent): Promise<void> {
    try {
      // å¹¶è¡Œæ‰§è¡Œå¤šä¸ªå¤„ç†ä»»åŠ¡
      await Promise.all([
        this.updateSearchIndex(event),
        this.invalidateCache(event),
        this.notifyFollowers(event),
      ]);
      
      this.logger.log(`Article published processed: ${event.articleId}`);
    } catch (error) {
      this.logger.error(`Failed to process article published: ${event.articleId}`, error);
      throw error;
    }
  }
  
  private async updateSearchIndex(event: ArticlePublishedEvent): Promise<void> {
    await this.searchService.indexArticle({
      id: event.articleId,
      title: event.title,
      authorId: event.authorId,
      publishedAt: event.publishedAt,
    });
  }
  
  private async invalidateCache(event: ArticlePublishedEvent): Promise<void> {
    const cacheKeys = [
      `articles:latest`,
      `articles:author:${event.authorId}`,
      `articles:popular`,
    ];
    
    await Promise.all(
      cacheKeys.map(key => this.cacheService.del(key))
    );
  }
  
  private async notifyFollowers(event: ArticlePublishedEvent): Promise<void> {
    await this.notificationService.notifyFollowers({
      authorId: event.authorId,
      articleId: event.articleId,
      title: event.title,
      publishedAt: event.publishedAt,
    });
  }
}
```

### ğŸ”„ æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ

```typescript
// æ¶ˆæ¯é˜Ÿåˆ—é…ç½®
@Module({
  imports: [
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        redis: {
          host: configService.get('REDIS_HOST'),
          port: configService.get('REDIS_PORT'),
          password: configService.get('REDIS_PASSWORD'),
        },
        defaultJobOptions: {
          removeOnComplete: 10,
          removeOnFail: 5,
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 2000,
          },
        },
      }),
      inject: [ConfigService],
    }),
    BullModule.registerQueue(
      { name: 'email' },
      { name: 'notification' },
      { name: 'analytics' },
      { name: 'search-index' },
    ),
  ],
  providers: [
    EmailProcessor,
    NotificationProcessor,
    AnalyticsProcessor,
    SearchIndexProcessor,
  ],
  exports: [BullModule],
})
export class QueueModule {}

// é‚®ä»¶é˜Ÿåˆ—å¤„ç†å™¨
@Processor('email')
export class EmailProcessor {
  constructor(
    private readonly emailService: EmailService,
    private readonly logger: Logger,
  ) {}
  
  @Process('welcome-email')
  async handleWelcomeEmail(job: Job<WelcomeEmailData>): Promise<void> {
    const { userId, email, registrationData } = job.data;
    
    try {
      await this.emailService.sendWelcomeEmail({
        to: email,
        userId,
        registrationData,
      });
      
      this.logger.log(`Welcome email sent to ${email}`);
    } catch (error) {
      this.logger.error(`Failed to send welcome email to ${email}`, error);
      throw error; // è§¦å‘é‡è¯•æœºåˆ¶
    }
  }
  
  @Process('article-notification')
  async handleArticleNotification(job: Job<ArticleNotificationData>): Promise<void> {
    const { authorId, articleId, title, followers } = job.data;
    
    try {
      for (const follower of followers) {
        await this.emailService.sendArticleNotification({
          to: follower.email,
          authorName: follower.authorName,
          articleTitle: title,
          articleUrl: `${process.env.FRONTEND_URL}/articles/${articleId}`,
        });
      }
      
      this.logger.log(`Article notification sent for article ${articleId}`);
    } catch (error) {
      this.logger.error(`Failed to send article notification for ${articleId}`, error);
      throw error;
    }
  }
  
  @OnQueueActive()
  onActive(job: Job): void {
    this.logger.log(`Processing email job ${job.id} of type ${job.name}`);
  }
  
  @OnQueueCompleted()
  onCompleted(job: Job): void {
    this.logger.log(`Email job ${job.id} completed`);
  }
  
  @OnQueueFailed()
  onFailed(job: Job, error: Error): void {
    this.logger.error(`Email job ${job.id} failed`, error);
  }
}

// æœç´¢ç´¢å¼•é˜Ÿåˆ—å¤„ç†å™¨
@Processor('search-index')
export class SearchIndexProcessor {
  constructor(
    private readonly searchService: SearchService,
    private readonly logger: Logger,
  ) {}
  
  @Process('index-article')
  async handleIndexArticle(job: Job<IndexArticleData>): Promise<void> {
    const { articleId, title, content, authorId, tags } = job.data;
    
    try {
      await this.searchService.indexDocument({
        id: articleId,
        type: 'article',
        body: {
          title,
          content,
          authorId,
          tags,
          indexedAt: new Date(),
        },
      });
      
      this.logger.log(`Article ${articleId} indexed successfully`);
    } catch (error) {
      this.logger.error(`Failed to index article ${articleId}`, error);
      throw error;
    }
  }
  
  @Process('remove-article')
  async handleRemoveArticle(job: Job<RemoveArticleData>): Promise<void> {
    const { articleId } = job.data;
    
    try {
      await this.searchService.removeDocument({
        id: articleId,
        type: 'article',
      });
      
      this.logger.log(`Article ${articleId} removed from index`);
    } catch (error) {
      this.logger.error(`Failed to remove article ${articleId} from index`, error);
      throw error;
    }
  }
}

// é˜Ÿåˆ—æœåŠ¡
@Injectable()
export class QueueService {
  constructor(
    @InjectQueue('email') private emailQueue: Queue,
    @InjectQueue('notification') private notificationQueue: Queue,
    @InjectQueue('analytics') private analyticsQueue: Queue,
    @InjectQueue('search-index') private searchIndexQueue: Queue,
  ) {}
  
  // æ·»åŠ é‚®ä»¶ä»»åŠ¡
  async addEmailJob(jobName: string, data: any, options?: JobOptions): Promise<Job> {
    return this.emailQueue.add(jobName, data, {
      priority: this.getEmailPriority(jobName),
      delay: this.getEmailDelay(jobName),
      ...options,
    });
  }
  
  // æ·»åŠ æœç´¢ç´¢å¼•ä»»åŠ¡
  async addSearchIndexJob(jobName: string, data: any, options?: JobOptions): Promise<Job> {
    return this.searchIndexQueue.add(jobName, data, {
      priority: this.getSearchIndexPriority(jobName),
      ...options,
    });
  }
  
  // æ‰¹é‡æ·»åŠ ä»»åŠ¡
  async addBulkJobs(queueName: string, jobs: Array<{ name: string; data: any; opts?: JobOptions }>): Promise<Job[]> {
    const queue = this.getQueue(queueName);
    return queue.addBulk(jobs);
  }
  
  // è·å–é˜Ÿåˆ—çŠ¶æ€
  async getQueueStatus(queueName: string): Promise<QueueStatus> {
    const queue = this.getQueue(queueName);
    
    const [waiting, active, completed, failed, delayed] = await Promise.all([
      queue.getWaiting(),
      queue.getActive(),
      queue.getCompleted(),
      queue.getFailed(),
      queue.getDelayed(),
    ]);
    
    return {
      waiting: waiting.length,
      active: active.length,
      completed: completed.length,
      failed: failed.length,
      delayed: delayed.length,
    };
  }
  
  private getQueue(queueName: string): Queue {
    switch (queueName) {
      case 'email':
        return this.emailQueue;
      case 'notification':
        return this.notificationQueue;
      case 'analytics':
        return this.analyticsQueue;
      case 'search-index':
        return this.searchIndexQueue;
      default:
        throw new Error(`Unknown queue: ${queueName}`);
    }
  }
  
  private getEmailPriority(jobName: string): number {
    const priorities = {
      'welcome-email': 1,
      'password-reset': 1,
      'article-notification': 5,
      'newsletter': 10,
    };
    return priorities[jobName] || 5;
  }
  
  private getEmailDelay(jobName: string): number {
    const delays = {
      'welcome-email': 0,
      'password-reset': 0,
      'article-notification': 60000, // 1åˆ†é’Ÿå»¶è¿Ÿ
      'newsletter': 300000, // 5åˆ†é’Ÿå»¶è¿Ÿ
    };
    return delays[jobName] || 0;
  }
  
  private getSearchIndexPriority(jobName: string): number {
    const priorities = {
      'index-article': 1,
      'remove-article': 1,
      'bulk-index': 5,
    };
    return priorities[jobName] || 3;
  }
}

// æ•°æ®ç±»å‹å®šä¹‰
interface WelcomeEmailData {
  userId: string;
  email: string;
  registrationData: any;
}

interface ArticleNotificationData {
  authorId: string;
  articleId: string;
  title: string;
  followers: Array<{
    email: string;
    authorName: string;
  }>;
}

interface IndexArticleData {
  articleId: string;
  title: string;
  content: string;
  authorId: string;
  tags: string[];
}

interface RemoveArticleData {
  articleId: string;
}

interface QueueStatus {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
}
```

## ğŸ¯ å®æˆ˜æ¡ˆä¾‹ï¼šåšå®¢ç³»ç»Ÿæ¨¡å—è®¾è®¡

### ğŸ“‹ å®Œæ•´æ¨¡å—æ¶æ„

```typescript
// åšå®¢ç³»ç»Ÿæ¨¡å—æ¶æ„
interface BlogSystemArchitecture {
  // æ ¸å¿ƒä¸šåŠ¡æ¨¡å—
  coreModules: {
    userModule: {
      responsibilities: ['ç”¨æˆ·ç®¡ç†', 'è®¤è¯æˆæƒ', 'ç”¨æˆ·èµ„æ–™'];
      entities: ['User', 'UserProfile', 'UserRole'];
      services: ['UserService', 'AuthService', 'ProfileService'];
      controllers: ['UserController', 'AuthController'];
      repositories: ['UserRepository', 'UserProfileRepository'];
    };
    
    articleModule: {
      responsibilities: ['æ–‡ç« ç®¡ç†', 'å†…å®¹ç¼–è¾‘', 'å‘å¸ƒæµç¨‹'];
      entities: ['Article', 'Draft', 'Category', 'Tag'];
      services: ['ArticleService', 'DraftService', 'CategoryService'];
      controllers: ['ArticleController', 'CategoryController'];
      repositories: ['ArticleRepository', 'CategoryRepository'];
    };
    
    commentModule: {
      responsibilities: ['è¯„è®ºç®¡ç†', 'å›å¤åŠŸèƒ½', 'è¯„è®ºå®¡æ ¸'];
      entities: ['Comment', 'CommentReply'];
      services: ['CommentService', 'CommentModerationService'];
      controllers: ['CommentController'];
      repositories: ['CommentRepository'];
    };
  };
  
  // æ”¯æ’‘æœåŠ¡æ¨¡å—
  supportModules: {
    fileModule: {
      responsibilities: ['æ–‡ä»¶ä¸Šä¼ ', 'å›¾ç‰‡å¤„ç†', 'æ–‡ä»¶ç®¡ç†'];
      services: ['FileService', 'ImageProcessingService'];
      controllers: ['FileController'];
    };
    
    searchModule: {
      responsibilities: ['å…¨æ–‡æœç´¢', 'æœç´¢å»ºè®®', 'æœç´¢ç»Ÿè®¡'];
      services: ['SearchService', 'IndexService'];
      controllers: ['SearchController'];
    };
    
    notificationModule: {
      responsibilities: ['æ¶ˆæ¯é€šçŸ¥', 'é‚®ä»¶å‘é€', 'æ¨é€æœåŠ¡'];
      services: ['NotificationService', 'EmailService', 'PushService'];
      controllers: ['NotificationController'];
    };
  };
  
  // åŸºç¡€è®¾æ–½æ¨¡å—
  infrastructureModules: {
    cacheModule: {
      responsibilities: ['ç¼“å­˜ç®¡ç†', 'ç¼“å­˜ç­–ç•¥', 'ç¼“å­˜ç›‘æ§'];
      services: ['CacheService', 'CacheMonitoringService'];
    };
    
    loggerModule: {
      responsibilities: ['æ—¥å¿—è®°å½•', 'æ—¥å¿—åˆ†æ', 'æ—¥å¿—å­˜å‚¨'];
      services: ['LoggerService', 'LogAnalyticsService'];
    };
    
    configModule: {
      responsibilities: ['é…ç½®ç®¡ç†', 'ç¯å¢ƒå˜é‡', 'é…ç½®éªŒè¯'];
      services: ['ConfigService', 'ConfigValidationService'];
    };
  };
}

// ç”¨æˆ·æ¨¡å—å®Œæ•´å®ç°
@Module({
  imports: [
    TypeOrmModule.forFeature([
      UserEntity,
      UserProfileEntity,
      UserRoleEntity,
      UserSessionEntity,
    ]),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: configService.get<string>('JWT_EXPIRES_IN') },
      }),
      inject: [ConfigService],
    }),
    PassportModule,
    CacheModule,
  ],
  controllers: [UserController, AuthController, ProfileController],
  providers: [
    // æ ¸å¿ƒæœåŠ¡
    UserService,
    AuthService,
    ProfileService,
    
    // ä»“å‚¨
    UserRepository,
    UserProfileRepository,
    UserRoleRepository,
    
    // è®¤è¯ç­–ç•¥
    JwtStrategy,
    LocalStrategy,
    
    // å®ˆå«
    JwtAuthGuard,
    RolesGuard,
    
    // äº‹ä»¶å¤„ç†å™¨
    UserEventHandler,
    
    // éªŒè¯å™¨
    UserValidator,
    
    // å·¥å‚
    UserFactory,
  ],
  exports: [
    UserService,
    AuthService,
    ProfileService,
    UserRepository,
  ],
})
export class UserModule implements OnModuleInit {
  constructor(
    private readonly userService: UserService,
    private readonly configService: ConfigService,
  ) {}
  
  async onModuleInit(): Promise<void> {
    // æ¨¡å—åˆå§‹åŒ–é€»è¾‘
    await this.initializeDefaultRoles();
    await this.initializeAdminUser();
  }
  
  private async initializeDefaultRoles(): Promise<void> {
    const defaultRoles = ['admin', 'editor', 'author', 'reader'];
    
    for (const roleName of defaultRoles) {
      const existingRole = await this.userService.findRoleByName(roleName);
      if (!existingRole) {
        await this.userService.createRole({
          name: roleName,
          description: `Default ${roleName} role`,
          permissions: this.getDefaultPermissions(roleName),
        });
      }
    }
  }
  
  private async initializeAdminUser(): Promise<void> {
    const adminEmail = this.configService.get<string>('ADMIN_EMAIL');
    const adminPassword = this.configService.get<string>('ADMIN_PASSWORD');
    
    if (adminEmail && adminPassword) {
      const existingAdmin = await this.userService.findByEmail(adminEmail);
      if (!existingAdmin) {
        await this.userService.createAdminUser({
          email: adminEmail,
          password: adminPassword,
          username: 'admin',
        });
      }
    }
  }
  
  private getDefaultPermissions(roleName: string): string[] {
    const permissionMap = {
      admin: ['*'], // æ‰€æœ‰æƒé™
      editor: ['article:read', 'article:write', 'article:edit', 'comment:moderate'],
      author: ['article:read', 'article:write', 'comment:read'],
      reader: ['article:read', 'comment:read', 'comment:write'],
    };
    
    return permissionMap[roleName] || [];
  }
}

// æ–‡ç« æ¨¡å—å®Œæ•´å®ç°
@Module({
  imports: [
    TypeOrmModule.forFeature([
      ArticleEntity,
      DraftEntity,
      CategoryEntity,
      TagEntity,
      ArticleTagEntity,
    ]),
    UserModule, // ä¾èµ–ç”¨æˆ·æ¨¡å—
    SearchModule, // ä¾èµ–æœç´¢æ¨¡å—
    CacheModule,
    QueueModule,
  ],
  controllers: [
    ArticleController,
    DraftController,
    CategoryController,
    TagController,
  ],
  providers: [
    // æ ¸å¿ƒæœåŠ¡
    ArticleService,
    DraftService,
    CategoryService,
    TagService,
    ArticleSearchService,
    
    // ä»“å‚¨
    ArticleRepository,
    DraftRepository,
    CategoryRepository,
    TagRepository,
    
    // äº‹ä»¶å¤„ç†å™¨
    ArticleEventHandler,
    
    // éªŒè¯å™¨
    ArticleValidator,
    
    // å·¥å‚
    ArticleFactory,
    
    // ç­–ç•¥
    ArticlePublishingStrategy,
    ArticleSEOStrategy,
  ],
  exports: [
    ArticleService,
    DraftService,
    CategoryService,
    TagService,
    ArticleRepository,
  ],
})
export class ArticleModule {}

// æ¨¡å—é—´ä¾èµ–ç®¡ç†
@Injectable()
export class ModuleDependencyManager {
  private readonly dependencyGraph = new Map<string, string[]>();
  
  constructor() {
    this.buildDependencyGraph();
  }
  
  private buildDependencyGraph(): void {
    // å®šä¹‰æ¨¡å—ä¾èµ–å…³ç³»
    this.dependencyGraph.set('UserModule', []);
    this.dependencyGraph.set('ArticleModule', ['UserModule', 'SearchModule']);
    this.dependencyGraph.set('CommentModule', ['UserModule', 'ArticleModule']);
    this.dependencyGraph.set('NotificationModule', ['UserModule']);
    this.dependencyGraph.set('SearchModule', []);
    this.dependencyGraph.set('FileModule', ['UserModule']);
  }
  
  // æ£€æŸ¥å¾ªç¯ä¾èµ–
  checkCircularDependencies(): boolean {
    const visited = new Set<string>();
    const recursionStack = new Set<string>();
    
    for (const module of this.dependencyGraph.keys()) {
      if (this.hasCircularDependency(module, visited, recursionStack)) {
        return true;
      }
    }
    
    return false;
  }
  
  private hasCircularDependency(
    module: string,
    visited: Set<string>,
    recursionStack: Set<string>,
  ): boolean {
    if (recursionStack.has(module)) {
      return true; // å‘ç°å¾ªç¯ä¾èµ–
    }
    
    if (visited.has(module)) {
      return false; // å·²ç»è®¿é—®è¿‡ï¼Œæ— å¾ªç¯ä¾èµ–
    }
    
    visited.add(module);
    recursionStack.add(module);
    
    const dependencies = this.dependencyGraph.get(module) || [];
    for (const dependency of dependencies) {
      if (this.hasCircularDependency(dependency, visited, recursionStack)) {
        return true;
      }
    }
    
    recursionStack.delete(module);
    return false;
  }
  
  // è·å–æ¨¡å—åŠ è½½é¡ºåº
  getLoadOrder(): string[] {
    const visited = new Set<string>();
    const loadOrder: string[] = [];
    
    for (const module of this.dependencyGraph.keys()) {
      this.topologicalSort(module, visited, loadOrder);
    }
    
    return loadOrder.reverse();
  }
  
  private topologicalSort(
    module: string,
    visited: Set<string>,
    loadOrder: string[],
  ): void {
    if (visited.has(module)) {
      return;
    }
    
    visited.add(module);
    
    const dependencies = this.dependencyGraph.get(module) || [];
    for (const dependency of dependencies) {
      this.topologicalSort(dependency, visited, loadOrder);
    }
    
    loadOrder.push(module);
  }
}
```

## ğŸ“Š å­¦ä¹ æ€»ç»“

é€šè¿‡ç¬¬8ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æŒæ¡äº†ï¼š

1. **ä¸šåŠ¡éœ€æ±‚åˆ†æ**ï¼šå­¦ä¼šäº†å¦‚ä½•åˆ†æå’Œç†è§£å¤æ‚çš„ä¸šåŠ¡éœ€æ±‚
2. **æ¨¡å—åˆ’åˆ†ç­–ç•¥**ï¼šæŒæ¡äº†åŸºäºé¢†åŸŸã€åŠŸèƒ½ã€æŠ€æœ¯å±‚æ¬¡çš„æ¨¡å—åˆ’åˆ†æ–¹æ³•
3. **ä¸šåŠ¡æµç¨‹è®¾è®¡**ï¼šå­¦ä¼šäº†è®¾è®¡æ¸…æ™°é«˜æ•ˆçš„ä¸šåŠ¡å¤„ç†æµç¨‹
4. **æ•°æ®æµè®¾è®¡**ï¼šå»ºç«‹äº†é«˜æ•ˆçš„æ•°æ®æµè½¬æœºåˆ¶å’Œä¸€è‡´æ€§ç­–ç•¥
5. **æ¨¡å—é€šä¿¡æœºåˆ¶**ï¼šæŒæ¡äº†äº‹ä»¶é©±åŠ¨ã€æ¶ˆæ¯é˜Ÿåˆ—ç­‰é€šä¿¡æ¨¡å¼
6. **ä¾èµ–å…³ç³»ç®¡ç†**ï¼šå­¦ä¼šäº†ç®¡ç†æ¨¡å—é—´çš„ä¾èµ–å…³ç³»ï¼Œé¿å…å¾ªç¯ä¾èµ–
7. **å®æˆ˜æ¡ˆä¾‹åº”ç”¨**ï¼šé€šè¿‡åšå®¢ç³»ç»Ÿæ¡ˆä¾‹ï¼Œå®è·µäº†å®Œæ•´çš„æ¨¡å—è®¾è®¡

è¿™äº›çŸ¥è¯†ä¸ºæˆ‘ä»¬æ„å»ºå¤æ‚çš„ä¼ä¸šçº§åº”ç”¨æä¾›äº†åšå®çš„åŸºç¡€ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†è¿›å…¥ä¼ä¸šå®æˆ˜ç¯‡ï¼Œå¼€å§‹æ„å»ºå®Œæ•´çš„ä¼ä¸šçº§åšå®¢ç³»ç»Ÿã€‚ 