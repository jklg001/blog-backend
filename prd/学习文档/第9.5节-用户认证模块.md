# ç¬¬9.5èŠ‚ ç”¨æˆ·è®¤è¯æ¨¡å—

> **å®‰å…¨ç¬¬ä¸€** - ä¼ä¸šçº§ç”¨æˆ·è®¤è¯ç³»ç»Ÿçš„è®¾è®¡ä¸å®ç°

## ğŸ“š æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

### ğŸ¯ çŸ¥è¯†ç›®æ ‡
- [ ] **æŒæ¡JWTè®¤è¯åŸç†**ï¼šæ·±å…¥ç†è§£JWTä»¤ç‰Œçš„å·¥ä½œæœºåˆ¶å’Œå®‰å…¨ç‰¹æ€§
- [ ] **ç†è§£ç”¨æˆ·è®¤è¯æµç¨‹**ï¼šæŒæ¡æ³¨å†Œã€ç™»å½•ã€æƒé™éªŒè¯çš„å®Œæ•´æµç¨‹
- [ ] **å­¦ä¼šè§’è‰²æƒé™è®¾è®¡**ï¼šå»ºç«‹åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰ç³»ç»Ÿ
- [ ] **æŒæ¡å¯†ç å®‰å…¨ç­–ç•¥**ï¼šå®æ–½ä¼ä¸šçº§å¯†ç åŠ å¯†å’Œå®‰å…¨æªæ–½

### ğŸ› ï¸ æŠ€èƒ½ç›®æ ‡
- [ ] èƒ½å¤Ÿå®ç°å®Œæ•´çš„JWTè®¤è¯ç³»ç»Ÿ
- [ ] èƒ½å¤Ÿè®¾è®¡ç”¨æˆ·æ³¨å†Œå’Œç™»å½•åŠŸèƒ½
- [ ] èƒ½å¤Ÿå»ºç«‹è§’è‰²æƒé™ç®¡ç†ç³»ç»Ÿ
- [ ] èƒ½å¤Ÿå®æ–½å¯†ç å®‰å…¨å’Œä¼šè¯ç®¡ç†

### â° å­¦ä¹ æ—¶é•¿
- **ç†è®ºå­¦ä¹ **ï¼š2-3å°æ—¶
- **å®è·µå¼€å‘**ï¼š4-5å°æ—¶
- **æ€»è®¡æ—¶é•¿**ï¼š6-8å°æ—¶

### ğŸ“‹ å‰ç½®çŸ¥è¯†æ£€æŸ¥
- [ ] æŒæ¡ç¬¬9.4èŠ‚çš„å¼€å‘ç¯å¢ƒæ­å»º
- [ ] ç†è§£HTTPè®¤è¯æœºåˆ¶
- [ ] äº†è§£åŠ å¯†ç®—æ³•åŸºç¡€
- [ ] ç†Ÿæ‚‰NestJSå®ˆå«å’Œè£…é¥°å™¨

---

## 9.5.1 JWTè®¤è¯æœºåˆ¶å®ç°

### ğŸ” JWTè®¤è¯åŸç†

#### ğŸ’¡ ä»€ä¹ˆæ˜¯JWTï¼Ÿ

**JWTå°±åƒèº«ä»½è¯**ï¼š
- ğŸ†” **èº«ä»½è¯**åŒ…å«ä¸ªäººä¿¡æ¯ â†’ **JWT**åŒ…å«ç”¨æˆ·ä¿¡æ¯
- ğŸ”’ **é˜²ä¼ªæ ‡è¯†**é˜²æ­¢ä¼ªé€  â†’ **æ•°å­—ç­¾å**é˜²æ­¢ç¯¡æ”¹
- â° **æœ‰æ•ˆæœŸé™åˆ¶** â†’ **è¿‡æœŸæ—¶é—´æ§åˆ¶**
- ğŸ›ï¸ **æ”¿åºœæœºæ„é¢å‘** â†’ **æœåŠ¡å™¨ç­¾å‘**

#### ğŸ—ï¸ JWTç»“æ„åˆ†æ

**JWTç”±ä¸‰éƒ¨åˆ†ç»„æˆ**ï¼š
```
Header.Payload.Signature
```

**1. Headerï¼ˆå¤´éƒ¨ï¼‰**ï¼š
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**2. Payloadï¼ˆè½½è·ï¼‰**ï¼š
```json
{
  "sub": "user-uuid",
  "username": "john_doe",
  "email": "john@example.com",
  "roles": ["user"],
  "iat": 1640995200,
  "exp": 1641081600
}
```

**3. Signatureï¼ˆç­¾åï¼‰**ï¼š
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

### ğŸ› ï¸ JWTæ¨¡å—é…ç½®

#### ğŸ“¦ å®‰è£…ä¾èµ–

```bash
# JWTç›¸å…³ä¾èµ–
npm install @nestjs/jwt @nestjs/passport passport passport-jwt passport-local

# ç±»å‹å®šä¹‰
npm install -D @types/passport-jwt @types/passport-local

# å¯†ç åŠ å¯†
npm install bcrypt
npm install -D @types/bcrypt
```

#### âš™ï¸ JWTé…ç½®æ¨¡å—

**åˆ›å»ºsrc/modules/auth/auth.module.ts**ï¼š
```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';

import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { User } from '../user/entities/user.entity';
import { UserService } from '../user/user.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';

@Module({
  imports: [
    TypeOrmModule.forFeature([User]),
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        secret: configService.get<string>('jwt.secret'),
        signOptions: {
          expiresIn: configService.get<string>('jwt.expiresIn'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, UserService, JwtStrategy, LocalStrategy],
  exports: [AuthService, JwtModule],
})
export class AuthModule {}
```

#### ğŸ”‘ JWTç­–ç•¥å®ç°

**åˆ›å»ºsrc/modules/auth/strategies/jwt.strategy.ts**ï¼š
```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UserService } from '../../user/user.service';

export interface JwtPayload {
  sub: string;
  username: string;
  email: string;
  roles: string[];
  iat?: number;
  exp?: number;
}

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    private readonly userService: UserService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('jwt.secret'),
    });
  }

  async validate(payload: JwtPayload) {
    const user = await this.userService.findById(payload.sub);
    
    if (!user) {
      throw new UnauthorizedException('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    if (user.status !== 'active') {
      throw new UnauthorizedException('ç”¨æˆ·è´¦æˆ·å·²è¢«ç¦ç”¨');
    }

    // è¿”å›çš„ç”¨æˆ·ä¿¡æ¯ä¼šè¢«æ·»åŠ åˆ°request.userä¸­
    return {
      id: user.id,
      username: user.username,
      email: user.email,
      roles: payload.roles,
    };
  }
}
```

**åˆ›å»ºsrc/modules/auth/strategies/local.strategy.ts**ï¼š
```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-local';
import { AuthService } from '../auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly authService: AuthService) {
    super({
      usernameField: 'email', // ä½¿ç”¨é‚®ç®±ä½œä¸ºç”¨æˆ·å
      passwordField: 'password',
    });
  }

  async validate(email: string, password: string) {
    const user = await this.authService.validateUser(email, password);
    
    if (!user) {
      throw new UnauthorizedException('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
    }
    
    return user;
  }
}
```

---

## 9.5.2 ç”¨æˆ·æ³¨å†Œå’Œç™»å½•åŠŸèƒ½

### ğŸ‘¥ ç”¨æˆ·å®ä½“è®¾è®¡

#### ğŸ“Š ç”¨æˆ·å®ä½“å®šä¹‰

**åˆ›å»ºsrc/modules/user/entities/user.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToOne,
  OneToMany,
  ManyToMany,
  JoinTable,
} from 'typeorm';
import { Exclude } from 'class-transformer';
import { UserProfile } from './user-profile.entity';
import { Article } from '../../article/entities/article.entity';
import { Role } from './role.entity';

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  BANNED = 'banned',
}

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true, length: 50 })
  username: string;

  @Column({ unique: true, length: 255 })
  email: string;

  @Column({ name: 'password_hash' })
  @Exclude() // åºåˆ—åŒ–æ—¶æ’é™¤å¯†ç å­—æ®µ
  passwordHash: string;

  @Column({
    type: 'enum',
    enum: UserStatus,
    default: UserStatus.ACTIVE,
  })
  status: UserStatus;

  @Column({ name: 'email_verified', default: false })
  emailVerified: boolean;

  @Column({ name: 'last_login_at', nullable: true })
  lastLoginAt: Date;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // å…³è”å…³ç³»
  @OneToOne(() => UserProfile, profile => profile.user, { cascade: true })
  profile: UserProfile;

  @OneToMany(() => Article, article => article.author)
  articles: Article[];

  @ManyToMany(() => Role, role => role.users)
  @JoinTable({
    name: 'user_roles',
    joinColumn: { name: 'user_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'role_id', referencedColumnName: 'id' },
  })
  roles: Role[];
}
```

**åˆ›å»ºsrc/modules/user/entities/role.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
} from 'typeorm';
import { User } from './user.entity';

@Entity('roles')
export class Role {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true, length: 50 })
  name: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({ type: 'json' })
  permissions: string[];

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  @ManyToMany(() => User, user => user.roles)
  users: User[];
}
```

### ğŸ“ DTOè®¾è®¡

#### ğŸ”§ è®¤è¯ç›¸å…³DTO

**åˆ›å»ºsrc/modules/auth/dto/register.dto.ts**ï¼š
```typescript
import {
  IsEmail,
  IsString,
  MinLength,
  MaxLength,
  Matches,
  IsOptional,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class RegisterDto {
  @ApiProperty({ description: 'ç”¨æˆ·å', example: 'john_doe' })
  @IsString({ message: 'ç”¨æˆ·åå¿…é¡»æ˜¯å­—ç¬¦ä¸²' })
  @MinLength(3, { message: 'ç”¨æˆ·åè‡³å°‘3ä¸ªå­—ç¬¦' })
  @MaxLength(50, { message: 'ç”¨æˆ·åæœ€å¤š50ä¸ªå­—ç¬¦' })
  @Matches(/^[a-zA-Z0-9_]+$/, { message: 'ç”¨æˆ·ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿' })
  username: string;

  @ApiProperty({ description: 'é‚®ç®±åœ°å€', example: 'john@example.com' })
  @IsEmail({}, { message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€' })
  email: string;

  @ApiProperty({ description: 'å¯†ç ', example: 'Password123!' })
  @IsString({ message: 'å¯†ç å¿…é¡»æ˜¯å­—ç¬¦ä¸²' })
  @MinLength(8, { message: 'å¯†ç è‡³å°‘8ä¸ªå­—ç¬¦' })
  @MaxLength(128, { message: 'å¯†ç æœ€å¤š128ä¸ªå­—ç¬¦' })
  @Matches(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    { message: 'å¯†ç å¿…é¡»åŒ…å«å¤§å°å†™å­—æ¯ã€æ•°å­—å’Œç‰¹æ®Šå­—ç¬¦' }
  )
  password: string;

  @ApiProperty({ description: 'ç¡®è®¤å¯†ç ', example: 'Password123!' })
  @IsString({ message: 'ç¡®è®¤å¯†ç å¿…é¡»æ˜¯å­—ç¬¦ä¸²' })
  confirmPassword: string;

  @ApiProperty({ description: 'æ˜¾ç¤ºåç§°', example: 'John Doe', required: false })
  @IsOptional()
  @IsString({ message: 'æ˜¾ç¤ºåç§°å¿…é¡»æ˜¯å­—ç¬¦ä¸²' })
  @MaxLength(100, { message: 'æ˜¾ç¤ºåç§°æœ€å¤š100ä¸ªå­—ç¬¦' })
  displayName?: string;
}
```

**åˆ›å»ºsrc/modules/auth/dto/login.dto.ts**ï¼š
```typescript
import { IsEmail, IsString, MinLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class LoginDto {
  @ApiProperty({ description: 'é‚®ç®±åœ°å€', example: 'john@example.com' })
  @IsEmail({}, { message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€' })
  email: string;

  @ApiProperty({ description: 'å¯†ç ', example: 'Password123!' })
  @IsString({ message: 'å¯†ç å¿…é¡»æ˜¯å­—ç¬¦ä¸²' })
  @MinLength(1, { message: 'å¯†ç ä¸èƒ½ä¸ºç©º' })
  password: string;
}
```

### ğŸ” è®¤è¯æœåŠ¡å®ç°

#### ğŸ› ï¸ AuthServiceæ ¸å¿ƒé€»è¾‘

**åˆ›å»ºsrc/modules/auth/auth.service.ts**ï¼š
```typescript
import {
  Injectable,
  ConflictException,
  UnauthorizedException,
  BadRequestException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';

import { User, UserStatus } from '../user/entities/user.entity';
import { Role } from '../user/entities/role.entity';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtPayload } from './strategies/jwt.strategy';

export interface AuthResult {
  user: Partial<User>;
  accessToken: string;
  refreshToken: string;
}

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Role)
    private readonly roleRepository: Repository<Role>,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
  ) {}

  /**
   * ç”¨æˆ·æ³¨å†Œ
   */
  async register(registerDto: RegisterDto): Promise<AuthResult> {
    const { username, email, password, confirmPassword, displayName } = registerDto;

    // éªŒè¯å¯†ç ç¡®è®¤
    if (password !== confirmPassword) {
      throw new BadRequestException('å¯†ç å’Œç¡®è®¤å¯†ç ä¸åŒ¹é…');
    }

    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    const existingUserByUsername = await this.userRepository.findOne({
      where: { username },
    });
    if (existingUserByUsername) {
      throw new ConflictException('ç”¨æˆ·åå·²å­˜åœ¨');
    }

    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    const existingUserByEmail = await this.userRepository.findOne({
      where: { email },
    });
    if (existingUserByEmail) {
      throw new ConflictException('é‚®ç®±å·²è¢«æ³¨å†Œ');
    }

    // åŠ å¯†å¯†ç 
    const saltRounds = 12;
    const passwordHash = await bcrypt.hash(password, saltRounds);

    // è·å–é»˜è®¤è§’è‰²
    const defaultRole = await this.roleRepository.findOne({
      where: { name: 'reader' },
    });

    // åˆ›å»ºç”¨æˆ·
    const user = this.userRepository.create({
      username,
      email,
      passwordHash,
      status: UserStatus.ACTIVE,
      roles: defaultRole ? [defaultRole] : [],
      profile: {
        displayName: displayName || username,
      },
    });

    const savedUser = await this.userRepository.save(user);

    // ç”Ÿæˆä»¤ç‰Œ
    const tokens = await this.generateTokens(savedUser);

    return {
      user: this.sanitizeUser(savedUser),
      ...tokens,
    };
  }

  /**
   * ç”¨æˆ·ç™»å½•
   */
  async login(loginDto: LoginDto): Promise<AuthResult> {
    const { email, password } = loginDto;

    // éªŒè¯ç”¨æˆ·å‡­æ®
    const user = await this.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('é‚®ç®±æˆ–å¯†ç é”™è¯¯');
    }

    // æ›´æ–°æœ€åç™»å½•æ—¶é—´
    await this.userRepository.update(user.id, {
      lastLoginAt: new Date(),
    });

    // ç”Ÿæˆä»¤ç‰Œ
    const tokens = await this.generateTokens(user);

    return {
      user: this.sanitizeUser(user),
      ...tokens,
    };
  }

  /**
   * éªŒè¯ç”¨æˆ·å‡­æ®
   */
  async validateUser(email: string, password: string): Promise<User | null> {
    const user = await this.userRepository.findOne({
      where: { email },
      relations: ['roles'],
    });

    if (!user) {
      return null;
    }

    // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    if (user.status !== UserStatus.ACTIVE) {
      throw new UnauthorizedException('ç”¨æˆ·è´¦æˆ·å·²è¢«ç¦ç”¨');
    }

    // éªŒè¯å¯†ç 
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      return null;
    }

    return user;
  }

  /**
   * ç”Ÿæˆè®¿é—®ä»¤ç‰Œå’Œåˆ·æ–°ä»¤ç‰Œ
   */
  private async generateTokens(user: User) {
    const payload: JwtPayload = {
      sub: user.id,
      username: user.username,
      email: user.email,
      roles: user.roles?.map(role => role.name) || [],
    };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(payload, {
        secret: this.configService.get<string>('jwt.secret'),
        expiresIn: this.configService.get<string>('jwt.expiresIn'),
      }),
      this.jwtService.signAsync(payload, {
        secret: this.configService.get<string>('jwt.refreshSecret'),
        expiresIn: this.configService.get<string>('jwt.refreshExpiresIn'),
      }),
    ]);

    return { accessToken, refreshToken };
  }

  /**
   * åˆ·æ–°è®¿é—®ä»¤ç‰Œ
   */
  async refreshToken(refreshToken: string): Promise<{ accessToken: string }> {
    try {
      const payload = this.jwtService.verify(refreshToken, {
        secret: this.configService.get<string>('jwt.refreshSecret'),
      });

      const user = await this.userRepository.findOne({
        where: { id: payload.sub },
        relations: ['roles'],
      });

      if (!user || user.status !== UserStatus.ACTIVE) {
        throw new UnauthorizedException('æ— æ•ˆçš„åˆ·æ–°ä»¤ç‰Œ');
      }

      const newPayload: JwtPayload = {
        sub: user.id,
        username: user.username,
        email: user.email,
        roles: user.roles?.map(role => role.name) || [],
      };

      const accessToken = await this.jwtService.signAsync(newPayload, {
        secret: this.configService.get<string>('jwt.secret'),
        expiresIn: this.configService.get<string>('jwt.expiresIn'),
      });

      return { accessToken };
    } catch (error) {
      throw new UnauthorizedException('æ— æ•ˆçš„åˆ·æ–°ä»¤ç‰Œ');
    }
  }

  /**
   * æ¸…ç†ç”¨æˆ·æ•æ„Ÿä¿¡æ¯
   */
  private sanitizeUser(user: User): Partial<User> {
    const { passwordHash, ...sanitizedUser } = user;
    return sanitizedUser;
  }
}
```

### ğŸ® è®¤è¯æ§åˆ¶å™¨

#### ğŸ“¡ AuthControllerå®ç°

**åˆ›å»ºsrc/modules/auth/auth.controller.ts**ï¼š
```typescript
import {
  Controller,
  Post,
  Body,
  UseGuards,
  Get,
  Request,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
} from '@nestjs/swagger';

import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { RefreshTokenDto } from './dto/refresh-token.dto';

@ApiTags('è®¤è¯')
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('register')
  @ApiOperation({ summary: 'ç”¨æˆ·æ³¨å†Œ' })
  @ApiResponse({ status: 201, description: 'æ³¨å†ŒæˆåŠŸ' })
  @ApiResponse({ status: 400, description: 'è¯·æ±‚å‚æ•°é”™è¯¯' })
  @ApiResponse({ status: 409, description: 'ç”¨æˆ·åæˆ–é‚®ç®±å·²å­˜åœ¨' })
  async register(@Body() registerDto: RegisterDto) {
    const result = await this.authService.register(registerDto);
    return {
      success: true,
      message: 'æ³¨å†ŒæˆåŠŸ',
      data: result,
    };
  }

  @Post('login')
  @HttpCode(HttpStatus.OK)
  @UseGuards(AuthGuard('local'))
  @ApiOperation({ summary: 'ç”¨æˆ·ç™»å½•' })
  @ApiResponse({ status: 200, description: 'ç™»å½•æˆåŠŸ' })
  @ApiResponse({ status: 401, description: 'é‚®ç®±æˆ–å¯†ç é”™è¯¯' })
  async login(@Body() loginDto: LoginDto, @Request() req) {
    const result = await this.authService.login(loginDto);
    return {
      success: true,
      message: 'ç™»å½•æˆåŠŸ',
      data: result,
    };
  }

  @Post('refresh')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'åˆ·æ–°è®¿é—®ä»¤ç‰Œ' })
  @ApiResponse({ status: 200, description: 'åˆ·æ–°æˆåŠŸ' })
  @ApiResponse({ status: 401, description: 'æ— æ•ˆçš„åˆ·æ–°ä»¤ç‰Œ' })
  async refreshToken(@Body() refreshTokenDto: RefreshTokenDto) {
    const result = await this.authService.refreshToken(refreshTokenDto.refreshToken);
    return {
      success: true,
      message: 'ä»¤ç‰Œåˆ·æ–°æˆåŠŸ',
      data: result,
    };
  }

  @Get('profile')
  @UseGuards(AuthGuard('jwt'))
  @ApiBearerAuth()
  @ApiOperation({ summary: 'è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯' })
  @ApiResponse({ status: 200, description: 'è·å–æˆåŠŸ' })
  @ApiResponse({ status: 401, description: 'æœªæˆæƒè®¿é—®' })
  async getProfile(@Request() req) {
    return {
      success: true,
      message: 'è·å–ç”¨æˆ·ä¿¡æ¯æˆåŠŸ',
      data: req.user,
    };
  }

  @Post('logout')
  @UseGuards(AuthGuard('jwt'))
  @ApiBearerAuth()
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'ç”¨æˆ·ç™»å‡º' })
  @ApiResponse({ status: 200, description: 'ç™»å‡ºæˆåŠŸ' })
  async logout(@Request() req) {
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œå¯ä»¥å°†ä»¤ç‰ŒåŠ å…¥é»‘åå•
    // æˆ–è€…æ¸…é™¤Redisä¸­çš„ä¼šè¯ä¿¡æ¯
    return {
      success: true,
      message: 'ç™»å‡ºæˆåŠŸ',
    };
  }
}
```

---

## 9.5.3 è§’è‰²æƒé™ç³»ç»Ÿè®¾è®¡

### ğŸ›¡ï¸ RBACæƒé™æ¨¡å‹

#### ğŸ“Š æƒé™ç³»ç»Ÿæ¶æ„

**æƒé™æ¨¡å‹è®¾è®¡**ï¼š
```
ç”¨æˆ·(User) â†’ è§’è‰²(Role) â†’ æƒé™(Permission) â†’ èµ„æº(Resource)
```

**æƒé™å®šä¹‰ç¤ºä¾‹**ï¼š
```typescript
// æƒé™å¸¸é‡å®šä¹‰
export const PERMISSIONS = {
  // æ–‡ç« æƒé™
  ARTICLE_CREATE: 'article:create',
  ARTICLE_READ: 'article:read',
  ARTICLE_UPDATE: 'article:update',
  ARTICLE_DELETE: 'article:delete',
  ARTICLE_PUBLISH: 'article:publish',
  
  // ç”¨æˆ·æƒé™
  USER_CREATE: 'user:create',
  USER_READ: 'user:read',
  USER_UPDATE: 'user:update',
  USER_DELETE: 'user:delete',
  
  // è¯„è®ºæƒé™
  COMMENT_CREATE: 'comment:create',
  COMMENT_READ: 'comment:read',
  COMMENT_UPDATE: 'comment:update',
  COMMENT_DELETE: 'comment:delete',
  COMMENT_MODERATE: 'comment:moderate',
  
  // ç®¡ç†æƒé™
  ADMIN_DASHBOARD: 'admin:dashboard',
  ADMIN_USERS: 'admin:users',
  ADMIN_CONTENT: 'admin:content',
  ADMIN_SYSTEM: 'admin:system',
} as const;

// è§’è‰²å®šä¹‰
export const ROLES = {
  ADMIN: 'admin',
  EDITOR: 'editor', 
  AUTHOR: 'author',
  READER: 'reader',
} as const;
```

#### ğŸ”’ æƒé™å®ˆå«å®ç°

**åˆ›å»ºsrc/shared/guards/permissions.guard.ts**ï¼š
```typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../../modules/user/entities/user.entity';

@Injectable()
export class PermissionsGuard implements CanActivate {
  constructor(
    private readonly reflector: Reflector,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(
      'permissions',
      [context.getHandler(), context.getClass()],
    );

    if (!requiredPermissions) {
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user;

    if (!user) {
      throw new ForbiddenException('ç”¨æˆ·æœªè®¤è¯');
    }

    // è·å–ç”¨æˆ·å®Œæ•´ä¿¡æ¯ï¼ˆåŒ…æ‹¬è§’è‰²å’Œæƒé™ï¼‰
    const fullUser = await this.userRepository.findOne({
      where: { id: user.id },
      relations: ['roles'],
    });

    if (!fullUser) {
      throw new ForbiddenException('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // è·å–ç”¨æˆ·æ‰€æœ‰æƒé™
    const userPermissions = this.getUserPermissions(fullUser);

    // æ£€æŸ¥æ˜¯å¦æ‹¥æœ‰æ‰€éœ€æƒé™
    const hasPermission = requiredPermissions.every(permission =>
      userPermissions.includes(permission),
    );

    if (!hasPermission) {
      throw new ForbiddenException('æƒé™ä¸è¶³');
    }

    return true;
  }

  private getUserPermissions(user: User): string[] {
    const permissions: string[] = [];
    
    user.roles?.forEach(role => {
      if (role.permissions && Array.isArray(role.permissions)) {
        permissions.push(...role.permissions);
      }
    });

    return [...new Set(permissions)]; // å»é‡
  }
}
```

**åˆ›å»ºæƒé™è£…é¥°å™¨src/shared/decorators/permissions.decorator.ts**ï¼š
```typescript
import { SetMetadata } from '@nestjs/common';

export const RequirePermissions = (...permissions: string[]) =>
  SetMetadata('permissions', permissions);
```

**åˆ›å»ºè§’è‰²è£…é¥°å™¨src/shared/decorators/roles.decorator.ts**ï¼š
```typescript
import { SetMetadata } from '@nestjs/common';

export const RequireRoles = (...roles: string[]) =>
  SetMetadata('roles', roles);
```

### ğŸ¯ æƒé™ä½¿ç”¨ç¤ºä¾‹

#### ğŸ“ åœ¨æ§åˆ¶å™¨ä¸­ä½¿ç”¨æƒé™

```typescript
import { Controller, Get, Post, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { PermissionsGuard } from '../../shared/guards/permissions.guard';
import { RequirePermissions } from '../../shared/decorators/permissions.decorator';
import { PERMISSIONS } from '../../shared/constants/permissions';

@Controller('articles')
@UseGuards(AuthGuard('jwt'))
export class ArticleController {
  
  @Get()
  @RequirePermissions(PERMISSIONS.ARTICLE_READ)
  @UseGuards(PermissionsGuard)
  async findAll() {
    // ä»»ä½•æœ‰è¯»å–æ–‡ç« æƒé™çš„ç”¨æˆ·éƒ½å¯ä»¥è®¿é—®
  }

  @Post()
  @RequirePermissions(PERMISSIONS.ARTICLE_CREATE)
  @UseGuards(PermissionsGuard)
  async create() {
    // åªæœ‰æœ‰åˆ›å»ºæ–‡ç« æƒé™çš„ç”¨æˆ·æ‰èƒ½è®¿é—®
  }

  @Post(':id/publish')
  @RequirePermissions(PERMISSIONS.ARTICLE_PUBLISH)
  @UseGuards(PermissionsGuard)
  async publish() {
    // åªæœ‰æœ‰å‘å¸ƒæ–‡ç« æƒé™çš„ç”¨æˆ·æ‰èƒ½è®¿é—®
  }
}
```

---

## 9.5.4 å¯†ç å®‰å…¨ç­–ç•¥

### ğŸ” å¯†ç åŠ å¯†å’ŒéªŒè¯

#### ğŸ›¡ï¸ å¯†ç å®‰å…¨æœ€ä½³å®è·µ

**1. å¯†ç å¼ºåº¦è¦æ±‚**ï¼š
- æœ€å°‘8ä¸ªå­—ç¬¦
- åŒ…å«å¤§å°å†™å­—æ¯
- åŒ…å«æ•°å­—
- åŒ…å«ç‰¹æ®Šå­—ç¬¦
- ä¸èƒ½æ˜¯å¸¸è§å¯†ç 

**2. åŠ å¯†ç­–ç•¥**ï¼š
- ä½¿ç”¨bcryptç®—æ³•
- ç›å€¼è½®æ•°è®¾ç½®ä¸º12
- å¯†ç å“ˆå¸Œå­˜å‚¨

**3. å¯†ç éªŒè¯**ï¼š
- ç™»å½•æ—¶éªŒè¯
- å¯†ç ä¿®æ”¹æ—¶éªŒè¯æ—§å¯†ç 
- é˜²æ­¢æš´åŠ›ç ´è§£

#### ğŸ”§ å¯†ç å·¥å…·ç±»

**åˆ›å»ºsrc/shared/utils/password.util.ts**ï¼š
```typescript
import * as bcrypt from 'bcrypt';

export class PasswordUtil {
  private static readonly SALT_ROUNDS = 12;

  /**
   * åŠ å¯†å¯†ç 
   */
  static async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, this.SALT_ROUNDS);
  }

  /**
   * éªŒè¯å¯†ç 
   */
  static async comparePassword(
    password: string,
    hashedPassword: string,
  ): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }

  /**
   * ç”Ÿæˆéšæœºå¯†ç 
   */
  static generateRandomPassword(length: number = 12): string {
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$!%*?&';
    let password = '';
    
    // ç¡®ä¿åŒ…å«å„ç§å­—ç¬¦ç±»å‹
    password += this.getRandomChar('abcdefghijklmnopqrstuvwxyz'); // å°å†™å­—æ¯
    password += this.getRandomChar('ABCDEFGHIJKLMNOPQRSTUVWXYZ'); // å¤§å†™å­—æ¯
    password += this.getRandomChar('0123456789'); // æ•°å­—
    password += this.getRandomChar('@$!%*?&'); // ç‰¹æ®Šå­—ç¬¦
    
    // å¡«å……å‰©ä½™é•¿åº¦
    for (let i = password.length; i < length; i++) {
      password += this.getRandomChar(charset);
    }
    
    // æ‰“ä¹±å­—ç¬¦é¡ºåº
    return password.split('').sort(() => Math.random() - 0.5).join('');
  }

  private static getRandomChar(charset: string): string {
    return charset.charAt(Math.floor(Math.random() * charset.length));
  }

  /**
   * éªŒè¯å¯†ç å¼ºåº¦
   */
  static validatePasswordStrength(password: string): {
    isValid: boolean;
    score: number;
    feedback: string[];
  } {
    const feedback: string[] = [];
    let score = 0;

    // é•¿åº¦æ£€æŸ¥
    if (password.length >= 8) {
      score += 1;
    } else {
      feedback.push('å¯†ç é•¿åº¦è‡³å°‘8ä¸ªå­—ç¬¦');
    }

    // å¤§å†™å­—æ¯
    if (/[A-Z]/.test(password)) {
      score += 1;
    } else {
      feedback.push('å¯†ç éœ€è¦åŒ…å«å¤§å†™å­—æ¯');
    }

    // å°å†™å­—æ¯
    if (/[a-z]/.test(password)) {
      score += 1;
    } else {
      feedback.push('å¯†ç éœ€è¦åŒ…å«å°å†™å­—æ¯');
    }

    // æ•°å­—
    if (/\d/.test(password)) {
      score += 1;
    } else {
      feedback.push('å¯†ç éœ€è¦åŒ…å«æ•°å­—');
    }

    // ç‰¹æ®Šå­—ç¬¦
    if (/[@$!%*?&]/.test(password)) {
      score += 1;
    } else {
      feedback.push('å¯†ç éœ€è¦åŒ…å«ç‰¹æ®Šå­—ç¬¦');
    }

    // é•¿åº¦åŠ åˆ†
    if (password.length >= 12) {
      score += 1;
    }

    return {
      isValid: score >= 4,
      score,
      feedback,
    };
  }
}
```

### ğŸ”’ ä¼šè¯ç®¡ç†

#### ğŸ“Š ä¼šè¯å®‰å…¨ç­–ç•¥

**1. ä»¤ç‰Œç®¡ç†**ï¼š
- è®¿é—®ä»¤ç‰ŒçŸ­æœŸæœ‰æ•ˆï¼ˆ15åˆ†é’Ÿ-1å°æ—¶ï¼‰
- åˆ·æ–°ä»¤ç‰Œé•¿æœŸæœ‰æ•ˆï¼ˆ7-30å¤©ï¼‰
- ä»¤ç‰Œè½®æ¢æœºåˆ¶

**2. ä¼šè¯ç›‘æ§**ï¼š
- è®°å½•ç™»å½•IPå’Œè®¾å¤‡ä¿¡æ¯
- æ£€æµ‹å¼‚å¸¸ç™»å½•è¡Œä¸º
- æ”¯æŒå¼ºåˆ¶ä¸‹çº¿

**3. å®‰å…¨æªæ–½**ï¼š
- é˜²æ­¢CSRFæ”»å‡»
- é˜²æ­¢XSSæ”»å‡»
- å®æ–½é€Ÿç‡é™åˆ¶

#### ğŸ› ï¸ ä¼šè¯æœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/auth/session.service.ts**ï¼š
```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { UserSession } from './entities/user-session.entity';

@Injectable()
export class SessionService {
  constructor(
    @InjectRepository(UserSession)
    private readonly sessionRepository: Repository<UserSession>,
  ) {}

  /**
   * åˆ›å»ºç”¨æˆ·ä¼šè¯
   */
  async createSession(
    userId: string,
    refreshToken: string,
    ipAddress: string,
    userAgent: string,
  ): Promise<UserSession> {
    const session = this.sessionRepository.create({
      userId,
      refreshToken,
      ipAddress,
      userAgent,
      isActive: true,
      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30å¤©
    });

    return this.sessionRepository.save(session);
  }

  /**
   * éªŒè¯ä¼šè¯
   */
  async validateSession(refreshToken: string): Promise<UserSession | null> {
    return this.sessionRepository.findOne({
      where: {
        refreshToken,
        isActive: true,
      },
    });
  }

  /**
   * æ’¤é”€ä¼šè¯
   */
  async revokeSession(refreshToken: string): Promise<void> {
    await this.sessionRepository.update(
      { refreshToken },
      { isActive: false },
    );
  }

  /**
   * æ’¤é”€ç”¨æˆ·æ‰€æœ‰ä¼šè¯
   */
  async revokeAllUserSessions(userId: string): Promise<void> {
    await this.sessionRepository.update(
      { userId, isActive: true },
      { isActive: false },
    );
  }

  /**
   * æ¸…ç†è¿‡æœŸä¼šè¯
   */
  async cleanupExpiredSessions(): Promise<void> {
    await this.sessionRepository.delete({
      expiresAt: { $lt: new Date() },
    });
  }
}
```

---

## ğŸ“Š æœ¬èŠ‚æ€»ç»“

### ğŸ¯ å…³é”®è¦ç‚¹å›é¡¾

1. **JWTè®¤è¯æ˜¯ç°ä»£Webåº”ç”¨çš„æ ‡å‡†**
   - æ— çŠ¶æ€è®¾è®¡ï¼Œæ˜“äºæ‰©å±•
   - åŒ…å«ç”¨æˆ·ä¿¡æ¯å’Œæƒé™
   - æ”¯æŒè·¨åŸŸå’Œç§»åŠ¨ç«¯

2. **ç”¨æˆ·è®¤è¯æµç¨‹è¦å®Œæ•´å®‰å…¨**
   - æ³¨å†Œæ—¶éªŒè¯ç”¨æˆ·ä¿¡æ¯å”¯ä¸€æ€§
   - ç™»å½•æ—¶éªŒè¯å‡­æ®å’Œç”¨æˆ·çŠ¶æ€
   - æ”¯æŒä»¤ç‰Œåˆ·æ–°å’Œä¼šè¯ç®¡ç†

3. **æƒé™ç³»ç»Ÿè¦çµæ´»å¯æ‰©å±•**
   - åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ï¼ˆRBACï¼‰
   - ç»†ç²’åº¦çš„æƒé™æ§åˆ¶
   - æ”¯æŒåŠ¨æ€æƒé™åˆ†é…

4. **å¯†ç å®‰å…¨è¦ç¬¦åˆæœ€ä½³å®è·µ**
   - å¼ºå¯†ç ç­–ç•¥
   - å®‰å…¨çš„åŠ å¯†ç®—æ³•
   - å®Œå–„çš„ä¼šè¯ç®¡ç†

### ğŸ“ å®è·µç»ƒä¹ 

#### ç»ƒä¹ 1ï¼šå®Œæ•´è®¤è¯ç³»ç»Ÿå®ç°
**ä»»åŠ¡**ï¼šå®ç°å®Œæ•´çš„ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
**è¦æ±‚**ï¼š
- å®ç°ç”¨æˆ·æ³¨å†Œå’Œç™»å½•
- é…ç½®JWTè®¤è¯ç­–ç•¥
- æ·»åŠ å¯†ç å¼ºåº¦éªŒè¯
- å®ç°ä»¤ç‰Œåˆ·æ–°æœºåˆ¶

#### ç»ƒä¹ 2ï¼šæƒé™ç³»ç»Ÿè®¾è®¡
**ä»»åŠ¡**ï¼šè®¾è®¡å’Œå®ç°è§’è‰²æƒé™ç³»ç»Ÿ
**è¦æ±‚**ï¼š
- å®šä¹‰è§’è‰²å’Œæƒé™å¸¸é‡
- å®ç°æƒé™å®ˆå«
- åˆ›å»ºæƒé™è£…é¥°å™¨
- åœ¨æ§åˆ¶å™¨ä¸­åº”ç”¨æƒé™æ§åˆ¶

#### ç»ƒä¹ 3ï¼šå®‰å…¨ç­–ç•¥åŠ å¼º
**ä»»åŠ¡**ï¼šåŠ å¼ºç³»ç»Ÿå®‰å…¨ç­–ç•¥
**è¦æ±‚**ï¼š
- å®ç°ä¼šè¯ç®¡ç†
- æ·»åŠ ç™»å½•æ—¥å¿—è®°å½•
- å®æ–½é€Ÿç‡é™åˆ¶
- æ·»åŠ å®‰å…¨å¤´è®¾ç½®

### ğŸ” è‡ªæˆ‘æ£€æµ‹

- [ ] æˆ‘ç†è§£JWTè®¤è¯çš„å·¥ä½œåŸç†
- [ ] æˆ‘èƒ½å¤Ÿå®ç°å®Œæ•´çš„ç”¨æˆ·è®¤è¯æµç¨‹
- [ ] æˆ‘æŒæ¡äº†è§’è‰²æƒé™ç³»ç»Ÿçš„è®¾è®¡
- [ ] æˆ‘äº†è§£å¯†ç å®‰å…¨çš„æœ€ä½³å®è·µ
- [ ] æˆ‘èƒ½å¤Ÿå®æ–½ä¼šè¯ç®¡ç†å’Œå®‰å…¨ç­–ç•¥

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ 

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… JWTè®¤è¯æœºåˆ¶çš„å®ç°
- âœ… ç”¨æˆ·æ³¨å†Œå’Œç™»å½•åŠŸèƒ½
- âœ… è§’è‰²æƒé™ç³»ç»Ÿè®¾è®¡
- âœ… å¯†ç å®‰å…¨ç­–ç•¥å®æ–½

**å‡†å¤‡å¥½è¿›å…¥ç¬¬9.6èŠ‚äº†å—ï¼Ÿ** ğŸš€

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å®ç°å†…å®¹ç®¡ç†æ¨¡å—ï¼ŒåŒ…æ‹¬ï¼š
- ğŸ“ æ–‡ç« CRUDæ“ä½œå®ç°
- ğŸ·ï¸ åˆ†ç±»æ ‡ç­¾ç³»ç»Ÿè®¾è®¡
- ğŸ“ æ–‡ä»¶ä¸Šä¼ å¤„ç†
- ğŸ” å¯Œæ–‡æœ¬ç¼–è¾‘å™¨é›†æˆ 