# ç¬¬9.9èŠ‚ æµ‹è¯•ä½“ç³»å»ºè®¾

> **è´¨é‡ä¿è¯** - æ„å»ºå®Œå–„çš„è‡ªåŠ¨åŒ–æµ‹è¯•ä½“ç³»

## ğŸ“š æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

### ğŸ¯ çŸ¥è¯†ç›®æ ‡
- [ ] **æŒæ¡å•å…ƒæµ‹è¯•ç¼–å†™**ï¼šå­¦ä¼šä½¿ç”¨Jestç¼–å†™é«˜è´¨é‡çš„å•å…ƒæµ‹è¯•
- [ ] **ç†è§£é›†æˆæµ‹è¯•è®¾è®¡**ï¼šæŒæ¡APIæ¥å£å’Œæ•°æ®åº“é›†æˆæµ‹è¯•
- [ ] **å­¦ä¼šæµ‹è¯•è¦†ç›–ç‡åˆ†æ**ï¼šä½¿ç”¨å·¥å…·åˆ†æå’Œæå‡æµ‹è¯•è¦†ç›–ç‡
- [ ] **æŒæ¡è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹**ï¼šå»ºç«‹CI/CDä¸­çš„è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

### ğŸ› ï¸ æŠ€èƒ½ç›®æ ‡
- [ ] èƒ½å¤Ÿç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•ç”¨ä¾‹
- [ ] èƒ½å¤Ÿè®¾è®¡æœ‰æ•ˆçš„é›†æˆæµ‹è¯•
- [ ] èƒ½å¤Ÿåˆ†æå’Œä¼˜åŒ–æµ‹è¯•è¦†ç›–ç‡
- [ ] èƒ½å¤Ÿå»ºç«‹è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

### â° å­¦ä¹ æ—¶é•¿
- **ç†è®ºå­¦ä¹ **ï¼š2-3å°æ—¶
- **å®è·µå¼€å‘**ï¼š4-5å°æ—¶
- **æ€»è®¡æ—¶é•¿**ï¼š6-8å°æ—¶

---

## 9.9.1 å•å…ƒæµ‹è¯•ç¼–å†™

### ğŸ§ª æµ‹è¯•ç¯å¢ƒé…ç½®

#### ğŸ“¦ æµ‹è¯•ä¾èµ–å®‰è£…

```bash
# æµ‹è¯•æ¡†æ¶å’Œå·¥å…·
npm install -D jest @types/jest ts-jest

# NestJSæµ‹è¯•å·¥å…·
npm install -D @nestjs/testing supertest @types/supertest

# æ•°æ®åº“æµ‹è¯•å·¥å…·
npm install -D sqlite3 @types/sqlite3

# æµ‹è¯•è¦†ç›–ç‡å·¥å…·
npm install -D jest-coverage-badges-generator
```

#### âš™ï¸ Jesté…ç½®

**æ›´æ–°package.jsonæµ‹è¯•é…ç½®**ï¼š
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json"
  },
  "jest": {
    "moduleFileExtensions": ["js", "json", "ts"],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s",
      "!**/*.spec.ts",
      "!**/*.interface.ts",
      "!**/node_modules/**",
      "!**/dist/**"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node",
    "coverageReporters": ["text", "lcov", "html"],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### ğŸ› ï¸ æœåŠ¡å±‚å•å…ƒæµ‹è¯•

#### ğŸ“ AuthServiceæµ‹è¯•

**åˆ›å»ºsrc/modules/auth/auth.service.spec.ts**ï¼š
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';

import { AuthService } from './auth.service';
import { User, UserStatus } from '../user/entities/user.entity';
import { Role } from '../user/entities/role.entity';
import { ConflictException, UnauthorizedException } from '@nestjs/common';

describe('AuthService', () => {
  let service: AuthService;
  let userRepository: Repository<User>;
  let roleRepository: Repository<Role>;
  let jwtService: JwtService;
  let configService: ConfigService;

  const mockUser = {
    id: 'user-id',
    username: 'testuser',
    email: 'test@example.com',
    passwordHash: 'hashed-password',
    status: UserStatus.ACTIVE,
    roles: [{ id: 'role-id', name: 'reader' }],
  };

  const mockUserRepository = {
    findOne: jest.fn(),
    create: jest.fn(),
    save: jest.fn(),
    update: jest.fn(),
  };

  const mockRoleRepository = {
    findOne: jest.fn(),
  };

  const mockJwtService = {
    signAsync: jest.fn(),
    verify: jest.fn(),
  };

  const mockConfigService = {
    get: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: getRepositoryToken(User),
          useValue: mockUserRepository,
        },
        {
          provide: getRepositoryToken(Role),
          useValue: mockRoleRepository,
        },
        {
          provide: JwtService,
          useValue: mockJwtService,
        },
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    userRepository = module.get<Repository<User>>(getRepositoryToken(User));
    roleRepository = module.get<Repository<Role>>(getRepositoryToken(Role));
    jwtService = module.get<JwtService>(JwtService);
    configService = module.get<ConfigService>(ConfigService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('register', () => {
    const registerDto = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'Password123!',
      confirmPassword: 'Password123!',
    };

    it('should register a new user successfully', async () => {
      // Arrange
      mockUserRepository.findOne.mockResolvedValueOnce(null); // username check
      mockUserRepository.findOne.mockResolvedValueOnce(null); // email check
      mockRoleRepository.findOne.mockResolvedValue({ id: 'role-id', name: 'reader' });
      mockUserRepository.create.mockReturnValue(mockUser);
      mockUserRepository.save.mockResolvedValue(mockUser);
      mockJwtService.signAsync.mockResolvedValue('access-token');
      mockConfigService.get.mockReturnValue('secret');

      jest.spyOn(bcrypt, 'hash').mockResolvedValue('hashed-password' as never);

      // Act
      const result = await service.register(registerDto);

      // Assert
      expect(result).toHaveProperty('user');
      expect(result).toHaveProperty('accessToken');
      expect(result).toHaveProperty('refreshToken');
      expect(mockUserRepository.save).toHaveBeenCalled();
    });

    it('should throw ConflictException if username exists', async () => {
      // Arrange
      mockUserRepository.findOne.mockResolvedValueOnce(mockUser);

      // Act & Assert
      await expect(service.register(registerDto)).rejects.toThrow(ConflictException);
    });

    it('should throw ConflictException if email exists', async () => {
      // Arrange
      mockUserRepository.findOne.mockResolvedValueOnce(null); // username check
      mockUserRepository.findOne.mockResolvedValueOnce(mockUser); // email check

      // Act & Assert
      await expect(service.register(registerDto)).rejects.toThrow(ConflictException);
    });
  });

  describe('validateUser', () => {
    it('should return user if credentials are valid', async () => {
      // Arrange
      mockUserRepository.findOne.mockResolvedValue(mockUser);
      jest.spyOn(bcrypt, 'compare').mockResolvedValue(true as never);

      // Act
      const result = await service.validateUser('test@example.com', 'password');

      // Assert
      expect(result).toEqual(mockUser);
    });

    it('should return null if user not found', async () => {
      // Arrange
      mockUserRepository.findOne.mockResolvedValue(null);

      // Act
      const result = await service.validateUser('test@example.com', 'password');

      // Assert
      expect(result).toBeNull();
    });

    it('should return null if password is invalid', async () => {
      // Arrange
      mockUserRepository.findOne.mockResolvedValue(mockUser);
      jest.spyOn(bcrypt, 'compare').mockResolvedValue(false as never);

      // Act
      const result = await service.validateUser('test@example.com', 'password');

      // Assert
      expect(result).toBeNull();
    });

    it('should throw UnauthorizedException if user is inactive', async () => {
      // Arrange
      const inactiveUser = { ...mockUser, status: UserStatus.INACTIVE };
      mockUserRepository.findOne.mockResolvedValue(inactiveUser);

      // Act & Assert
      await expect(
        service.validateUser('test@example.com', 'password')
      ).rejects.toThrow(UnauthorizedException);
    });
  });

  describe('refreshToken', () => {
    it('should return new access token if refresh token is valid', async () => {
      // Arrange
      const payload = { sub: 'user-id', username: 'testuser' };
      mockJwtService.verify.mockReturnValue(payload);
      mockUserRepository.findOne.mockResolvedValue(mockUser);
      mockJwtService.signAsync.mockResolvedValue('new-access-token');
      mockConfigService.get.mockReturnValue('secret');

      // Act
      const result = await service.refreshToken('valid-refresh-token');

      // Assert
      expect(result).toHaveProperty('accessToken', 'new-access-token');
    });

    it('should throw UnauthorizedException if refresh token is invalid', async () => {
      // Arrange
      mockJwtService.verify.mockImplementation(() => {
        throw new Error('Invalid token');
      });

      // Act & Assert
      await expect(service.refreshToken('invalid-token')).rejects.toThrow(
        UnauthorizedException
      );
    });
  });
});
```

#### ğŸ“ ArticleServiceæµ‹è¯•

**åˆ›å»ºsrc/modules/article/article.service.spec.ts**ï¼š
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { NotFoundException, ForbiddenException } from '@nestjs/common';

import { ArticleService } from './article.service';
import { Article, ArticleStatus } from './entities/article.entity';
import { Category } from './entities/category.entity';
import { Tag } from './entities/tag.entity';

describe('ArticleService', () => {
  let service: ArticleService;
  let articleRepository: Repository<Article>;
  let categoryRepository: Repository<Category>;
  let tagRepository: Repository<Tag>;

  const mockArticle = {
    id: 'article-id',
    title: 'Test Article',
    content: 'Test content',
    status: ArticleStatus.PUBLISHED,
    author: { id: 'author-id' },
    slug: 'test-article',
  };

  const mockArticleRepository = {
    create: jest.fn(),
    save: jest.fn(),
    findOne: jest.fn(),
    createQueryBuilder: jest.fn(),
    increment: jest.fn(),
    remove: jest.fn(),
  };

  const mockCategoryRepository = {
    findOne: jest.fn(),
  };

  const mockTagRepository = {
    findByIds: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ArticleService,
        {
          provide: getRepositoryToken(Article),
          useValue: mockArticleRepository,
        },
        {
          provide: getRepositoryToken(Category),
          useValue: mockCategoryRepository,
        },
        {
          provide: getRepositoryToken(Tag),
          useValue: mockTagRepository,
        },
      ],
    }).compile();

    service = module.get<ArticleService>(ArticleService);
    articleRepository = module.get<Repository<Article>>(getRepositoryToken(Article));
    categoryRepository = module.get<Repository<Category>>(getRepositoryToken(Category));
    tagRepository = module.get<Repository<Tag>>(getRepositoryToken(Tag));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('create', () => {
    const createArticleDto = {
      title: 'Test Article',
      content: 'Test content',
      status: ArticleStatus.DRAFT,
      categoryId: 'category-id',
      tagIds: ['tag-1', 'tag-2'],
    };

    it('should create article successfully', async () => {
      // Arrange
      const mockCategory = { id: 'category-id', name: 'Test Category' };
      const mockTags = [
        { id: 'tag-1', name: 'Tag 1' },
        { id: 'tag-2', name: 'Tag 2' },
      ];

      mockCategoryRepository.findOne.mockResolvedValue(mockCategory);
      mockTagRepository.findByIds.mockResolvedValue(mockTags);
      mockArticleRepository.findOne.mockResolvedValue(null); // for slug check
      mockArticleRepository.create.mockReturnValue(mockArticle);
      mockArticleRepository.save.mockResolvedValue(mockArticle);

      // Act
      const result = await service.create(createArticleDto, 'author-id');

      // Assert
      expect(result).toEqual(mockArticle);
      expect(mockArticleRepository.save).toHaveBeenCalled();
    });

    it('should generate unique slug', async () => {
      // Arrange
      mockCategoryRepository.findOne.mockResolvedValue(null);
      mockTagRepository.findByIds.mockResolvedValue([]);
      mockArticleRepository.findOne.mockResolvedValueOnce(mockArticle); // slug exists
      mockArticleRepository.findOne.mockResolvedValueOnce(null); // new slug available
      mockArticleRepository.create.mockReturnValue(mockArticle);
      mockArticleRepository.save.mockResolvedValue(mockArticle);

      // Act
      await service.create(createArticleDto, 'author-id');

      // Assert
      expect(mockArticleRepository.findOne).toHaveBeenCalledTimes(2);
    });
  });

  describe('findOne', () => {
    it('should return article and increment view count', async () => {
      // Arrange
      mockArticleRepository.findOne.mockResolvedValue(mockArticle);

      // Act
      const result = await service.findOne('article-id');

      // Assert
      expect(result).toEqual(mockArticle);
      expect(mockArticleRepository.increment).toHaveBeenCalledWith(
        { id: 'article-id' },
        'viewCount',
        1
      );
    });

    it('should throw NotFoundException if article not found', async () => {
      // Arrange
      mockArticleRepository.findOne.mockResolvedValue(null);

      // Act & Assert
      await expect(service.findOne('non-existent-id')).rejects.toThrow(
        NotFoundException
      );
    });
  });

  describe('update', () => {
    const updateArticleDto = {
      title: 'Updated Title',
      content: 'Updated content',
    };

    it('should update article successfully', async () => {
      // Arrange
      mockArticleRepository.findOne.mockResolvedValue(mockArticle);
      mockArticleRepository.save.mockResolvedValue({
        ...mockArticle,
        ...updateArticleDto,
      });

      // Act
      const result = await service.update('article-id', updateArticleDto, 'author-id');

      // Assert
      expect(result.title).toBe(updateArticleDto.title);
      expect(mockArticleRepository.save).toHaveBeenCalled();
    });

    it('should throw ForbiddenException if user is not author', async () => {
      // Arrange
      mockArticleRepository.findOne.mockResolvedValue(mockArticle);

      // Act & Assert
      await expect(
        service.update('article-id', updateArticleDto, 'different-user-id')
      ).rejects.toThrow(ForbiddenException);
    });
  });

  describe('remove', () => {
    it('should remove article successfully', async () => {
      // Arrange
      mockArticleRepository.findOne.mockResolvedValue(mockArticle);
      mockArticleRepository.remove.mockResolvedValue(mockArticle);

      // Act
      const result = await service.remove('article-id', 'author-id');

      // Assert
      expect(result).toHaveProperty('message', 'æ–‡ç« åˆ é™¤æˆåŠŸ');
      expect(mockArticleRepository.remove).toHaveBeenCalledWith(mockArticle);
    });

    it('should throw ForbiddenException if user is not author', async () => {
      // Arrange
      mockArticleRepository.findOne.mockResolvedValue(mockArticle);

      // Act & Assert
      await expect(
        service.remove('article-id', 'different-user-id')
      ).rejects.toThrow(ForbiddenException);
    });
  });
});
```

---

## 9.9.2 é›†æˆæµ‹è¯•è®¾è®¡

### ğŸ”„ APIé›†æˆæµ‹è¯•

#### ğŸ“¡ AuthControlleré›†æˆæµ‹è¯•

**åˆ›å»ºtest/auth.e2e-spec.ts**ï¼š
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import * as request from 'supertest';

import { AppModule } from '../src/app.module';
import { User } from '../src/modules/user/entities/user.entity';
import { Role } from '../src/modules/user/entities/role.entity';

describe('AuthController (e2e)', () => {
  let app: INestApplication;
  let userRepository: any;
  let roleRepository: any;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        AppModule,
        TypeOrmModule.forRoot({
          type: 'sqlite',
          database: ':memory:',
          entities: [User, Role],
          synchronize: true,
        }),
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    userRepository = moduleFixture.get('UserRepository');
    roleRepository = moduleFixture.get('RoleRepository');

    // åˆ›å»ºé»˜è®¤è§’è‰²
    const defaultRole = roleRepository.create({
      name: 'reader',
      description: 'æ™®é€šè¯»è€…',
      permissions: ['article:read'],
    });
    await roleRepository.save(defaultRole);
  });

  afterAll(async () => {
    await app.close();
  });

  beforeEach(async () => {
    // æ¸…ç†æ•°æ®
    await userRepository.clear();
  });

  describe('/auth/register (POST)', () => {
    const registerDto = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'Password123!',
      confirmPassword: 'Password123!',
    };

    it('should register a new user', () => {
      return request(app.getHttpServer())
        .post('/auth/register')
        .send(registerDto)
        .expect(201)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(res.body.data).toHaveProperty('user');
          expect(res.body.data).toHaveProperty('accessToken');
          expect(res.body.data).toHaveProperty('refreshToken');
          expect(res.body.data.user.email).toBe(registerDto.email);
        });
    });

    it('should return 409 if username already exists', async () => {
      // å…ˆåˆ›å»ºä¸€ä¸ªç”¨æˆ·
      await request(app.getHttpServer())
        .post('/auth/register')
        .send(registerDto);

      // å°è¯•ç”¨ç›¸åŒç”¨æˆ·åæ³¨å†Œ
      return request(app.getHttpServer())
        .post('/auth/register')
        .send(registerDto)
        .expect(409);
    });

    it('should return 400 if password confirmation does not match', () => {
      return request(app.getHttpServer())
        .post('/auth/register')
        .send({
          ...registerDto,
          confirmPassword: 'DifferentPassword123!',
        })
        .expect(400);
    });

    it('should return 400 if email format is invalid', () => {
      return request(app.getHttpServer())
        .post('/auth/register')
        .send({
          ...registerDto,
          email: 'invalid-email',
        })
        .expect(400);
    });
  });

  describe('/auth/login (POST)', () => {
    const registerDto = {
      username: 'testuser',
      email: 'test@example.com',
      password: 'Password123!',
      confirmPassword: 'Password123!',
    };

    const loginDto = {
      email: 'test@example.com',
      password: 'Password123!',
    };

    beforeEach(async () => {
      // æ³¨å†Œç”¨æˆ·
      await request(app.getHttpServer())
        .post('/auth/register')
        .send(registerDto);
    });

    it('should login successfully', () => {
      return request(app.getHttpServer())
        .post('/auth/login')
        .send(loginDto)
        .expect(200)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(res.body.data).toHaveProperty('user');
          expect(res.body.data).toHaveProperty('accessToken');
          expect(res.body.data).toHaveProperty('refreshToken');
        });
    });

    it('should return 401 for invalid credentials', () => {
      return request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: 'test@example.com',
          password: 'WrongPassword',
        })
        .expect(401);
    });

    it('should return 401 for non-existent user', () => {
      return request(app.getHttpServer())
        .post('/auth/login')
        .send({
          email: 'nonexistent@example.com',
          password: 'Password123!',
        })
        .expect(401);
    });
  });

  describe('/auth/profile (GET)', () => {
    let accessToken: string;

    beforeEach(async () => {
      // æ³¨å†Œå¹¶ç™»å½•è·å–token
      const registerResponse = await request(app.getHttpServer())
        .post('/auth/register')
        .send({
          username: 'testuser',
          email: 'test@example.com',
          password: 'Password123!',
          confirmPassword: 'Password123!',
        });

      accessToken = registerResponse.body.data.accessToken;
    });

    it('should return user profile', () => {
      return request(app.getHttpServer())
        .get('/auth/profile')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(res.body.data).toHaveProperty('id');
          expect(res.body.data).toHaveProperty('username');
          expect(res.body.data).toHaveProperty('email');
        });
    });

    it('should return 401 without token', () => {
      return request(app.getHttpServer())
        .get('/auth/profile')
        .expect(401);
    });

    it('should return 401 with invalid token', () => {
      return request(app.getHttpServer())
        .get('/auth/profile')
        .set('Authorization', 'Bearer invalid-token')
        .expect(401);
    });
  });
});
```

#### ğŸ“ ArticleControlleré›†æˆæµ‹è¯•

**åˆ›å»ºtest/article.e2e-spec.ts**ï¼š
```typescript
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';

import { AppModule } from '../src/app.module';
import { ArticleStatus } from '../src/modules/article/entities/article.entity';

describe('ArticleController (e2e)', () => {
  let app: INestApplication;
  let accessToken: string;
  let userId: string;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();

    // æ³¨å†Œç”¨æˆ·å¹¶è·å–token
    const registerResponse = await request(app.getHttpServer())
      .post('/auth/register')
      .send({
        username: 'testuser',
        email: 'test@example.com',
        password: 'Password123!',
        confirmPassword: 'Password123!',
      });

    accessToken = registerResponse.body.data.accessToken;
    userId = registerResponse.body.data.user.id;
  });

  afterAll(async () => {
    await app.close();
  });

  describe('/articles (POST)', () => {
    const createArticleDto = {
      title: 'Test Article',
      content: 'This is a test article content.',
      status: ArticleStatus.PUBLISHED,
    };

    it('should create article successfully', () => {
      return request(app.getHttpServer())
        .post('/articles')
        .set('Authorization', `Bearer ${accessToken}`)
        .send(createArticleDto)
        .expect(201)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(res.body.data).toHaveProperty('id');
          expect(res.body.data.title).toBe(createArticleDto.title);
          expect(res.body.data.status).toBe(createArticleDto.status);
        });
    });

    it('should return 401 without authentication', () => {
      return request(app.getHttpServer())
        .post('/articles')
        .send(createArticleDto)
        .expect(401);
    });

    it('should return 400 for invalid data', () => {
      return request(app.getHttpServer())
        .post('/articles')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          title: '', // ç©ºæ ‡é¢˜
          content: 'Content',
          status: ArticleStatus.PUBLISHED,
        })
        .expect(400);
    });
  });

  describe('/articles (GET)', () => {
    beforeEach(async () => {
      // åˆ›å»ºæµ‹è¯•æ–‡ç« 
      await request(app.getHttpServer())
        .post('/articles')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          title: 'Test Article 1',
          content: 'Content 1',
          status: ArticleStatus.PUBLISHED,
        });

      await request(app.getHttpServer())
        .post('/articles')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          title: 'Test Article 2',
          content: 'Content 2',
          status: ArticleStatus.PUBLISHED,
        });
    });

    it('should return articles list', () => {
      return request(app.getHttpServer())
        .get('/articles')
        .expect(200)
        .expect((res) => {
          expect(res.body.success).toBe(true);
          expect(res.body.data).toHaveProperty('items');
          expect(res.body.data).toHaveProperty('pagination');
          expect(Array.isArray(res.body.data.items)).toBe(true);
        });
    });

    it('should support pagination', () => {
      return request(app.getHttpServer())
        .get('/articles?page=1&limit=1')
        .expect(200)
        .expect((res) => {
          expect(res.body.data.pagination.page).toBe(1);
          expect(res.body.data.pagination.limit).toBe(1);
          expect(res.body.data.items.length).toBeLessThanOrEqual(1);
        });
    });

    it('should support status filtering', () => {
      return request(app.getHttpServer())
        .get(`/articles?status=${ArticleStatus.PUBLISHED}`)
        .expect(200)
        .expect((res) => {
          res.body.data.items.forEach((article: any) => {
            expect(article.status).toBe(ArticleStatus.PUBLISHED);
          });
        });
    });
  });
});
```

---

## 9.9.3 æµ‹è¯•è¦†ç›–ç‡åˆ†æ

### ğŸ“Š è¦†ç›–ç‡é…ç½®

#### ğŸ”§ è¦†ç›–ç‡æŠ¥å‘Šç”Ÿæˆ

**åˆ›å»ºscripts/test-coverage.js**ï¼š
```javascript
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
console.log('ğŸ§ª Running tests with coverage...');
execSync('npm run test:cov', { stdio: 'inherit' });

// è¯»å–è¦†ç›–ç‡æ•°æ®
const coveragePath = path.join(__dirname, '../coverage/coverage-summary.json');
if (fs.existsSync(coveragePath)) {
  const coverage = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
  
  console.log('\nğŸ“Š Coverage Summary:');
  console.log(`Lines: ${coverage.total.lines.pct}%`);
  console.log(`Functions: ${coverage.total.functions.pct}%`);
  console.log(`Branches: ${coverage.total.branches.pct}%`);
  console.log(`Statements: ${coverage.total.statements.pct}%`);
  
  // æ£€æŸ¥è¦†ç›–ç‡é˜ˆå€¼
  const threshold = 80;
  const metrics = ['lines', 'functions', 'branches', 'statements'];
  
  let passed = true;
  metrics.forEach(metric => {
    if (coverage.total[metric].pct < threshold) {
      console.log(`âŒ ${metric} coverage (${coverage.total[metric].pct}%) below threshold (${threshold}%)`);
      passed = false;
    }
  });
  
  if (passed) {
    console.log('âœ… All coverage thresholds met!');
  } else {
    console.log('âŒ Some coverage thresholds not met');
    process.exit(1);
  }
} else {
  console.log('âŒ Coverage report not found');
  process.exit(1);
}
```

#### ğŸ“ˆ è¦†ç›–ç‡å¾½ç« ç”Ÿæˆ

**åˆ›å»ºscripts/generate-badges.js**ï¼š
```javascript
const { makeBadge } = require('badge-maker');
const fs = require('fs');
const path = require('path');

// è¯»å–è¦†ç›–ç‡æ•°æ®
const coveragePath = path.join(__dirname, '../coverage/coverage-summary.json');
const coverage = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));

// ç”Ÿæˆå¾½ç« 
const badges = {
  lines: makeBadge({
    label: 'Lines',
    message: `${coverage.total.lines.pct}%`,
    color: coverage.total.lines.pct >= 80 ? 'green' : 'red',
  }),
  functions: makeBadge({
    label: 'Functions',
    message: `${coverage.total.functions.pct}%`,
    color: coverage.total.functions.pct >= 80 ? 'green' : 'red',
  }),
  branches: makeBadge({
    label: 'Branches',
    message: `${coverage.total.branches.pct}%`,
    color: coverage.total.branches.pct >= 80 ? 'green' : 'red',
  }),
  statements: makeBadge({
    label: 'Statements',
    message: `${coverage.total.statements.pct}%`,
    color: coverage.total.statements.pct >= 80 ? 'green' : 'red',
  }),
};

// ä¿å­˜å¾½ç« 
const badgesDir = path.join(__dirname, '../badges');
if (!fs.existsSync(badgesDir)) {
  fs.mkdirSync(badgesDir);
}

Object.entries(badges).forEach(([name, svg]) => {
  fs.writeFileSync(path.join(badgesDir, `${name}.svg`), svg);
});

console.log('âœ… Coverage badges generated!');
```

---

## 9.9.4 è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

### ğŸš€ GitHub Actionsé…ç½®

#### ğŸ“‹ CI/CDå·¥ä½œæµ

**åˆ›å»º.github/workflows/test.yml**ï¼š
```yaml
name: Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root123
          MYSQL_DATABASE: blog_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run unit tests
      run: npm run test:cov
      env:
        NODE_ENV: test
        DB_HOST: localhost
        DB_PORT: 3306
        DB_USERNAME: root
        DB_PASSWORD: root123
        DB_DATABASE: blog_test
        REDIS_HOST: localhost
        REDIS_PORT: 6379

    - name: Run e2e tests
      run: npm run test:e2e
      env:
        NODE_ENV: test
        DB_HOST: localhost
        DB_PORT: 3306
        DB_USERNAME: root
        DB_PASSWORD: root123
        DB_DATABASE: blog_test
        REDIS_HOST: localhost
        REDIS_PORT: 6379

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

    - name: Generate coverage badges
      run: npm run generate-badges

    - name: Upload coverage badges
      uses: actions/upload-artifact@v3
      with:
        name: coverage-badges
        path: badges/
```

#### ğŸ”„ é¢„æäº¤é’©å­

**åˆ›å»º.husky/pre-commit**ï¼š
```bash
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# è¿è¡Œä»£ç æ£€æŸ¥
npm run lint

# è¿è¡Œå•å…ƒæµ‹è¯•
npm run test

# æ£€æŸ¥æµ‹è¯•è¦†ç›–ç‡
npm run test:cov -- --passWithNoTests

echo "âœ… Pre-commit checks passed!"
```

#### ğŸ“Š æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ

**åˆ›å»ºscripts/test-report.js**ï¼š
```javascript
const fs = require('fs');
const path = require('path');

// ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
function generateTestReport() {
  const coveragePath = path.join(__dirname, '../coverage/coverage-summary.json');
  const testResultsPath = path.join(__dirname, '../test-results.json');
  
  let report = {
    timestamp: new Date().toISOString(),
    coverage: null,
    testResults: null,
  };

  // è¯»å–è¦†ç›–ç‡æ•°æ®
  if (fs.existsSync(coveragePath)) {
    report.coverage = JSON.parse(fs.readFileSync(coveragePath, 'utf8'));
  }

  // è¯»å–æµ‹è¯•ç»“æœ
  if (fs.existsSync(testResultsPath)) {
    report.testResults = JSON.parse(fs.readFileSync(testResultsPath, 'utf8'));
  }

  // ç”ŸæˆHTMLæŠ¥å‘Š
  const htmlReport = `
<!DOCTYPE html>
<html>
<head>
    <title>Test Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .metric { display: inline-block; margin: 10px; padding: 10px; border-radius: 5px; }
        .good { background-color: #d4edda; color: #155724; }
        .bad { background-color: #f8d7da; color: #721c24; }
        .coverage-table { border-collapse: collapse; width: 100%; }
        .coverage-table th, .coverage-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .coverage-table th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>Test Report</h1>
    <p>Generated: ${report.timestamp}</p>
    
    ${report.coverage ? `
    <h2>Coverage Summary</h2>
    <div class="metric ${report.coverage.total.lines.pct >= 80 ? 'good' : 'bad'}">
        Lines: ${report.coverage.total.lines.pct}%
    </div>
    <div class="metric ${report.coverage.total.functions.pct >= 80 ? 'good' : 'bad'}">
        Functions: ${report.coverage.total.functions.pct}%
    </div>
    <div class="metric ${report.coverage.total.branches.pct >= 80 ? 'good' : 'bad'}">
        Branches: ${report.coverage.total.branches.pct}%
    </div>
    <div class="metric ${report.coverage.total.statements.pct >= 80 ? 'good' : 'bad'}">
        Statements: ${report.coverage.total.statements.pct}%
    </div>
    ` : '<p>No coverage data available</p>'}
    
    <h2>Coverage Details</h2>
    <p><a href="coverage/lcov-report/index.html">View detailed coverage report</a></p>
</body>
</html>
  `;

  // ä¿å­˜æŠ¥å‘Š
  fs.writeFileSync(path.join(__dirname, '../test-report.html'), htmlReport);
  fs.writeFileSync(path.join(__dirname, '../test-report.json'), JSON.stringify(report, null, 2));

  console.log('âœ… Test report generated!');
}

generateTestReport();
```

---

## ğŸ“Š æœ¬èŠ‚æ€»ç»“

### ğŸ¯ å…³é”®è¦ç‚¹å›é¡¾

1. **å•å…ƒæµ‹è¯•è¦å…¨é¢è¦†ç›–**
   - æµ‹è¯•æ‰€æœ‰ä¸šåŠ¡é€»è¾‘
   - æ¨¡æ‹Ÿå¤–éƒ¨ä¾èµ–
   - éªŒè¯å¼‚å¸¸æƒ…å†µ

2. **é›†æˆæµ‹è¯•è¦çœŸå®å¯é **
   - æµ‹è¯•APIæ¥å£
   - éªŒè¯æ•°æ®åº“æ“ä½œ
   - æ¨¡æ‹ŸçœŸå®ç”¨æˆ·åœºæ™¯

3. **æµ‹è¯•è¦†ç›–ç‡è¦è¾¾æ ‡**
   - è®¾ç½®åˆç†çš„è¦†ç›–ç‡é˜ˆå€¼
   - ç”Ÿæˆè¯¦ç»†çš„è¦†ç›–ç‡æŠ¥å‘Š
   - æŒç»­ç›‘æ§è¦†ç›–ç‡å˜åŒ–

4. **è‡ªåŠ¨åŒ–æµç¨‹è¦å®Œå–„**
   - CI/CDé›†æˆæµ‹è¯•
   - é¢„æäº¤é’©å­æ£€æŸ¥
   - è‡ªåŠ¨ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š

### ğŸ“ å®è·µç»ƒä¹ 

#### ç»ƒä¹ 1ï¼šå®Œæ•´æµ‹è¯•å¥—ä»¶
**ä»»åŠ¡**ï¼šä¸ºæ‰€æœ‰æ¨¡å—ç¼–å†™æµ‹è¯•
**è¦æ±‚**ï¼š
- ç¼–å†™å•å…ƒæµ‹è¯•ç”¨ä¾‹
- å®ç°é›†æˆæµ‹è¯•
- è¾¾åˆ°80%ä»¥ä¸Šè¦†ç›–ç‡
- é…ç½®è‡ªåŠ¨åŒ–æµ‹è¯•

#### ç»ƒä¹ 2ï¼šæµ‹è¯•ä¼˜åŒ–
**ä»»åŠ¡**ï¼šä¼˜åŒ–æµ‹è¯•æ€§èƒ½å’Œè´¨é‡
**è¦æ±‚**ï¼š
- ä¼˜åŒ–æµ‹è¯•æ‰§è¡Œé€Ÿåº¦
- æé«˜æµ‹è¯•è¦†ç›–ç‡
- æ”¹è¿›æµ‹è¯•æŠ¥å‘Š
- å®Œå–„CI/CDæµç¨‹

### ğŸ” è‡ªæˆ‘æ£€æµ‹

- [ ] æˆ‘èƒ½å¤Ÿç¼–å†™é«˜è´¨é‡çš„å•å…ƒæµ‹è¯•
- [ ] æˆ‘ç†è§£é›†æˆæµ‹è¯•çš„è®¾è®¡åŸåˆ™
- [ ] æˆ‘æŒæ¡äº†æµ‹è¯•è¦†ç›–ç‡åˆ†ææ–¹æ³•
- [ ] æˆ‘äº†è§£è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹çš„é…ç½®

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ 

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… å•å…ƒæµ‹è¯•ç¼–å†™
- âœ… é›†æˆæµ‹è¯•è®¾è®¡
- âœ… æµ‹è¯•è¦†ç›–ç‡åˆ†æ
- âœ… è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

**å‡†å¤‡å¥½è¿›å…¥ç¬¬9.10èŠ‚äº†å—ï¼Ÿ** ğŸš€

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ éƒ¨ç½²ä¸è¿ç»´ï¼ŒåŒ…æ‹¬ï¼š
- ğŸ³ Dockerå®¹å™¨åŒ–éƒ¨ç½²
- â˜ï¸ äº‘æœåŠ¡å™¨éƒ¨ç½²é…ç½®
- ğŸ“Š ç›‘æ§å’Œæ—¥å¿—ç®¡ç†
- ğŸ”„ CI/CDè‡ªåŠ¨åŒ–éƒ¨ç½² 