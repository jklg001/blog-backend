# 依赖注入原理

> 从前端的手动依赖管理到后端的自动依赖注入

## 🤔 什么是依赖注入？

### 前端的依赖管理问题

在前端开发中，你可能遇到过这样的情况：

```tsx
// ❌ 问题代码：组件直接创建依赖
function UserProfile({ userId }) {
  const apiClient = new ApiClient();  // 硬编码依赖
  const userService = new UserService(apiClient);
  
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    userService.getUser(userId).then(setUser);
  }, [userId]);
  
  return <div>{user?.name}</div>;
}
```

**问题**：
- ❌ 难以测试（无法Mock ApiClient）
- ❌ 配置混乱（每个组件都要配置）
- ❌ 耦合度高（组件知道太多实现细节）
- ❌ 难以替换（比如要换成不同的API）

### 前端的解决方案：Context + Provider

```tsx
// ✅ 前端的依赖注入方案
const ServicesContext = createContext();

function ServicesProvider({ children }) {
  const apiClient = new ApiClient();
  const userService = new UserService(apiClient);
  
  return (
    <ServicesContext.Provider value={{ userService }}>
      {children}
    </ServicesContext.Provider>
  );
}

function UserProfile({ userId }) {
  const { userService } = useContext(ServicesContext);  // 注入依赖
  
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    userService.getUser(userId).then(setUser);
  }, [userId]);
  
  return <div>{user?.name}</div>;
}
```

### 后端的自动依赖注入

```typescript
// ✅ NestJS的自动依赖注入
@Controller('users')
export class UserController {
  constructor(
    private userService: UserService  // 自动注入，无需手动创建
  ) {}
  
  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.userService.findOne(+id);
  }
}
```

## 🔍 深入理解依赖注入

### 1. 控制反转 (IoC) 原理

**传统方式**：对象主动创建依赖
```typescript
class ArticleService {
  constructor() {
    this.userService = new UserService();  // 主动创建
    this.emailService = new EmailService(); // 主动创建
  }
}
```

**依赖注入**：外部容器提供依赖
```typescript
@Injectable()
export class ArticleService {
  constructor(
    private userService: UserService,     // 被动接收
    private emailService: EmailService,  // 被动接收
  ) {}
}
```

**对比前端状态管理**：

| 方式 | 传统组件 | Context方式 | 后端DI |
|------|---------|------------|--------|
| 依赖来源 | 组件内创建 | Context提供 | 容器注入 |
| 控制权 | 组件控制 | 外部控制 | 框架控制 |
| 测试性 | 难测试 | 可Mock | 易Mock |

### 2. 依赖注入容器

**前端的"容器"概念**：
```tsx
// React的Provider就像一个容器
function App() {
  return (
    <UserProvider>      {/* 用户服务容器 */}
      <ThemeProvider>   {/* 主题服务容器 */}
        <ApiProvider>   {/* API服务容器 */}
          <Routes />
        </ApiProvider>
      </ThemeProvider>
    </UserProvider>
  );
}
```

**后端的DI容器**：
```typescript
// NestJS自动构建依赖图
@Module({
  providers: [
    UserService,           // 注册到容器
    EmailService,          // 注册到容器
    ArticleService,        // 依赖上面两个服务
  ],
})
export class AppModule {}

// 框架自动解析依赖关系：
// ArticleService → UserService + EmailService
```

## 🏗️ NestJS的依赖注入系统

### 1. Provider 的类型

#### 类提供者（最常用）
```typescript
@Module({
  providers: [UserService],  // 简写
  // 等价于：
  providers: [
    {
      provide: UserService,
      useClass: UserService,
    }
  ],
})
```

#### 值提供者
```typescript
const CONFIG = {
  database: {
    host: 'localhost',
    port: 3306,
  }
};

@Module({
  providers: [
    {
      provide: 'CONFIG',
      useValue: CONFIG,
    }
  ],
})

// 使用：
@Injectable()
export class UserService {
  constructor(
    @Inject('CONFIG') private config: any
  ) {}
}
```

**前端对比**：
```tsx
// 前端的环境变量注入
const ConfigContext = createContext();

function ConfigProvider({ children }) {
  const config = {
    apiUrl: process.env.REACT_APP_API_URL,
    version: process.env.REACT_APP_VERSION,
  };
  
  return (
    <ConfigContext.Provider value={config}>
      {children}
    </ConfigContext.Provider>
  );
}
```

#### 工厂提供者
```typescript
@Module({
  providers: [
    {
      provide: 'LOGGER',
      useFactory: (config: ConfigService) => {
        return new Logger(config.get('LOG_LEVEL'));
      },
      inject: [ConfigService],  // 工厂函数的依赖
    }
  ],
})
```

**前端对比**：
```tsx
// 前端的工厂模式
function createApiClient(config) {
  return new ApiClient({
    baseURL: config.apiUrl,
    timeout: config.timeout,
  });
}

function ApiProvider({ children }) {
  const config = useContext(ConfigContext);
  const apiClient = useMemo(() => createApiClient(config), [config]);
  
  return (
    <ApiContext.Provider value={apiClient}>
      {children}
    </ApiContext.Provider>
  );
}
```

### 2. 作用域 (Scope)

#### 单例模式（默认）
```typescript
@Injectable()  // 默认是单例
export class UserService {
  private cache = new Map();  // 缓存会在整个应用中共享
}
```

**前端对比**：
```tsx
// 全局状态（单例）
const GlobalStore = createStore();

function App() {
  return (
    <Provider store={GlobalStore}>  {/* 整个应用共享一个store */}
      <Routes />
    </Provider>
  );
}
```

#### 请求作用域
```typescript
@Injectable({ scope: Scope.REQUEST })
export class RequestService {
  private requestId = Math.random();  // 每个请求都有独立的实例
}
```

**前端对比**：
```tsx
// 每个页面组件有独立状态
function UserPage() {
  const [localState, setLocalState] = useState({});  // 每次渲染都是新的
  
  return <div>...</div>;
}
```

## 🔧 实战：我们项目中的依赖注入

### 文章服务的依赖注入

```typescript
// src/article/article.service.ts
@Injectable()
export class ArticleService {
  constructor(
    @InjectRepository(Article)           // 注入文章仓库
    private articleRepository: Repository<Article>,
    
    @InjectRepository(User)              // 注入用户仓库
    private userRepository: Repository<User>,
  ) {}
  
  async create(createArticleDto: CreateArticleDto, userId: number) {
    // 验证用户是否存在
    const user = await this.userRepository.findOne({ where: { id: userId } });
    if (!user) {
      throw new BadRequestException(`用户ID ${userId} 不存在`);
    }
    
    // 创建文章逻辑...
  }
}
```

**依赖流程**：
1. **注册阶段**：ArticleModule 注册 ArticleService
2. **解析阶段**：框架发现 ArticleService 需要两个 Repository
3. **创建阶段**：框架自动创建 Repository 实例并注入
4. **使用阶段**：ArticleController 获得配置好的 ArticleService

### 模块间的依赖注入

```typescript
// src/article/article.module.ts
@Module({
  imports: [
    TypeOrmModule.forFeature([Article, User])  // 导入需要的实体
  ],
  controllers: [ArticleController],
  providers: [ArticleService],
  exports: [ArticleService],                   // 导出给其他模块使用
})
export class ArticleModule {}
```

**类比前端模块**：
```tsx
// 前端的模块导出
export { UserService } from './UserService';
export { useUser } from './hooks/useUser';
export { UserContext } from './UserContext';

// 其他模块导入
import { UserService } from '@/modules/user';
```

## 🧪 测试中的依赖注入

### 前端测试的 Mock

```tsx
// 前端测试
const mockUserService = {
  getUser: jest.fn().mockResolvedValue({ id: 1, name: 'Test User' }),
};

render(
  <ServicesContext.Provider value={{ userService: mockUserService }}>
    <UserProfile userId={1} />
  </ServicesContext.Provider>
);
```

### 后端测试的 Mock

```typescript
// 后端测试
describe('ArticleService', () => {
  let service: ArticleService;
  let mockUserRepository: Repository<User>;
  
  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        ArticleService,
        {
          provide: getRepositoryToken(User),
          useValue: {
            findOne: jest.fn(),  // Mock 方法
          },
        },
      ],
    }).compile();
    
    service = module.get<ArticleService>(ArticleService);
    mockUserRepository = module.get(getRepositoryToken(User));
  });
  
  it('should validate user exists', async () => {
    mockUserRepository.findOne.mockResolvedValue(null);
    
    await expect(
      service.create(createArticleDto, 999)
    ).rejects.toThrow('用户ID 999 不存在');
  });
});
```

## 🌟 依赖注入的优势

### 1. 松耦合
```typescript
// ❌ 紧耦合
class ArticleService {
  constructor() {
    this.emailService = new EmailService();  // 直接依赖具体实现
  }
}

// ✅ 松耦合
class ArticleService {
  constructor(
    private emailService: EmailService  // 依赖接口，可以替换实现
  ) {}
}
```

### 2. 易测试
```typescript
// 测试时可以轻松替换依赖
const mockEmailService = {
  send: jest.fn(),
};

const articleService = new ArticleService(mockEmailService);
```

### 3. 配置集中
```typescript
// 所有依赖配置都在Module中
@Module({
  providers: [
    ArticleService,
    EmailService,
    {
      provide: 'CONFIG',
      useValue: config,
    }
  ],
})
```

## 🎓 学习要点总结

1. **依赖注入 = 自动化的Context**：框架帮你管理依赖的创建和注入
2. **控制反转**：从"我要什么我自己创建"变成"我需要什么外部给我"
3. **Provider = 服务工厂**：告诉框架如何创建和配置服务
4. **作用域控制**：类似前端的状态作用域，控制实例的生命周期
5. **测试友好**：可以轻松替换任何依赖进行单元测试

## 🔗 与前端概念对应

| 后端DI概念 | 前端对应 | 说明 |
|-----------|---------|------|
| @Injectable() | useContext Hook | 声明可被注入 |
| Provider | Context Provider | 提供依赖 |
| @Inject() | useContext() | 获取依赖 |
| Module | Provider组合 | 组织依赖关系 |
| Scope | State作用域 | 控制生命周期 |

理解了依赖注入，你就掌握了现代后端框架的核心设计哲学！ 