# 📚 第7章：项目架构与最佳实践（补充内容）

> 本文档是第7章的补充内容，包含日志监控、性能优化、工程化工具链和质量保证体系

## 📊 日志监控系统

### 📝 结构化日志设计

```typescript
// 日志级别定义
export enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug',
  VERBOSE = 'verbose'
}

// 日志上下文接口
export interface LogContext {
  requestId?: string;
  userId?: string;
  sessionId?: string;
  ip?: string;
  userAgent?: string;
  method?: string;
  url?: string;
  statusCode?: number;
  responseTime?: number;
  module?: string;
  action?: string;
  metadata?: Record<string, any>;
}

// 结构化日志服务
@Injectable()
export class StructuredLogger {
  private readonly logger = new Logger(StructuredLogger.name);

  log(level: LogLevel, message: string, context?: LogContext): void {
    const logEntry = this.createLogEntry(level, message, context);
    
    switch (level) {
      case LogLevel.ERROR:
        this.logger.error(logEntry);
        break;
      case LogLevel.WARN:
        this.logger.warn(logEntry);
        break;
      case LogLevel.INFO:
        this.logger.log(logEntry);
        break;
      case LogLevel.DEBUG:
        this.logger.debug(logEntry);
        break;
      case LogLevel.VERBOSE:
        this.logger.verbose(logEntry);
        break;
    }
  }

  error(message: string, error?: Error, context?: LogContext): void {
    const logEntry = this.createLogEntry(LogLevel.ERROR, message, {
      ...context,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined
    });
    
    this.logger.error(logEntry);
  }

  warn(message: string, context?: LogContext): void {
    this.log(LogLevel.WARN, message, context);
  }

  info(message: string, context?: LogContext): void {
    this.log(LogLevel.INFO, message, context);
  }

  debug(message: string, context?: LogContext): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  private createLogEntry(level: LogLevel, message: string, context?: LogContext): any {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...context,
      environment: process.env.NODE_ENV,
      service: 'blog-api',
      version: process.env.APP_VERSION || '1.0.0'
    };
  }
}

// 请求日志拦截器
@Injectable()
export class RequestLoggingInterceptor implements NestInterceptor {
  constructor(private readonly logger: StructuredLogger) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    const startTime = Date.now();

    const requestId = request.headers['x-request-id'] || this.generateRequestId();
    request.requestId = requestId;

    // 记录请求开始
    this.logger.info('请求开始', {
      requestId,
      method: request.method,
      url: request.url,
      ip: request.ip,
      userAgent: request.headers['user-agent'],
      userId: request.user?.id,
      body: this.sanitizeBody(request.body)
    });

    return next.handle().pipe(
      tap({
        next: (data) => {
          const responseTime = Date.now() - startTime;
          
          // 记录请求成功
          this.logger.info('请求成功', {
            requestId,
            method: request.method,
            url: request.url,
            statusCode: response.statusCode,
            responseTime,
            userId: request.user?.id
          });
        },
        error: (error) => {
          const responseTime = Date.now() - startTime;
          
          // 记录请求错误
          this.logger.error('请求失败', error, {
            requestId,
            method: request.method,
            url: request.url,
            statusCode: response.statusCode,
            responseTime,
            userId: request.user?.id
          });
        }
      })
    );
  }

  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private sanitizeBody(body: any): any {
    if (!body) return body;

    const sanitized = { ...body };
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'authorization'];
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    });

    return sanitized;
  }
}

// 业务日志装饰器
export function LogBusinessAction(action: string, module?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const logger = new StructuredLogger();
      const startTime = Date.now();

      try {
        logger.info(`${action} 开始`, {
          module: module || target.constructor.name,
          action,
          args: args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg)
        });

        const result = await originalMethod.apply(this, args);
        const duration = Date.now() - startTime;

        logger.info(`${action} 成功`, {
          module: module || target.constructor.name,
          action,
          duration
        });

        return result;
      } catch (error) {
        const duration = Date.now() - startTime;

        logger.error(`${action} 失败`, error, {
          module: module || target.constructor.name,
          action,
          duration
        });

        throw error;
      }
    };
  };
}

// 使用示例
@Injectable()
export class UserService {
  constructor(private readonly logger: StructuredLogger) {}

  @LogBusinessAction('创建用户', 'UserService')
  async createUser(createUserDto: CreateUserDto): Promise<UserResponseDto> {
    // 业务逻辑
    const user = await this.userRepository.create(createUserDto);
    
    this.logger.info('用户创建成功', {
      userId: user.id,
      username: user.username,
      action: 'user_created'
    });

    return this.transformToResponseDto(user);
  }
}
```

### 📈 性能监控

```typescript
// 性能监控服务
@Injectable()
export class PerformanceMonitoringService {
  private readonly metrics = new Map<string, PerformanceMetric>();

  // 记录性能指标
  recordMetric(name: string, value: number, tags?: Record<string, string>): void {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now(),
      tags: tags || {}
    };

    this.metrics.set(`${name}_${Date.now()}`, metric);
    
    // 发送到监控系统（如Prometheus、DataDog等）
    this.sendToMonitoringSystem(metric);
  }

  // 记录响应时间
  recordResponseTime(endpoint: string, method: string, duration: number, statusCode: number): void {
    this.recordMetric('http_request_duration_ms', duration, {
      endpoint,
      method,
      status_code: statusCode.toString()
    });
  }

  // 记录数据库查询时间
  recordDatabaseQueryTime(query: string, duration: number): void {
    this.recordMetric('database_query_duration_ms', duration, {
      query_type: this.extractQueryType(query)
    });
  }

  // 记录内存使用情况
  recordMemoryUsage(): void {
    const memoryUsage = process.memoryUsage();
    
    this.recordMetric('memory_heap_used_bytes', memoryUsage.heapUsed);
    this.recordMetric('memory_heap_total_bytes', memoryUsage.heapTotal);
    this.recordMetric('memory_external_bytes', memoryUsage.external);
    this.recordMetric('memory_rss_bytes', memoryUsage.rss);
  }

  // 记录CPU使用情况
  recordCpuUsage(): void {
    const cpuUsage = process.cpuUsage();
    
    this.recordMetric('cpu_user_microseconds', cpuUsage.user);
    this.recordMetric('cpu_system_microseconds', cpuUsage.system);
  }

  private extractQueryType(query: string): string {
    const normalizedQuery = query.trim().toLowerCase();
    
    if (normalizedQuery.startsWith('select')) return 'select';
    if (normalizedQuery.startsWith('insert')) return 'insert';
    if (normalizedQuery.startsWith('update')) return 'update';
    if (normalizedQuery.startsWith('delete')) return 'delete';
    
    return 'other';
  }

  private sendToMonitoringSystem(metric: PerformanceMetric): void {
    // 实现发送到监控系统的逻辑
    // 例如：Prometheus、DataDog、CloudWatch等
    console.log('Metric:', metric);
  }
}

interface PerformanceMetric {
  name: string;
  value: number;
  timestamp: number;
  tags: Record<string, string>;
}

// 性能监控拦截器
@Injectable()
export class PerformanceInterceptor implements NestInterceptor {
  constructor(
    private readonly performanceMonitoring: PerformanceMonitoringService,
    private readonly logger: StructuredLogger
  ) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    const startTime = Date.now();

    return next.handle().pipe(
      tap({
        next: () => {
          const duration = Date.now() - startTime;
          
          this.performanceMonitoring.recordResponseTime(
            request.route?.path || request.url,
            request.method,
            duration,
            response.statusCode
          );

          // 记录慢请求
          if (duration > 1000) { // 超过1秒的请求
            this.logger.warn('慢请求检测', {
              method: request.method,
              url: request.url,
              duration,
              statusCode: response.statusCode
            });
          }
        },
        error: () => {
          const duration = Date.now() - startTime;
          
          this.performanceMonitoring.recordResponseTime(
            request.route?.path || request.url,
            request.method,
            duration,
            response.statusCode
          );
        }
      })
    );
  }
}

// 数据库性能监控
@Injectable()
export class DatabasePerformanceInterceptor {
  constructor(private readonly performanceMonitoring: PerformanceMonitoringService) {}

  intercept(query: string, parameters?: any[]): any {
    const startTime = Date.now();

    return {
      afterQuery: () => {
        const duration = Date.now() - startTime;
        this.performanceMonitoring.recordDatabaseQueryTime(query, duration);
      }
    };
  }
}
```

## ⚡ 性能优化策略

### 🗄️ 缓存策略实现

```typescript
// 多层缓存服务
@Injectable()
export class MultiLevelCacheService {
  private readonly memoryCache = new Map<string, CacheItem>();
  private readonly maxMemoryCacheSize = 1000;

  constructor(
    @Inject('REDIS_CLIENT') private readonly redisClient: Redis,
    private readonly logger: StructuredLogger
  ) {
    // 定期清理内存缓存
    setInterval(() => this.cleanupMemoryCache(), 60000); // 每分钟清理一次
  }

  // 获取缓存
  async get<T>(key: string): Promise<T | null> {
    try {
      // 1. 先从内存缓存获取
      const memoryItem = this.memoryCache.get(key);
      if (memoryItem && !this.isExpired(memoryItem)) {
        this.logger.debug('从内存缓存命中', { key });
        return memoryItem.value as T;
      }

      // 2. 从Redis获取
      const redisValue = await this.redisClient.get(key);
      if (redisValue) {
        const value = JSON.parse(redisValue);
        
        // 回写到内存缓存
        this.setMemoryCache(key, value, 300); // 5分钟内存缓存
        
        this.logger.debug('从Redis缓存命中', { key });
        return value as T;
      }

      this.logger.debug('缓存未命中', { key });
      return null;
    } catch (error) {
      this.logger.error('缓存获取失败', error, { key });
      return null;
    }
  }

  // 设置缓存
  async set<T>(key: string, value: T, ttl: number = 3600): Promise<void> {
    try {
      // 1. 设置Redis缓存
      await this.redisClient.setex(key, ttl, JSON.stringify(value));
      
      // 2. 设置内存缓存（较短的TTL）
      const memoryTtl = Math.min(ttl, 300); // 最多5分钟内存缓存
      this.setMemoryCache(key, value, memoryTtl);
      
      this.logger.debug('缓存设置成功', { key, ttl });
    } catch (error) {
      this.logger.error('缓存设置失败', error, { key });
    }
  }

  // 删除缓存
  async del(key: string): Promise<void> {
    try {
      // 1. 删除内存缓存
      this.memoryCache.delete(key);
      
      // 2. 删除Redis缓存
      await this.redisClient.del(key);
      
      this.logger.debug('缓存删除成功', { key });
    } catch (error) {
      this.logger.error('缓存删除失败', error, { key });
    }
  }

  // 批量删除缓存（支持通配符）
  async delPattern(pattern: string): Promise<void> {
    try {
      // 1. 清理内存缓存
      for (const key of this.memoryCache.keys()) {
        if (this.matchPattern(key, pattern)) {
          this.memoryCache.delete(key);
        }
      }

      // 2. 清理Redis缓存
      const keys = await this.redisClient.keys(pattern);
      if (keys.length > 0) {
        await this.redisClient.del(...keys);
      }
      
      this.logger.debug('批量缓存删除成功', { pattern, count: keys.length });
    } catch (error) {
      this.logger.error('批量缓存删除失败', error, { pattern });
    }
  }

  private setMemoryCache<T>(key: string, value: T, ttl: number): void {
    // 检查内存缓存大小限制
    if (this.memoryCache.size >= this.maxMemoryCacheSize) {
      // 删除最旧的缓存项
      const oldestKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(oldestKey);
    }

    this.memoryCache.set(key, {
      value,
      expiredAt: Date.now() + ttl * 1000
    });
  }

  private isExpired(item: CacheItem): boolean {
    return Date.now() > item.expiredAt;
  }

  private cleanupMemoryCache(): void {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [key, item] of this.memoryCache.entries()) {
      if (now > item.expiredAt) {
        this.memoryCache.delete(key);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      this.logger.debug('内存缓存清理完成', { cleanedCount });
    }
  }

  private matchPattern(key: string, pattern: string): boolean {
    // 简单的通配符匹配实现
    const regex = new RegExp(pattern.replace(/\*/g, '.*'));
    return regex.test(key);
  }
}

interface CacheItem {
  value: any;
  expiredAt: number;
}

// 缓存装饰器
export function Cacheable(options: CacheOptions = {}) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const cacheService = this.cacheService || new MultiLevelCacheService();
      const cacheKey = options.keyGenerator 
        ? options.keyGenerator(target.constructor.name, propertyName, args)
        : `${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`;

      // 尝试从缓存获取
      const cached = await cacheService.get(cacheKey);
      if (cached !== null) {
        return cached;
      }

      // 执行原方法
      const result = await originalMethod.apply(this, args);

      // 缓存结果
      if (result !== null && result !== undefined) {
        await cacheService.set(cacheKey, result, options.ttl || 3600);
      }

      return result;
    };
  };
}

interface CacheOptions {
  ttl?: number;
  keyGenerator?: (className: string, methodName: string, args: any[]) => string;
}

// 使用示例
@Injectable()
export class ArticleService {
  constructor(private readonly cacheService: MultiLevelCacheService) {}

  @Cacheable({ ttl: 600 }) // 10分钟缓存
  async findPopularArticles(limit: number = 10): Promise<ArticleResponseDto[]> {
    return this.articleRepository.findPopularArticles(limit);
  }

  @Cacheable({ 
    ttl: 300,
    keyGenerator: (className, methodName, args) => `${className}:${methodName}:${args[0]}`
  })
  async findArticleById(id: string): Promise<ArticleResponseDto> {
    const article = await this.articleRepository.findById(id);
    if (!article) {
      throw new ResourceNotFoundException('Article', id);
    }
    return this.transformToResponseDto(article);
  }
}
```

### 🔄 数据库优化

```typescript
// 数据库连接池优化
@Injectable()
export class DatabaseOptimizationService {
  constructor(
    @InjectDataSource() private readonly dataSource: DataSource,
    private readonly performanceMonitoring: PerformanceMonitoringService
  ) {}

  // 查询优化分析
  async analyzeQuery(query: string, parameters?: any[]): Promise<QueryAnalysis> {
    const startTime = Date.now();
    
    try {
      // 执行查询计划分析
      const explainResult = await this.dataSource.query(`EXPLAIN ANALYZE ${query}`, parameters);
      const duration = Date.now() - startTime;

      const analysis: QueryAnalysis = {
        query,
        duration,
        executionPlan: explainResult,
        recommendations: this.generateRecommendations(explainResult, duration)
      };

      // 记录慢查询
      if (duration > 1000) {
        this.performanceMonitoring.recordMetric('slow_query_detected', 1, {
          query_type: this.extractQueryType(query),
          duration: duration.toString()
        });
      }

      return analysis;
    } catch (error) {
      throw new Error(`查询分析失败: ${error.message}`);
    }
  }

  // 索引建议
  async suggestIndexes(tableName: string): Promise<IndexSuggestion[]> {
    const suggestions: IndexSuggestion[] = [];

    // 分析查询模式
    const queryPatterns = await this.analyzeQueryPatterns(tableName);
    
    for (const pattern of queryPatterns) {
      if (pattern.frequency > 10 && pattern.avgDuration > 100) {
        suggestions.push({
          tableName,
          columns: pattern.whereColumns,
          type: 'btree',
          reason: `频繁查询字段，平均耗时${pattern.avgDuration}ms`,
          priority: this.calculatePriority(pattern)
        });
      }
    }

    return suggestions;
  }

  // 连接池监控
  getConnectionPoolStats(): ConnectionPoolStats {
    const pool = this.dataSource.driver.pool;
    
    return {
      totalConnections: pool.totalCount,
      idleConnections: pool.idleCount,
      activeConnections: pool.totalCount - pool.idleCount,
      waitingClients: pool.waitingCount,
      maxConnections: pool.options.max,
      minConnections: pool.options.min
    };
  }

  // 优化建议
  getOptimizationRecommendations(): OptimizationRecommendation[] {
    const recommendations: OptimizationRecommendation[] = [];
    const poolStats = this.getConnectionPoolStats();

    // 连接池优化建议
    if (poolStats.activeConnections / poolStats.maxConnections > 0.8) {
      recommendations.push({
        type: 'connection_pool',
        priority: 'high',
        description: '连接池使用率过高，建议增加最大连接数',
        action: '调整数据库连接池配置'
      });
    }

    if (poolStats.waitingClients > 0) {
      recommendations.push({
        type: 'connection_pool',
        priority: 'critical',
        description: '存在等待连接的客户端，连接池可能不足',
        action: '立即增加连接池大小或优化查询性能'
      });
    }

    return recommendations;
  }

  private async analyzeQueryPatterns(tableName: string): Promise<QueryPattern[]> {
    // 这里应该分析实际的查询日志
    // 简化实现，返回模拟数据
    return [
      {
        whereColumns: ['user_id'],
        frequency: 50,
        avgDuration: 150
      },
      {
        whereColumns: ['created_at'],
        frequency: 30,
        avgDuration: 80
      }
    ];
  }

  private generateRecommendations(executionPlan: any[], duration: number): string[] {
    const recommendations: string[] = [];

    if (duration > 1000) {
      recommendations.push('查询耗时过长，建议优化');
    }

    // 分析执行计划
    const planText = JSON.stringify(executionPlan).toLowerCase();
    
    if (planText.includes('seq scan')) {
      recommendations.push('检测到全表扫描，建议添加索引');
    }

    if (planText.includes('nested loop')) {
      recommendations.push('检测到嵌套循环，考虑优化JOIN条件');
    }

    return recommendations;
  }

  private extractQueryType(query: string): string {
    const normalizedQuery = query.trim().toLowerCase();
    
    if (normalizedQuery.startsWith('select')) return 'select';
    if (normalizedQuery.startsWith('insert')) return 'insert';
    if (normalizedQuery.startsWith('update')) return 'update';
    if (normalizedQuery.startsWith('delete')) return 'delete';
    
    return 'other';
  }

  private calculatePriority(pattern: QueryPattern): 'low' | 'medium' | 'high' {
    const score = pattern.frequency * pattern.avgDuration;
    
    if (score > 10000) return 'high';
    if (score > 5000) return 'medium';
    return 'low';
  }
}

interface QueryAnalysis {
  query: string;
  duration: number;
  executionPlan: any[];
  recommendations: string[];
}

interface IndexSuggestion {
  tableName: string;
  columns: string[];
  type: string;
  reason: string;
  priority: 'low' | 'medium' | 'high';
}

interface ConnectionPoolStats {
  totalConnections: number;
  idleConnections: number;
  activeConnections: number;
  waitingClients: number;
  maxConnections: number;
  minConnections: number;
}

interface OptimizationRecommendation {
  type: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  action: string;
}

interface QueryPattern {
  whereColumns: string[];
  frequency: number;
  avgDuration: number;
}
```

## 🔧 工程化工具链

### 📋 代码质量工具配置

```typescript
// ESLint配置
// .eslintrc.js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    '@nestjs/eslint-config',
    '@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/prefer-readonly': 'error',
    '@typescript-eslint/prefer-readonly-parameter-types': 'off',
    'prefer-const': 'error',
    'no-var': 'error',
    'no-console': 'warn',
    'complexity': ['error', { max: 10 }],
    'max-lines-per-function': ['error', { max: 50 }],
    'max-depth': ['error', { max: 4 }],
    'max-params': ['error', { max: 4 }],
  },
};

// Prettier配置
// .prettierrc
{
  "singleQuote": true,
  "trailingComma": "all",
  "tabWidth": 2,
  "semi": true,
  "printWidth": 100,
  "endOfLine": "lf"
}

// Husky配置
// .husky/pre-commit
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npm run lint
npm run format:check
npm run test:unit

// .husky/commit-msg
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx commitlint --edit $1

// CommitLint配置
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',     // 新功能
        'fix',      // 修复bug
        'docs',     // 文档更新
        'style',    // 代码格式
        'refactor', // 重构
        'perf',     // 性能优化
        'test',     // 测试
        'chore',    // 构建过程或辅助工具的变动
        'ci',       // CI配置
        'build',    // 构建系统
        'revert',   // 回滚
      ],
    ],
    'type-case': [2, 'always', 'lower-case'],
    'type-empty': [2, 'never'],
    'scope-case': [2, 'always', 'lower-case'],
    'subject-case': [2, 'never', ['sentence-case', 'start-case', 'pascal-case', 'upper-case']],
    'subject-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],
    'header-max-length': [2, 'always', 72],
  },
};
```

### 🧪 自动化测试配置

```typescript
// Jest配置
// jest.config.js
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.spec.ts',
    '!**/*.interface.ts',
    '!**/*.dto.ts',
    '!**/*.entity.ts',
    '!**/node_modules/**',
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],
  testTimeout: 30000,
};

// 测试工具类
export class TestUtils {
  // 创建测试模块
  static async createTestingModule(metadata: ModuleMetadata): Promise<TestingModule> {
    return Test.createTestingModule(metadata).compile();
  }

  // 创建Mock仓储
  static createMockRepository<T>(): MockRepository<T> {
    return {
      find: jest.fn(),
      findOne: jest.fn(),
      findAndCount: jest.fn(),
      save: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      remove: jest.fn(),
      count: jest.fn(),
      increment: jest.fn(),
      decrement: jest.fn(),
    } as any;
  }

  // 创建Mock服务
  static createMockService<T>(methods: (keyof T)[]): Partial<T> {
    const mock: any = {};
    methods.forEach(method => {
      mock[method] = jest.fn();
    });
    return mock;
  }

  // 生成测试数据
  static generateTestUser(overrides: Partial<UserEntity> = {}): UserEntity {
    return {
      id: 'test-user-id',
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword',
      avatar: null,
      status: 'active',
      roles: ['user'],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    } as UserEntity;
  }

  static generateTestArticle(overrides: Partial<ArticleEntity> = {}): ArticleEntity {
    return {
      id: 'test-article-id',
      title: 'Test Article',
      content: 'Test content',
      summary: 'Test summary',
      slug: 'test-article',
      viewCount: 0,
      readingTime: 5,
      publishedAt: new Date(),
      author: this.generateTestUser(),
      tags: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    } as ArticleEntity;
  }

  // 等待异步操作
  static async waitFor(condition: () => boolean, timeout: number = 5000): Promise<void> {
    const startTime = Date.now();
    
    while (!condition() && Date.now() - startTime < timeout) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    if (!condition()) {
      throw new Error('等待条件超时');
    }
  }
}

type MockRepository<T> = {
  [K in keyof Repository<T>]: jest.Mock;
};

// 集成测试基类
export abstract class IntegrationTestBase {
  protected app: INestApplication;
  protected dataSource: DataSource;

  async beforeAll(): Promise<void> {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    })
      .overrideProvider(DataSource)
      .useValue(await this.createTestDataSource())
      .compile();

    this.app = moduleFixture.createNestApplication();
    this.dataSource = moduleFixture.get<DataSource>(DataSource);
    
    await this.app.init();
    await this.setupTestData();
  }

  async afterAll(): Promise<void> {
    await this.cleanupTestData();
    await this.dataSource.destroy();
    await this.app.close();
  }

  async beforeEach(): Promise<void> {
    await this.dataSource.query('BEGIN');
  }

  async afterEach(): Promise<void> {
    await this.dataSource.query('ROLLBACK');
  }

  protected abstract createTestDataSource(): Promise<DataSource>;
  protected abstract setupTestData(): Promise<void>;
  protected abstract cleanupTestData(): Promise<void>;

  protected async request(): Promise<supertest.SuperTest<supertest.Test>> {
    return supertest(this.app.getHttpServer());
  }
}

// E2E测试示例
describe('ArticleController (e2e)', () => {
  let app: INestApplication;
  let userService: UserService;
  let authService: AuthService;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    userService = moduleFixture.get<UserService>(UserService);
    authService = moduleFixture.get<AuthService>(AuthService);
    
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('/articles (GET)', () => {
    it('应该返回文章列表', async () => {
      const response = await request(app.getHttpServer())
        .get('/articles')
        .expect(200);

      expect(response.body).toHaveProperty('data');
      expect(response.body).toHaveProperty('pagination');
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('应该支持分页查询', async () => {
      const response = await request(app.getHttpServer())
        .get('/articles?page=1&limit=5')
        .expect(200);

      expect(response.body.pagination.page).toBe(1);
      expect(response.body.pagination.limit).toBe(5);
    });
  });

  describe('/articles (POST)', () => {
    let authToken: string;

    beforeEach(async () => {
      // 创建测试用户并获取认证令牌
      const user = await userService.create({
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123'
      });

      const loginResult = await authService.login({
        email: 'test@example.com',
        password: 'password123'
      });

      authToken = loginResult.accessToken;
    });

    it('应该创建新文章', async () => {
      const createArticleDto = {
        title: '测试文章',
        content: '这是一篇测试文章的内容',
        summary: '测试文章摘要',
        tags: ['测试', 'NestJS']
      };

      const response = await request(app.getHttpServer())
        .post('/articles')
        .set('Authorization', `Bearer ${authToken}`)
        .send(createArticleDto)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.title).toBe(createArticleDto.title);
      expect(response.body.content).toBe(createArticleDto.content);
    });

    it('未认证用户不能创建文章', async () => {
      const createArticleDto = {
        title: '测试文章',
        content: '这是一篇测试文章的内容'
      };

      await request(app.getHttpServer())
        .post('/articles')
        .send(createArticleDto)
        .expect(401);
    });
  });
});
```

## 🛡️ 质量保证体系

### 📊 代码质量监控

```typescript
// 代码质量分析服务
@Injectable()
export class CodeQualityService {
  private readonly metrics = new Map<string, QualityMetric>();

  // 代码复杂度分析
  analyzeComplexity(filePath: string, sourceCode: string): ComplexityAnalysis {
    const analysis: ComplexityAnalysis = {
      filePath,
      cyclomaticComplexity: this.calculateCyclomaticComplexity(sourceCode),
      cognitiveComplexity: this.calculateCognitiveComplexity(sourceCode),
      linesOfCode: this.countLinesOfCode(sourceCode),
      maintainabilityIndex: 0,
      technicalDebt: 0
    };

    // 计算可维护性指数
    analysis.maintainabilityIndex = this.calculateMaintainabilityIndex(analysis);
    
    // 计算技术债务
    analysis.technicalDebt = this.calculateTechnicalDebt(analysis);

    return analysis;
  }

  // 测试覆盖率分析
  async analyzeCoverage(coverageReport: CoverageReport): Promise<CoverageAnalysis> {
    const analysis: CoverageAnalysis = {
      overall: {
        lines: coverageReport.total.lines.pct,
        functions: coverageReport.total.functions.pct,
        branches: coverageReport.total.branches.pct,
        statements: coverageReport.total.statements.pct
      },
      files: [],
      recommendations: []
    };

    // 分析每个文件的覆盖率
    for (const [filePath, fileData] of Object.entries(coverageReport.files)) {
      const fileAnalysis: FileCoverageAnalysis = {
        filePath,
        lines: fileData.lines.pct,
        functions: fileData.functions.pct,
        branches: fileData.branches.pct,
        statements: fileData.statements.pct,
        uncoveredLines: fileData.lines.uncovered
      };

      analysis.files.push(fileAnalysis);

      // 生成改进建议
      if (fileAnalysis.lines < 80) {
        analysis.recommendations.push({
          type: 'coverage',
          priority: 'high',
          file: filePath,
          message: `行覆盖率过低 (${fileAnalysis.lines}%)，建议增加测试用例`
        });
      }
    }

    return analysis;
  }

  // 代码重复度分析
  analyzeDuplication(sourceFiles: string[]): DuplicationAnalysis {
    const duplicates: DuplicateBlock[] = [];
    const analysis: DuplicationAnalysis = {
      duplicateBlocks: duplicates,
      duplicationRatio: 0,
      recommendations: []
    };

    // 简化的重复代码检测算法
    for (let i = 0; i < sourceFiles.length; i++) {
      for (let j = i + 1; j < sourceFiles.length; j++) {
        const duplicateBlocks = this.findDuplicateBlocks(sourceFiles[i], sourceFiles[j]);
        duplicates.push(...duplicateBlocks);
      }
    }

    // 计算重复率
    const totalLines = sourceFiles.reduce((sum, file) => sum + this.countLinesOfCode(file), 0);
    const duplicateLines = duplicates.reduce((sum, block) => sum + block.lines, 0);
    analysis.duplicationRatio = (duplicateLines / totalLines) * 100;

    // 生成建议
    if (analysis.duplicationRatio > 5) {
      analysis.recommendations.push({
        type: 'duplication',
        priority: 'medium',
        message: `代码重复率过高 (${analysis.duplicationRatio.toFixed(2)}%)，建议重构重复代码`
      });
    }

    return analysis;
  }

  // 依赖分析
  analyzeDependencies(packageJson: any): DependencyAnalysis {
    const analysis: DependencyAnalysis = {
      totalDependencies: 0,
      outdatedDependencies: [],
      vulnerabilities: [],
      recommendations: []
    };

    const allDependencies = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };

    analysis.totalDependencies = Object.keys(allDependencies).length;

    // 检查过时的依赖
    for (const [name, version] of Object.entries(allDependencies)) {
      // 这里应该调用npm registry API检查最新版本
      // 简化实现
      if (this.isOutdated(name, version as string)) {
        analysis.outdatedDependencies.push({
          name,
          currentVersion: version as string,
          latestVersion: 'latest' // 实际应该从registry获取
        });
      }
    }

    // 安全漏洞检查
    analysis.vulnerabilities = this.checkVulnerabilities(allDependencies);

    return analysis;
  }

  private calculateCyclomaticComplexity(sourceCode: string): number {
    // 简化的圈复杂度计算
    const complexityKeywords = ['if', 'else', 'while', 'for', 'switch', 'case', 'catch', '&&', '||', '?'];
    let complexity = 1; // 基础复杂度

    for (const keyword of complexityKeywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, 'g');
      const matches = sourceCode.match(regex);
      if (matches) {
        complexity += matches.length;
      }
    }

    return complexity;
  }

  private calculateCognitiveComplexity(sourceCode: string): number {
    // 简化的认知复杂度计算
    // 实际实现需要更复杂的AST分析
    return this.calculateCyclomaticComplexity(sourceCode) * 0.8;
  }

  private countLinesOfCode(sourceCode: string): number {
    return sourceCode.split('\n').filter(line => line.trim().length > 0).length;
  }

  private calculateMaintainabilityIndex(analysis: ComplexityAnalysis): number {
    // 可维护性指数计算公式
    const volume = analysis.linesOfCode * Math.log2(analysis.linesOfCode);
    const complexity = analysis.cyclomaticComplexity;
    
    return Math.max(0, (171 - 5.2 * Math.log(volume) - 0.23 * complexity - 16.2 * Math.log(analysis.linesOfCode)) * 100 / 171);
  }

  private calculateTechnicalDebt(analysis: ComplexityAnalysis): number {
    // 技术债务估算（以小时为单位）
    let debt = 0;

    if (analysis.cyclomaticComplexity > 10) {
      debt += (analysis.cyclomaticComplexity - 10) * 0.5;
    }

    if (analysis.maintainabilityIndex < 70) {
      debt += (70 - analysis.maintainabilityIndex) * 0.1;
    }

    return debt;
  }

  private findDuplicateBlocks(file1: string, file2: string): DuplicateBlock[] {
    // 简化的重复代码检测
    const blocks: DuplicateBlock[] = [];
    const lines1 = file1.split('\n');
    const lines2 = file2.split('\n');

    // 查找连续的相同行
    for (let i = 0; i < lines1.length - 5; i++) {
      for (let j = 0; j < lines2.length - 5; j++) {
        let matchLength = 0;
        while (
          i + matchLength < lines1.length &&
          j + matchLength < lines2.length &&
          lines1[i + matchLength].trim() === lines2[j + matchLength].trim() &&
          lines1[i + matchLength].trim().length > 0
        ) {
          matchLength++;
        }

        if (matchLength >= 6) { // 至少6行重复
          blocks.push({
            file1: 'file1',
            file2: 'file2',
            startLine1: i + 1,
            startLine2: j + 1,
            lines: matchLength
          });
        }
      }
    }

    return blocks;
  }

  private isOutdated(name: string, version: string): boolean {
    // 简化实现，实际应该调用npm registry API
    return Math.random() > 0.8; // 20%的概率认为是过时的
  }

  private checkVulnerabilities(dependencies: Record<string, string>): SecurityVulnerability[] {
    // 简化实现，实际应该调用安全数据库API
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const [name, version] of Object.entries(dependencies)) {
      if (Math.random() > 0.95) { // 5%的概率有漏洞
        vulnerabilities.push({
          package: name,
          version,
          severity: 'medium',
          description: `${name} 存在安全漏洞`,
          recommendation: `升级到最新版本`
        });
      }
    }

    return vulnerabilities;
  }
}

// 接口定义
interface ComplexityAnalysis {
  filePath: string;
  cyclomaticComplexity: number;
  cognitiveComplexity: number;
  linesOfCode: number;
  maintainabilityIndex: number;
  technicalDebt: number;
}

interface CoverageAnalysis {
  overall: {
    lines: number;
    functions: number;
    branches: number;
    statements: number;
  };
  files: FileCoverageAnalysis[];
  recommendations: QualityRecommendation[];
}

interface FileCoverageAnalysis {
  filePath: string;
  lines: number;
  functions: number;
  branches: number;
  statements: number;
  uncoveredLines: number[];
}

interface DuplicationAnalysis {
  duplicateBlocks: DuplicateBlock[];
  duplicationRatio: number;
  recommendations: QualityRecommendation[];
}

interface DuplicateBlock {
  file1: string;
  file2: string;
  startLine1: number;
  startLine2: number;
  lines: number;
}

interface DependencyAnalysis {
  totalDependencies: number;
  outdatedDependencies: OutdatedDependency[];
  vulnerabilities: SecurityVulnerability[];
  recommendations: QualityRecommendation[];
}

interface OutdatedDependency {
  name: string;
  currentVersion: string;
  latestVersion: string;
}

interface SecurityVulnerability {
  package: string;
  version: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  recommendation: string;
}

interface QualityRecommendation {
  type: string;
  priority: 'low' | 'medium' | 'high';
  file?: string;
  message: string;
}

interface QualityMetric {
  name: string;
  value: number;
  timestamp: number;
  threshold: number;
}

interface CoverageReport {
  total: {
    lines: { pct: number };
    functions: { pct: number };
    branches: { pct: number };
    statements: { pct: number };
  };
  files: Record<string, {
    lines: { pct: number; uncovered: number[] };
    functions: { pct: number };
    branches: { pct: number };
    statements: { pct: number };
  }>;
}
```

### 🔄 CI/CD流程配置

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # 代码质量检查
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint check
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: Type check
        run: npm run type-check

      - name: Security audit
        run: npm audit --audit-level moderate

  # 单元测试
  unit-tests:
    runs-on: ubuntu-latest
    needs: quality-check
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # 集成测试
  integration-tests:
    runs-on: ubuntu-latest
    needs: quality-check
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run database migrations
        run: npm run migration:run
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: test_db

      - name: Run integration tests
        run: npm run test:integration
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: test_db
          REDIS_HOST: localhost
          REDIS_PORT: 6379

  # E2E测试
  e2e-tests:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Run E2E tests
        run: npm run test:e2e
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: test_db
          REDIS_HOST: localhost
          REDIS_PORT: 6379

  # 构建Docker镜像
  build-image:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, e2e-tests]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT

  # 安全扫描
  security-scan:
    runs-on: ubuntu-latest
    needs: build-image
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-image.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # 部署到测试环境
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-image, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: staging
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying ${{ needs.build-image.outputs.image }} to staging environment"
          # 这里添加实际的部署脚本

  # 部署到生产环境
  deploy-production:
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying ${{ needs.build-image.outputs.image }} to production environment"
          # 这里添加实际的部署脚本

# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production && npm cache clean --force

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 生产镜像
FROM node:18-alpine AS production

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nestjs -u 1001

WORKDIR /app

# 复制依赖和构建产物
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/package*.json ./

# 切换到非root用户
USER nestjs

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# 启动应用
CMD ["node", "dist/main"]

# docker-compose.yml (用于本地开发)
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USERNAME=postgres
      - DB_PASSWORD=postgres
      - DB_DATABASE=blog_db
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - postgres
      - redis
    volumes:
      - .:/app
      - /app/node_modules
    command: npm run start:dev

  postgres:
    image: postgres:14
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=blog_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app

volumes:
  postgres_data:
  redis_data:
```

## 🎯 实战项目：企业级博客系统

### 📋 项目需求分析

```typescript
// 项目需求文档
export interface ProjectRequirements {
  // 功能需求
  functional: {
    userManagement: {
      registration: '用户注册功能';
      authentication: '用户认证功能';
      profile: '用户资料管理';
      roleManagement: '角色权限管理';
    };
    
    contentManagement: {
      articleCRUD: '文章增删改查';
      categoryManagement: '分类管理';
      tagManagement: '标签管理';
      commentSystem: '评论系统';
      searchFunction: '搜索功能';
    };
    
    systemFeatures: {
      fileUpload: '文件上传功能';
      emailNotification: '邮件通知';
      caching: '缓存机制';
      logging: '日志记录';
      monitoring: '系统监控';
    };
  };
  
  // 非功能需求
  nonFunctional: {
    performance: {
      responseTime: '接口响应时间 < 200ms';
      throughput: '支持1000并发用户';
      availability: '99.9%可用性';
    };
    
    security: {
      authentication: 'JWT认证机制';
      authorization: 'RBAC权限控制';
      dataEncryption: '敏感数据加密';
      inputValidation: '输入数据验证';
    };
    
    scalability: {
      horizontal: '支持水平扩展';
      database: '数据库读写分离';
      caching: '多级缓存策略';
    };
    
    maintainability: {
      codeQuality: '代码质量标准';
      documentation: '完整的文档';
      testing: '测试覆盖率 > 80%';
      monitoring: '完善的监控体系';
    };
  };
}

// 系统架构设计
export interface SystemArchitecture {
  // 分层架构
  layers: {
    presentation: {
      controllers: '控制器层';
      dto: '数据传输对象';
      guards: '守卫层';
      interceptors: '拦截器';
    };
    
    business: {
      services: '业务服务层';
      domainModels: '领域模型';
      businessRules: '业务规则';
    };
    
    data: {
      repositories: '数据访问层';
      entities: '实体模型';
      migrations: '数据库迁移';
    };
    
    infrastructure: {
      database: '数据库';
      cache: '缓存';
      messageQueue: '消息队列';
      fileStorage: '文件存储';
    };
  };
  
  // 模块设计
  modules: {
    core: '核心模块';
    auth: '认证模块';
    user: '用户模块';
    article: '文章模块';
    comment: '评论模块';
    file: '文件模块';
    notification: '通知模块';
  };
}
```

### 🏗️ 核心模块实现

```typescript
// 核心模块 - 应用启动配置
@Module({
  imports: [
    // 配置模块
    ConfigModule.forRoot({
      isGlobal: true,
      load: [appConfig, databaseConfig, redisConfig, jwtConfig],
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DB_HOST: Joi.string().required(),
        DB_PORT: Joi.number().default(5432),
        DB_USERNAME: Joi.string().required(),
        DB_PASSWORD: Joi.string().required(),
        DB_DATABASE: Joi.string().required(),
        REDIS_HOST: Joi.string().default('localhost'),
        REDIS_PORT: Joi.number().default(6379),
        JWT_SECRET: Joi.string().required(),
        JWT_EXPIRES_IN: Joi.string().default('1h'),
      }),
    }),

    // 数据库模块
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get('database.host'),
        port: configService.get('database.port'),
        username: configService.get('database.username'),
        password: configService.get('database.password'),
        database: configService.get('database.database'),
        entities: [__dirname + '/**/*.entity{.ts,.js}'],
        migrations: [__dirname + '/database/migrations/*{.ts,.js}'],
        synchronize: configService.get('NODE_ENV') === 'development',
        logging: configService.get('database.logging'),
        ssl: configService.get('database.ssl'),
        extra: {
          max: configService.get('database.maxConnections'),
          connectionTimeoutMillis: configService.get('database.acquireTimeout'),
          idleTimeoutMillis: configService.get('database.timeout'),
        },
      }),
      inject: [ConfigService],
    }),

    // Redis缓存模块
    CacheModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('redis.host'),
        port: configService.get('redis.port'),
        password: configService.get('redis.password'),
        db: configService.get('redis.db'),
        keyPrefix: configService.get('redis.keyPrefix'),
        ttl: configService.get('redis.ttl'),
      }),
      inject: [ConfigService],
      isGlobal: true,
    }),

    // 限流模块
    ThrottlerModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        ttl: configService.get('app.rateLimit.ttl'),
        limit: configService.get('app.rateLimit.limit'),
        storage: new ThrottlerStorageRedisService(
          new Redis({
            host: configService.get('redis.host'),
            port: configService.get('redis.port'),
          })
        ),
      }),
      inject: [ConfigService],
    }),

    // 事件模块
    EventEmitterModule.forRoot(),

    // 调度模块
    ScheduleModule.forRoot(),

    // 业务模块
    AuthModule,
    UserModule,
    ArticleModule,
    CommentModule,
    FileModule,
    NotificationModule,
    
    // 共享模块
    LoggerModule,
    CacheModule,
    EmailModule,
    HealthModule,
  ],
  providers: [
    // 全局提供者
    {
      provide: APP_GUARD,
      useClass: ThrottlerGuard,
    },
    {
      provide: APP_FILTER,
      useClass: GlobalExceptionFilter,
    },
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLoggingInterceptor,
    },
    {
      provide: APP_INTERCEPTOR,
      useClass: PerformanceInterceptor,
    },
    {
      provide: APP_PIPE,
      useClass: ValidationPipe,
    },
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer): void {
    // 配置中间件
    consumer
      .apply(
        helmet(), // 安全头
        compression(), // 响应压缩
        cors({
          origin: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
          credentials: true,
        }),
        morgan('combined'), // 请求日志
      )
      .forRoutes('*');

    // 请求ID中间件
    consumer
      .apply((req: Request, res: Response, next: NextFunction) => {
        req.headers['x-request-id'] = req.headers['x-request-id'] || uuidv4();
        next();
      })
      .forRoutes('*');
  }
}

// 应用启动文件
async function bootstrap(): Promise<void> {
  const app = await NestFactory.create(AppModule, {
    logger: ['error', 'warn', 'log', 'debug', 'verbose'],
  });

  const configService = app.get(ConfigService);
  const port = configService.get<number>('app.port');
  const apiPrefix = configService.get<string>('app.apiPrefix');

  // 设置API前缀
  app.setGlobalPrefix(apiPrefix);

  // Swagger文档配置
  if (process.env.NODE_ENV !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('博客系统API')
      .setDescription('企业级博客系统API文档')
      .setVersion('1.0')
      .addBearerAuth()
      .addTag('认证', '用户认证相关接口')
      .addTag('用户', '用户管理相关接口')
      .addTag('文章', '文章管理相关接口')
      .addTag('评论', '评论管理相关接口')
      .addTag('文件', '文件管理相关接口')
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup(`${apiPrefix}/docs`, app, document, {
      swaggerOptions: {
        persistAuthorization: true,
      },
    });
  }

  // 启用关闭钩子
  app.enableShutdownHooks();

  // 启动应用
  await app.listen(port);
  
  console.log(`🚀 应用已启动: http://localhost:${port}/${apiPrefix}`);
  console.log(`📚 API文档: http://localhost:${port}/${apiPrefix}/docs`);
}

bootstrap().catch((error) => {
  console.error('应用启动失败:', error);
  process.exit(1);
});
```

## 📋 最佳实践总结

### ✅ 开发最佳实践清单

```typescript
// 开发最佳实践检查清单
export interface BestPracticesChecklist {
  // 代码质量
  codeQuality: {
    ✅: '使用有意义的变量和函数名';
    ✅: '遵循一致的命名约定';
    ✅: '避免使用缩写和简写';
  };
  
  // 架构设计
  architecture: {
    layering: {
      ✅: '清晰的分层架构';
      ✅: '正确的依赖方向';
      ✅: '避免循环依赖';
    };
    
    modules: {
      ✅: '模块职责明确';
      ✅: '合理的模块划分';
      ✅: '正确的模块导入导出';
    };
    
    patterns: {
      ✅: '使用合适的设计模式';
      ✅: '遵循SOLID原则';
      ✅: '正确使用装饰器';
    };
  };
  
  // 安全性
  security: {
    authentication: {
      ✅: '实现强认证机制';
      ✅: '使用安全的密码策略';
      ✅: '实现会话管理';
    };
    
    authorization: {
      ✅: '实现细粒度权限控制';
      ✅: '使用角色基访问控制';
      ✅: '验证用户权限';
    };
    
    dataProtection: {
      ✅: '敏感数据加密存储';
      ✅: '输入数据验证';
      ✅: '防止SQL注入';
      ✅: '防止XSS攻击';
    };
  };
  
  // 性能优化
  performance: {
    database: {
      ✅: '合理使用索引';
      ✅: '避免N+1查询问题';
      ✅: '使用连接池';
      ✅: '实现查询优化';
    };
    
    caching: {
      ✅: '实现多级缓存';
      ✅: '合理设置缓存TTL';
      ✅: '实现缓存失效策略';
    };
    
    optimization: {
      ✅: '使用异步处理';
      ✅: '实现分页查询';
      ✅: '优化响应大小';
      ✅: '使用压缩';
    };
  };
  
  // 测试
  testing: {
    coverage: {
      ✅: '单元测试覆盖率 > 80%';
      ✅: '集成测试覆盖核心流程';
      ✅: 'E2E测试覆盖关键场景';
    };
    
    quality: {
      ✅: '测试用例清晰明确';
      ✅: '使用合适的测试工具';
      ✅: '实现测试数据管理';
      ✅: '测试环境隔离';
    };
  };
  
  // 监控和维护
  monitoring: {
    logging: {
      ✅: '实现结构化日志';
      ✅: '记录关键业务事件';
      ✅: '实现日志级别管理';
    };
    
    metrics: {
      ✅: '监控应用性能指标';
      ✅: '监控业务指标';
      ✅: '实现告警机制';
    };
    
    health: {
      ✅: '实现健康检查';
      ✅: '监控依赖服务状态';
      ✅: '实现优雅关闭';
    };
  };
}

// 代码审查清单
export interface CodeReviewChecklist {
  // 功能性
  functionality: {
    ✅: '代码实现符合需求';
    ✅: '边界条件处理正确';
    ✅: '错误处理完善';
    ✅: '业务逻辑正确';
  };
  
  // 可读性
  readability: {
    ✅: '代码结构清晰';
    ✅: '注释充分且准确';
    ✅: '变量命名有意义';
    ✅: '代码格式一致';
  };
  
  // 可维护性
  maintainability: {
    ✅: '代码复用性好';
    ✅: '模块耦合度低';
    ✅: '易于扩展';
    ✅: '遵循编码规范';
  };
  
  // 性能
  performance: {
    ✅: '算法效率合理';
    ✅: '资源使用优化';
    ✅: '避免内存泄漏';
    ✅: '数据库查询优化';
  };
  
  // 安全性
  security: {
    ✅: '输入验证充分';
    ✅: '权限检查正确';
    ✅: '敏感信息保护';
    ✅: '安全编码实践';
  };
}

// 部署清单
export interface DeploymentChecklist {
  // 环境准备
  environment: {
    ✅: '生产环境配置正确';
    ✅: '环境变量设置完整';
    ✅: '依赖服务可用';
    ✅: '网络配置正确';
  };
  
  // 数据库
  database: {
    ✅: '数据库迁移执行';
    ✅: '数据备份完成';
    ✅: '索引创建完成';
    ✅: '权限配置正确';
  };
  
  // 应用部署
  application: {
    ✅: '应用构建成功';
    ✅: '配置文件正确';
    ✅: '健康检查通过';
    ✅: '日志输出正常';
  };
  
  // 监控告警
  monitoring: {
    ✅: '监控指标配置';
    ✅: '告警规则设置';
    ✅: '日志收集配置';
    ✅: '性能监控启用';
  };
  
  // 安全配置
  security: {
    ✅: '防火墙规则配置';
    ✅: 'SSL证书安装';
    ✅: '访问控制配置';
    ✅: '安全扫描通过';
  };
}
```

### 🎯 持续改进建议

```typescript
// 持续改进框架
export interface ContinuousImprovementFramework {
  // 技术债务管理
  technicalDebt: {
    identification: {
      codeSmells: '识别代码异味';
      complexityAnalysis: '复杂度分析';
      dependencyAnalysis: '依赖分析';
      performanceBottlenecks: '性能瓶颈识别';
    };
    
    prioritization: {
      businessImpact: '业务影响评估';
      technicalRisk: '技术风险评估';
      effortEstimation: '工作量估算';
      costBenefitAnalysis: '成本效益分析';
    };
    
    resolution: {
      refactoringPlan: '重构计划';
      incrementalImprovement: '渐进式改进';
      architecturalChanges: '架构调整';
      toolingUpgrade: '工具升级';
    };
  };
  
  // 性能优化
  performanceOptimization: {
    monitoring: {
      responseTime: '响应时间监控';
      throughput: '吞吐量监控';
      resourceUsage: '资源使用监控';
      errorRate: '错误率监控';
    };
    
    analysis: {
      bottleneckIdentification: '瓶颈识别';
      rootCauseAnalysis: '根因分析';
      impactAssessment: '影响评估';
      optimizationOpportunities: '优化机会识别';
    };
    
    optimization: {
      codeOptimization: '代码优化';
      databaseOptimization: '数据库优化';
      cachingStrategy: '缓存策略优化';
      infrastructureScaling: '基础设施扩展';
    };
  };
  
  // 团队能力提升
  teamCapabilityBuilding: {
    skillAssessment: {
      technicalSkills: '技术技能评估';
      domainKnowledge: '领域知识评估';
      toolProficiency: '工具熟练度评估';
      bestPracticesAdherence: '最佳实践遵循度';
    };
    
    trainingPlan: {
      technicalTraining: '技术培训计划';
      codeReviewSessions: '代码审查会议';
      knowledgeSharing: '知识分享会';
      mentorship: '导师制度';
    };
    
    processImprovement: {
      developmentWorkflow: '开发流程优化';
      codeQualityStandards: '代码质量标准';
      testingStrategy: '测试策略改进';
      deploymentProcess: '部署流程优化';
    };
  };
}
```

## 🎓 学习总结

通过第7章的学习，我们掌握了：

1. **企业级架构设计**：分层架构、模块化设计、SOLID原则应用
2. **代码组织规范**：目录结构、命名规范、模块组织
3. **配置管理体系**：环境配置、敏感信息管理、配置验证
4. **错误处理机制**：统一异常处理、业务异常设计、错误日志记录
5. **日志监控系统**：结构化日志、性能监控、业务日志
6. **性能优化策略**：多级缓存、数据库优化、查询分析
7. **工程化工具链**：代码质量工具、自动化测试、CI/CD流程
8. **质量保证体系**：代码质量监控、测试策略、持续改进

这些知识为我们构建高质量、可维护、可扩展的企业级NestJS应用奠定了坚实的基础。在下一章中，我们将学习微服务架构设计，进一步提升系统的可扩展性和可维护性。
</rewritten_file>