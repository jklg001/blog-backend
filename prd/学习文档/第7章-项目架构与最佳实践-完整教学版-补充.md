# ğŸ“š ç¬¬7ç« ï¼šé¡¹ç›®æ¶æ„ä¸æœ€ä½³å®è·µï¼ˆè¡¥å……å†…å®¹ï¼‰

> æœ¬æ–‡æ¡£æ˜¯ç¬¬7ç« çš„è¡¥å……å†…å®¹ï¼ŒåŒ…å«æ—¥å¿—ç›‘æ§ã€æ€§èƒ½ä¼˜åŒ–ã€å·¥ç¨‹åŒ–å·¥å…·é“¾å’Œè´¨é‡ä¿è¯ä½“ç³»

## ğŸ“Š æ—¥å¿—ç›‘æ§ç³»ç»Ÿ

### ğŸ“ ç»“æ„åŒ–æ—¥å¿—è®¾è®¡

```typescript
// æ—¥å¿—çº§åˆ«å®šä¹‰
export enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug',
  VERBOSE = 'verbose'
}

// æ—¥å¿—ä¸Šä¸‹æ–‡æ¥å£
export interface LogContext {
  requestId?: string;
  userId?: string;
  sessionId?: string;
  ip?: string;
  userAgent?: string;
  method?: string;
  url?: string;
  statusCode?: number;
  responseTime?: number;
  module?: string;
  action?: string;
  metadata?: Record<string, any>;
}

// ç»“æ„åŒ–æ—¥å¿—æœåŠ¡
@Injectable()
export class StructuredLogger {
  private readonly logger = new Logger(StructuredLogger.name);

  log(level: LogLevel, message: string, context?: LogContext): void {
    const logEntry = this.createLogEntry(level, message, context);
    
    switch (level) {
      case LogLevel.ERROR:
        this.logger.error(logEntry);
        break;
      case LogLevel.WARN:
        this.logger.warn(logEntry);
        break;
      case LogLevel.INFO:
        this.logger.log(logEntry);
        break;
      case LogLevel.DEBUG:
        this.logger.debug(logEntry);
        break;
      case LogLevel.VERBOSE:
        this.logger.verbose(logEntry);
        break;
    }
  }

  error(message: string, error?: Error, context?: LogContext): void {
    const logEntry = this.createLogEntry(LogLevel.ERROR, message, {
      ...context,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined
    });
    
    this.logger.error(logEntry);
  }

  warn(message: string, context?: LogContext): void {
    this.log(LogLevel.WARN, message, context);
  }

  info(message: string, context?: LogContext): void {
    this.log(LogLevel.INFO, message, context);
  }

  debug(message: string, context?: LogContext): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  private createLogEntry(level: LogLevel, message: string, context?: LogContext): any {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...context,
      environment: process.env.NODE_ENV,
      service: 'blog-api',
      version: process.env.APP_VERSION || '1.0.0'
    };
  }
}

// è¯·æ±‚æ—¥å¿—æ‹¦æˆªå™¨
@Injectable()
export class RequestLoggingInterceptor implements NestInterceptor {
  constructor(private readonly logger: StructuredLogger) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    const startTime = Date.now();

    const requestId = request.headers['x-request-id'] || this.generateRequestId();
    request.requestId = requestId;

    // è®°å½•è¯·æ±‚å¼€å§‹
    this.logger.info('è¯·æ±‚å¼€å§‹', {
      requestId,
      method: request.method,
      url: request.url,
      ip: request.ip,
      userAgent: request.headers['user-agent'],
      userId: request.user?.id,
      body: this.sanitizeBody(request.body)
    });

    return next.handle().pipe(
      tap({
        next: (data) => {
          const responseTime = Date.now() - startTime;
          
          // è®°å½•è¯·æ±‚æˆåŠŸ
          this.logger.info('è¯·æ±‚æˆåŠŸ', {
            requestId,
            method: request.method,
            url: request.url,
            statusCode: response.statusCode,
            responseTime,
            userId: request.user?.id
          });
        },
        error: (error) => {
          const responseTime = Date.now() - startTime;
          
          // è®°å½•è¯·æ±‚é”™è¯¯
          this.logger.error('è¯·æ±‚å¤±è´¥', error, {
            requestId,
            method: request.method,
            url: request.url,
            statusCode: response.statusCode,
            responseTime,
            userId: request.user?.id
          });
        }
      })
    );
  }

  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private sanitizeBody(body: any): any {
    if (!body) return body;

    const sanitized = { ...body };
    const sensitiveFields = ['password', 'token', 'secret', 'key', 'authorization'];
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    });

    return sanitized;
  }
}

// ä¸šåŠ¡æ—¥å¿—è£…é¥°å™¨
export function LogBusinessAction(action: string, module?: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const logger = new StructuredLogger();
      const startTime = Date.now();

      try {
        logger.info(`${action} å¼€å§‹`, {
          module: module || target.constructor.name,
          action,
          args: args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg)
        });

        const result = await originalMethod.apply(this, args);
        const duration = Date.now() - startTime;

        logger.info(`${action} æˆåŠŸ`, {
          module: module || target.constructor.name,
          action,
          duration
        });

        return result;
      } catch (error) {
        const duration = Date.now() - startTime;

        logger.error(`${action} å¤±è´¥`, error, {
          module: module || target.constructor.name,
          action,
          duration
        });

        throw error;
      }
    };
  };
}

// ä½¿ç”¨ç¤ºä¾‹
@Injectable()
export class UserService {
  constructor(private readonly logger: StructuredLogger) {}

  @LogBusinessAction('åˆ›å»ºç”¨æˆ·', 'UserService')
  async createUser(createUserDto: CreateUserDto): Promise<UserResponseDto> {
    // ä¸šåŠ¡é€»è¾‘
    const user = await this.userRepository.create(createUserDto);
    
    this.logger.info('ç”¨æˆ·åˆ›å»ºæˆåŠŸ', {
      userId: user.id,
      username: user.username,
      action: 'user_created'
    });

    return this.transformToResponseDto(user);
  }
}
```

### ğŸ“ˆ æ€§èƒ½ç›‘æ§

```typescript
// æ€§èƒ½ç›‘æ§æœåŠ¡
@Injectable()
export class PerformanceMonitoringService {
  private readonly metrics = new Map<string, PerformanceMetric>();

  // è®°å½•æ€§èƒ½æŒ‡æ ‡
  recordMetric(name: string, value: number, tags?: Record<string, string>): void {
    const metric: PerformanceMetric = {
      name,
      value,
      timestamp: Date.now(),
      tags: tags || {}
    };

    this.metrics.set(`${name}_${Date.now()}`, metric);
    
    // å‘é€åˆ°ç›‘æ§ç³»ç»Ÿï¼ˆå¦‚Prometheusã€DataDogç­‰ï¼‰
    this.sendToMonitoringSystem(metric);
  }

  // è®°å½•å“åº”æ—¶é—´
  recordResponseTime(endpoint: string, method: string, duration: number, statusCode: number): void {
    this.recordMetric('http_request_duration_ms', duration, {
      endpoint,
      method,
      status_code: statusCode.toString()
    });
  }

  // è®°å½•æ•°æ®åº“æŸ¥è¯¢æ—¶é—´
  recordDatabaseQueryTime(query: string, duration: number): void {
    this.recordMetric('database_query_duration_ms', duration, {
      query_type: this.extractQueryType(query)
    });
  }

  // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
  recordMemoryUsage(): void {
    const memoryUsage = process.memoryUsage();
    
    this.recordMetric('memory_heap_used_bytes', memoryUsage.heapUsed);
    this.recordMetric('memory_heap_total_bytes', memoryUsage.heapTotal);
    this.recordMetric('memory_external_bytes', memoryUsage.external);
    this.recordMetric('memory_rss_bytes', memoryUsage.rss);
  }

  // è®°å½•CPUä½¿ç”¨æƒ…å†µ
  recordCpuUsage(): void {
    const cpuUsage = process.cpuUsage();
    
    this.recordMetric('cpu_user_microseconds', cpuUsage.user);
    this.recordMetric('cpu_system_microseconds', cpuUsage.system);
  }

  private extractQueryType(query: string): string {
    const normalizedQuery = query.trim().toLowerCase();
    
    if (normalizedQuery.startsWith('select')) return 'select';
    if (normalizedQuery.startsWith('insert')) return 'insert';
    if (normalizedQuery.startsWith('update')) return 'update';
    if (normalizedQuery.startsWith('delete')) return 'delete';
    
    return 'other';
  }

  private sendToMonitoringSystem(metric: PerformanceMetric): void {
    // å®ç°å‘é€åˆ°ç›‘æ§ç³»ç»Ÿçš„é€»è¾‘
    // ä¾‹å¦‚ï¼šPrometheusã€DataDogã€CloudWatchç­‰
    console.log('Metric:', metric);
  }
}

interface PerformanceMetric {
  name: string;
  value: number;
  timestamp: number;
  tags: Record<string, string>;
}

// æ€§èƒ½ç›‘æ§æ‹¦æˆªå™¨
@Injectable()
export class PerformanceInterceptor implements NestInterceptor {
  constructor(
    private readonly performanceMonitoring: PerformanceMonitoringService,
    private readonly logger: StructuredLogger
  ) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const response = context.switchToHttp().getResponse();
    const startTime = Date.now();

    return next.handle().pipe(
      tap({
        next: () => {
          const duration = Date.now() - startTime;
          
          this.performanceMonitoring.recordResponseTime(
            request.route?.path || request.url,
            request.method,
            duration,
            response.statusCode
          );

          // è®°å½•æ…¢è¯·æ±‚
          if (duration > 1000) { // è¶…è¿‡1ç§’çš„è¯·æ±‚
            this.logger.warn('æ…¢è¯·æ±‚æ£€æµ‹', {
              method: request.method,
              url: request.url,
              duration,
              statusCode: response.statusCode
            });
          }
        },
        error: () => {
          const duration = Date.now() - startTime;
          
          this.performanceMonitoring.recordResponseTime(
            request.route?.path || request.url,
            request.method,
            duration,
            response.statusCode
          );
        }
      })
    );
  }
}

// æ•°æ®åº“æ€§èƒ½ç›‘æ§
@Injectable()
export class DatabasePerformanceInterceptor {
  constructor(private readonly performanceMonitoring: PerformanceMonitoringService) {}

  intercept(query: string, parameters?: any[]): any {
    const startTime = Date.now();

    return {
      afterQuery: () => {
        const duration = Date.now() - startTime;
        this.performanceMonitoring.recordDatabaseQueryTime(query, duration);
      }
    };
  }
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ğŸ—„ï¸ ç¼“å­˜ç­–ç•¥å®ç°

```typescript
// å¤šå±‚ç¼“å­˜æœåŠ¡
@Injectable()
export class MultiLevelCacheService {
  private readonly memoryCache = new Map<string, CacheItem>();
  private readonly maxMemoryCacheSize = 1000;

  constructor(
    @Inject('REDIS_CLIENT') private readonly redisClient: Redis,
    private readonly logger: StructuredLogger
  ) {
    // å®šæœŸæ¸…ç†å†…å­˜ç¼“å­˜
    setInterval(() => this.cleanupMemoryCache(), 60000); // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
  }

  // è·å–ç¼“å­˜
  async get<T>(key: string): Promise<T | null> {
    try {
      // 1. å…ˆä»å†…å­˜ç¼“å­˜è·å–
      const memoryItem = this.memoryCache.get(key);
      if (memoryItem && !this.isExpired(memoryItem)) {
        this.logger.debug('ä»å†…å­˜ç¼“å­˜å‘½ä¸­', { key });
        return memoryItem.value as T;
      }

      // 2. ä»Redisè·å–
      const redisValue = await this.redisClient.get(key);
      if (redisValue) {
        const value = JSON.parse(redisValue);
        
        // å›å†™åˆ°å†…å­˜ç¼“å­˜
        this.setMemoryCache(key, value, 300); // 5åˆ†é’Ÿå†…å­˜ç¼“å­˜
        
        this.logger.debug('ä»Redisç¼“å­˜å‘½ä¸­', { key });
        return value as T;
      }

      this.logger.debug('ç¼“å­˜æœªå‘½ä¸­', { key });
      return null;
    } catch (error) {
      this.logger.error('ç¼“å­˜è·å–å¤±è´¥', error, { key });
      return null;
    }
  }

  // è®¾ç½®ç¼“å­˜
  async set<T>(key: string, value: T, ttl: number = 3600): Promise<void> {
    try {
      // 1. è®¾ç½®Redisç¼“å­˜
      await this.redisClient.setex(key, ttl, JSON.stringify(value));
      
      // 2. è®¾ç½®å†…å­˜ç¼“å­˜ï¼ˆè¾ƒçŸ­çš„TTLï¼‰
      const memoryTtl = Math.min(ttl, 300); // æœ€å¤š5åˆ†é’Ÿå†…å­˜ç¼“å­˜
      this.setMemoryCache(key, value, memoryTtl);
      
      this.logger.debug('ç¼“å­˜è®¾ç½®æˆåŠŸ', { key, ttl });
    } catch (error) {
      this.logger.error('ç¼“å­˜è®¾ç½®å¤±è´¥', error, { key });
    }
  }

  // åˆ é™¤ç¼“å­˜
  async del(key: string): Promise<void> {
    try {
      // 1. åˆ é™¤å†…å­˜ç¼“å­˜
      this.memoryCache.delete(key);
      
      // 2. åˆ é™¤Redisç¼“å­˜
      await this.redisClient.del(key);
      
      this.logger.debug('ç¼“å­˜åˆ é™¤æˆåŠŸ', { key });
    } catch (error) {
      this.logger.error('ç¼“å­˜åˆ é™¤å¤±è´¥', error, { key });
    }
  }

  // æ‰¹é‡åˆ é™¤ç¼“å­˜ï¼ˆæ”¯æŒé€šé…ç¬¦ï¼‰
  async delPattern(pattern: string): Promise<void> {
    try {
      // 1. æ¸…ç†å†…å­˜ç¼“å­˜
      for (const key of this.memoryCache.keys()) {
        if (this.matchPattern(key, pattern)) {
          this.memoryCache.delete(key);
        }
      }

      // 2. æ¸…ç†Redisç¼“å­˜
      const keys = await this.redisClient.keys(pattern);
      if (keys.length > 0) {
        await this.redisClient.del(...keys);
      }
      
      this.logger.debug('æ‰¹é‡ç¼“å­˜åˆ é™¤æˆåŠŸ', { pattern, count: keys.length });
    } catch (error) {
      this.logger.error('æ‰¹é‡ç¼“å­˜åˆ é™¤å¤±è´¥', error, { pattern });
    }
  }

  private setMemoryCache<T>(key: string, value: T, ttl: number): void {
    // æ£€æŸ¥å†…å­˜ç¼“å­˜å¤§å°é™åˆ¶
    if (this.memoryCache.size >= this.maxMemoryCacheSize) {
      // åˆ é™¤æœ€æ—§çš„ç¼“å­˜é¡¹
      const oldestKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(oldestKey);
    }

    this.memoryCache.set(key, {
      value,
      expiredAt: Date.now() + ttl * 1000
    });
  }

  private isExpired(item: CacheItem): boolean {
    return Date.now() > item.expiredAt;
  }

  private cleanupMemoryCache(): void {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [key, item] of this.memoryCache.entries()) {
      if (now > item.expiredAt) {
        this.memoryCache.delete(key);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      this.logger.debug('å†…å­˜ç¼“å­˜æ¸…ç†å®Œæˆ', { cleanedCount });
    }
  }

  private matchPattern(key: string, pattern: string): boolean {
    // ç®€å•çš„é€šé…ç¬¦åŒ¹é…å®ç°
    const regex = new RegExp(pattern.replace(/\*/g, '.*'));
    return regex.test(key);
  }
}

interface CacheItem {
  value: any;
  expiredAt: number;
}

// ç¼“å­˜è£…é¥°å™¨
export function Cacheable(options: CacheOptions = {}) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const cacheService = this.cacheService || new MultiLevelCacheService();
      const cacheKey = options.keyGenerator 
        ? options.keyGenerator(target.constructor.name, propertyName, args)
        : `${target.constructor.name}:${propertyName}:${JSON.stringify(args)}`;

      // å°è¯•ä»ç¼“å­˜è·å–
      const cached = await cacheService.get(cacheKey);
      if (cached !== null) {
        return cached;
      }

      // æ‰§è¡ŒåŸæ–¹æ³•
      const result = await originalMethod.apply(this, args);

      // ç¼“å­˜ç»“æœ
      if (result !== null && result !== undefined) {
        await cacheService.set(cacheKey, result, options.ttl || 3600);
      }

      return result;
    };
  };
}

interface CacheOptions {
  ttl?: number;
  keyGenerator?: (className: string, methodName: string, args: any[]) => string;
}

// ä½¿ç”¨ç¤ºä¾‹
@Injectable()
export class ArticleService {
  constructor(private readonly cacheService: MultiLevelCacheService) {}

  @Cacheable({ ttl: 600 }) // 10åˆ†é’Ÿç¼“å­˜
  async findPopularArticles(limit: number = 10): Promise<ArticleResponseDto[]> {
    return this.articleRepository.findPopularArticles(limit);
  }

  @Cacheable({ 
    ttl: 300,
    keyGenerator: (className, methodName, args) => `${className}:${methodName}:${args[0]}`
  })
  async findArticleById(id: string): Promise<ArticleResponseDto> {
    const article = await this.articleRepository.findById(id);
    if (!article) {
      throw new ResourceNotFoundException('Article', id);
    }
    return this.transformToResponseDto(article);
  }
}
```

### ğŸ”„ æ•°æ®åº“ä¼˜åŒ–

```typescript
// æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
@Injectable()
export class DatabaseOptimizationService {
  constructor(
    @InjectDataSource() private readonly dataSource: DataSource,
    private readonly performanceMonitoring: PerformanceMonitoringService
  ) {}

  // æŸ¥è¯¢ä¼˜åŒ–åˆ†æ
  async analyzeQuery(query: string, parameters?: any[]): Promise<QueryAnalysis> {
    const startTime = Date.now();
    
    try {
      // æ‰§è¡ŒæŸ¥è¯¢è®¡åˆ’åˆ†æ
      const explainResult = await this.dataSource.query(`EXPLAIN ANALYZE ${query}`, parameters);
      const duration = Date.now() - startTime;

      const analysis: QueryAnalysis = {
        query,
        duration,
        executionPlan: explainResult,
        recommendations: this.generateRecommendations(explainResult, duration)
      };

      // è®°å½•æ…¢æŸ¥è¯¢
      if (duration > 1000) {
        this.performanceMonitoring.recordMetric('slow_query_detected', 1, {
          query_type: this.extractQueryType(query),
          duration: duration.toString()
        });
      }

      return analysis;
    } catch (error) {
      throw new Error(`æŸ¥è¯¢åˆ†æå¤±è´¥: ${error.message}`);
    }
  }

  // ç´¢å¼•å»ºè®®
  async suggestIndexes(tableName: string): Promise<IndexSuggestion[]> {
    const suggestions: IndexSuggestion[] = [];

    // åˆ†ææŸ¥è¯¢æ¨¡å¼
    const queryPatterns = await this.analyzeQueryPatterns(tableName);
    
    for (const pattern of queryPatterns) {
      if (pattern.frequency > 10 && pattern.avgDuration > 100) {
        suggestions.push({
          tableName,
          columns: pattern.whereColumns,
          type: 'btree',
          reason: `é¢‘ç¹æŸ¥è¯¢å­—æ®µï¼Œå¹³å‡è€—æ—¶${pattern.avgDuration}ms`,
          priority: this.calculatePriority(pattern)
        });
      }
    }

    return suggestions;
  }

  // è¿æ¥æ± ç›‘æ§
  getConnectionPoolStats(): ConnectionPoolStats {
    const pool = this.dataSource.driver.pool;
    
    return {
      totalConnections: pool.totalCount,
      idleConnections: pool.idleCount,
      activeConnections: pool.totalCount - pool.idleCount,
      waitingClients: pool.waitingCount,
      maxConnections: pool.options.max,
      minConnections: pool.options.min
    };
  }

  // ä¼˜åŒ–å»ºè®®
  getOptimizationRecommendations(): OptimizationRecommendation[] {
    const recommendations: OptimizationRecommendation[] = [];
    const poolStats = this.getConnectionPoolStats();

    // è¿æ¥æ± ä¼˜åŒ–å»ºè®®
    if (poolStats.activeConnections / poolStats.maxConnections > 0.8) {
      recommendations.push({
        type: 'connection_pool',
        priority: 'high',
        description: 'è¿æ¥æ± ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå»ºè®®å¢åŠ æœ€å¤§è¿æ¥æ•°',
        action: 'è°ƒæ•´æ•°æ®åº“è¿æ¥æ± é…ç½®'
      });
    }

    if (poolStats.waitingClients > 0) {
      recommendations.push({
        type: 'connection_pool',
        priority: 'critical',
        description: 'å­˜åœ¨ç­‰å¾…è¿æ¥çš„å®¢æˆ·ç«¯ï¼Œè¿æ¥æ± å¯èƒ½ä¸è¶³',
        action: 'ç«‹å³å¢åŠ è¿æ¥æ± å¤§å°æˆ–ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½'
      });
    }

    return recommendations;
  }

  private async analyzeQueryPatterns(tableName: string): Promise<QueryPattern[]> {
    // è¿™é‡Œåº”è¯¥åˆ†æå®é™…çš„æŸ¥è¯¢æ—¥å¿—
    // ç®€åŒ–å®ç°ï¼Œè¿”å›æ¨¡æ‹Ÿæ•°æ®
    return [
      {
        whereColumns: ['user_id'],
        frequency: 50,
        avgDuration: 150
      },
      {
        whereColumns: ['created_at'],
        frequency: 30,
        avgDuration: 80
      }
    ];
  }

  private generateRecommendations(executionPlan: any[], duration: number): string[] {
    const recommendations: string[] = [];

    if (duration > 1000) {
      recommendations.push('æŸ¥è¯¢è€—æ—¶è¿‡é•¿ï¼Œå»ºè®®ä¼˜åŒ–');
    }

    // åˆ†ææ‰§è¡Œè®¡åˆ’
    const planText = JSON.stringify(executionPlan).toLowerCase();
    
    if (planText.includes('seq scan')) {
      recommendations.push('æ£€æµ‹åˆ°å…¨è¡¨æ‰«æï¼Œå»ºè®®æ·»åŠ ç´¢å¼•');
    }

    if (planText.includes('nested loop')) {
      recommendations.push('æ£€æµ‹åˆ°åµŒå¥—å¾ªç¯ï¼Œè€ƒè™‘ä¼˜åŒ–JOINæ¡ä»¶');
    }

    return recommendations;
  }

  private extractQueryType(query: string): string {
    const normalizedQuery = query.trim().toLowerCase();
    
    if (normalizedQuery.startsWith('select')) return 'select';
    if (normalizedQuery.startsWith('insert')) return 'insert';
    if (normalizedQuery.startsWith('update')) return 'update';
    if (normalizedQuery.startsWith('delete')) return 'delete';
    
    return 'other';
  }

  private calculatePriority(pattern: QueryPattern): 'low' | 'medium' | 'high' {
    const score = pattern.frequency * pattern.avgDuration;
    
    if (score > 10000) return 'high';
    if (score > 5000) return 'medium';
    return 'low';
  }
}

interface QueryAnalysis {
  query: string;
  duration: number;
  executionPlan: any[];
  recommendations: string[];
}

interface IndexSuggestion {
  tableName: string;
  columns: string[];
  type: string;
  reason: string;
  priority: 'low' | 'medium' | 'high';
}

interface ConnectionPoolStats {
  totalConnections: number;
  idleConnections: number;
  activeConnections: number;
  waitingClients: number;
  maxConnections: number;
  minConnections: number;
}

interface OptimizationRecommendation {
  type: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  action: string;
}

interface QueryPattern {
  whereColumns: string[];
  frequency: number;
  avgDuration: number;
}
```

## ğŸ”§ å·¥ç¨‹åŒ–å·¥å…·é“¾

### ğŸ“‹ ä»£ç è´¨é‡å·¥å…·é…ç½®

```typescript
// ESLinté…ç½®
// .eslintrc.js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    '@nestjs/eslint-config',
    '@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'error',
    '@typescript-eslint/explicit-module-boundary-types': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/prefer-readonly': 'error',
    '@typescript-eslint/prefer-readonly-parameter-types': 'off',
    'prefer-const': 'error',
    'no-var': 'error',
    'no-console': 'warn',
    'complexity': ['error', { max: 10 }],
    'max-lines-per-function': ['error', { max: 50 }],
    'max-depth': ['error', { max: 4 }],
    'max-params': ['error', { max: 4 }],
  },
};

// Prettieré…ç½®
// .prettierrc
{
  "singleQuote": true,
  "trailingComma": "all",
  "tabWidth": 2,
  "semi": true,
  "printWidth": 100,
  "endOfLine": "lf"
}

// Huskyé…ç½®
// .husky/pre-commit
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npm run lint
npm run format:check
npm run test:unit

// .husky/commit-msg
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npx commitlint --edit $1

// CommitLinté…ç½®
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      [
        'feat',     // æ–°åŠŸèƒ½
        'fix',      // ä¿®å¤bug
        'docs',     // æ–‡æ¡£æ›´æ–°
        'style',    // ä»£ç æ ¼å¼
        'refactor', // é‡æ„
        'perf',     // æ€§èƒ½ä¼˜åŒ–
        'test',     // æµ‹è¯•
        'chore',    // æ„å»ºè¿‡ç¨‹æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨
        'ci',       // CIé…ç½®
        'build',    // æ„å»ºç³»ç»Ÿ
        'revert',   // å›æ»š
      ],
    ],
    'type-case': [2, 'always', 'lower-case'],
    'type-empty': [2, 'never'],
    'scope-case': [2, 'always', 'lower-case'],
    'subject-case': [2, 'never', ['sentence-case', 'start-case', 'pascal-case', 'upper-case']],
    'subject-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],
    'header-max-length': [2, 'always', 72],
  },
};
```

### ğŸ§ª è‡ªåŠ¨åŒ–æµ‹è¯•é…ç½®

```typescript
// Jesté…ç½®
// jest.config.js
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.spec.ts',
    '!**/*.interface.ts',
    '!**/*.dto.ts',
    '!**/*.entity.ts',
    '!**/node_modules/**',
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],
  testTimeout: 30000,
};

// æµ‹è¯•å·¥å…·ç±»
export class TestUtils {
  // åˆ›å»ºæµ‹è¯•æ¨¡å—
  static async createTestingModule(metadata: ModuleMetadata): Promise<TestingModule> {
    return Test.createTestingModule(metadata).compile();
  }

  // åˆ›å»ºMockä»“å‚¨
  static createMockRepository<T>(): MockRepository<T> {
    return {
      find: jest.fn(),
      findOne: jest.fn(),
      findAndCount: jest.fn(),
      save: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      remove: jest.fn(),
      count: jest.fn(),
      increment: jest.fn(),
      decrement: jest.fn(),
    } as any;
  }

  // åˆ›å»ºMockæœåŠ¡
  static createMockService<T>(methods: (keyof T)[]): Partial<T> {
    const mock: any = {};
    methods.forEach(method => {
      mock[method] = jest.fn();
    });
    return mock;
  }

  // ç”Ÿæˆæµ‹è¯•æ•°æ®
  static generateTestUser(overrides: Partial<UserEntity> = {}): UserEntity {
    return {
      id: 'test-user-id',
      username: 'testuser',
      email: 'test@example.com',
      password: 'hashedpassword',
      avatar: null,
      status: 'active',
      roles: ['user'],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    } as UserEntity;
  }

  static generateTestArticle(overrides: Partial<ArticleEntity> = {}): ArticleEntity {
    return {
      id: 'test-article-id',
      title: 'Test Article',
      content: 'Test content',
      summary: 'Test summary',
      slug: 'test-article',
      viewCount: 0,
      readingTime: 5,
      publishedAt: new Date(),
      author: this.generateTestUser(),
      tags: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    } as ArticleEntity;
  }

  // ç­‰å¾…å¼‚æ­¥æ“ä½œ
  static async waitFor(condition: () => boolean, timeout: number = 5000): Promise<void> {
    const startTime = Date.now();
    
    while (!condition() && Date.now() - startTime < timeout) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    if (!condition()) {
      throw new Error('ç­‰å¾…æ¡ä»¶è¶…æ—¶');
    }
  }
}

type MockRepository<T> = {
  [K in keyof Repository<T>]: jest.Mock;
};

// é›†æˆæµ‹è¯•åŸºç±»
export abstract class IntegrationTestBase {
  protected app: INestApplication;
  protected dataSource: DataSource;

  async beforeAll(): Promise<void> {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    })
      .overrideProvider(DataSource)
      .useValue(await this.createTestDataSource())
      .compile();

    this.app = moduleFixture.createNestApplication();
    this.dataSource = moduleFixture.get<DataSource>(DataSource);
    
    await this.app.init();
    await this.setupTestData();
  }

  async afterAll(): Promise<void> {
    await this.cleanupTestData();
    await this.dataSource.destroy();
    await this.app.close();
  }

  async beforeEach(): Promise<void> {
    await this.dataSource.query('BEGIN');
  }

  async afterEach(): Promise<void> {
    await this.dataSource.query('ROLLBACK');
  }

  protected abstract createTestDataSource(): Promise<DataSource>;
  protected abstract setupTestData(): Promise<void>;
  protected abstract cleanupTestData(): Promise<void>;

  protected async request(): Promise<supertest.SuperTest<supertest.Test>> {
    return supertest(this.app.getHttpServer());
  }
}

// E2Eæµ‹è¯•ç¤ºä¾‹
describe('ArticleController (e2e)', () => {
  let app: INestApplication;
  let userService: UserService;
  let authService: AuthService;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    userService = moduleFixture.get<UserService>(UserService);
    authService = moduleFixture.get<AuthService>(AuthService);
    
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('/articles (GET)', () => {
    it('åº”è¯¥è¿”å›æ–‡ç« åˆ—è¡¨', async () => {
      const response = await request(app.getHttpServer())
        .get('/articles')
        .expect(200);

      expect(response.body).toHaveProperty('data');
      expect(response.body).toHaveProperty('pagination');
      expect(Array.isArray(response.body.data)).toBe(true);
    });

    it('åº”è¯¥æ”¯æŒåˆ†é¡µæŸ¥è¯¢', async () => {
      const response = await request(app.getHttpServer())
        .get('/articles?page=1&limit=5')
        .expect(200);

      expect(response.body.pagination.page).toBe(1);
      expect(response.body.pagination.limit).toBe(5);
    });
  });

  describe('/articles (POST)', () => {
    let authToken: string;

    beforeEach(async () => {
      // åˆ›å»ºæµ‹è¯•ç”¨æˆ·å¹¶è·å–è®¤è¯ä»¤ç‰Œ
      const user = await userService.create({
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123'
      });

      const loginResult = await authService.login({
        email: 'test@example.com',
        password: 'password123'
      });

      authToken = loginResult.accessToken;
    });

    it('åº”è¯¥åˆ›å»ºæ–°æ–‡ç« ', async () => {
      const createArticleDto = {
        title: 'æµ‹è¯•æ–‡ç« ',
        content: 'è¿™æ˜¯ä¸€ç¯‡æµ‹è¯•æ–‡ç« çš„å†…å®¹',
        summary: 'æµ‹è¯•æ–‡ç« æ‘˜è¦',
        tags: ['æµ‹è¯•', 'NestJS']
      };

      const response = await request(app.getHttpServer())
        .post('/articles')
        .set('Authorization', `Bearer ${authToken}`)
        .send(createArticleDto)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.title).toBe(createArticleDto.title);
      expect(response.body.content).toBe(createArticleDto.content);
    });

    it('æœªè®¤è¯ç”¨æˆ·ä¸èƒ½åˆ›å»ºæ–‡ç« ', async () => {
      const createArticleDto = {
        title: 'æµ‹è¯•æ–‡ç« ',
        content: 'è¿™æ˜¯ä¸€ç¯‡æµ‹è¯•æ–‡ç« çš„å†…å®¹'
      };

      await request(app.getHttpServer())
        .post('/articles')
        .send(createArticleDto)
        .expect(401);
    });
  });
});
```

## ğŸ›¡ï¸ è´¨é‡ä¿è¯ä½“ç³»

### ğŸ“Š ä»£ç è´¨é‡ç›‘æ§

```typescript
// ä»£ç è´¨é‡åˆ†ææœåŠ¡
@Injectable()
export class CodeQualityService {
  private readonly metrics = new Map<string, QualityMetric>();

  // ä»£ç å¤æ‚åº¦åˆ†æ
  analyzeComplexity(filePath: string, sourceCode: string): ComplexityAnalysis {
    const analysis: ComplexityAnalysis = {
      filePath,
      cyclomaticComplexity: this.calculateCyclomaticComplexity(sourceCode),
      cognitiveComplexity: this.calculateCognitiveComplexity(sourceCode),
      linesOfCode: this.countLinesOfCode(sourceCode),
      maintainabilityIndex: 0,
      technicalDebt: 0
    };

    // è®¡ç®—å¯ç»´æŠ¤æ€§æŒ‡æ•°
    analysis.maintainabilityIndex = this.calculateMaintainabilityIndex(analysis);
    
    // è®¡ç®—æŠ€æœ¯å€ºåŠ¡
    analysis.technicalDebt = this.calculateTechnicalDebt(analysis);

    return analysis;
  }

  // æµ‹è¯•è¦†ç›–ç‡åˆ†æ
  async analyzeCoverage(coverageReport: CoverageReport): Promise<CoverageAnalysis> {
    const analysis: CoverageAnalysis = {
      overall: {
        lines: coverageReport.total.lines.pct,
        functions: coverageReport.total.functions.pct,
        branches: coverageReport.total.branches.pct,
        statements: coverageReport.total.statements.pct
      },
      files: [],
      recommendations: []
    };

    // åˆ†ææ¯ä¸ªæ–‡ä»¶çš„è¦†ç›–ç‡
    for (const [filePath, fileData] of Object.entries(coverageReport.files)) {
      const fileAnalysis: FileCoverageAnalysis = {
        filePath,
        lines: fileData.lines.pct,
        functions: fileData.functions.pct,
        branches: fileData.branches.pct,
        statements: fileData.statements.pct,
        uncoveredLines: fileData.lines.uncovered
      };

      analysis.files.push(fileAnalysis);

      // ç”Ÿæˆæ”¹è¿›å»ºè®®
      if (fileAnalysis.lines < 80) {
        analysis.recommendations.push({
          type: 'coverage',
          priority: 'high',
          file: filePath,
          message: `è¡Œè¦†ç›–ç‡è¿‡ä½ (${fileAnalysis.lines}%)ï¼Œå»ºè®®å¢åŠ æµ‹è¯•ç”¨ä¾‹`
        });
      }
    }

    return analysis;
  }

  // ä»£ç é‡å¤åº¦åˆ†æ
  analyzeDuplication(sourceFiles: string[]): DuplicationAnalysis {
    const duplicates: DuplicateBlock[] = [];
    const analysis: DuplicationAnalysis = {
      duplicateBlocks: duplicates,
      duplicationRatio: 0,
      recommendations: []
    };

    // ç®€åŒ–çš„é‡å¤ä»£ç æ£€æµ‹ç®—æ³•
    for (let i = 0; i < sourceFiles.length; i++) {
      for (let j = i + 1; j < sourceFiles.length; j++) {
        const duplicateBlocks = this.findDuplicateBlocks(sourceFiles[i], sourceFiles[j]);
        duplicates.push(...duplicateBlocks);
      }
    }

    // è®¡ç®—é‡å¤ç‡
    const totalLines = sourceFiles.reduce((sum, file) => sum + this.countLinesOfCode(file), 0);
    const duplicateLines = duplicates.reduce((sum, block) => sum + block.lines, 0);
    analysis.duplicationRatio = (duplicateLines / totalLines) * 100;

    // ç”Ÿæˆå»ºè®®
    if (analysis.duplicationRatio > 5) {
      analysis.recommendations.push({
        type: 'duplication',
        priority: 'medium',
        message: `ä»£ç é‡å¤ç‡è¿‡é«˜ (${analysis.duplicationRatio.toFixed(2)}%)ï¼Œå»ºè®®é‡æ„é‡å¤ä»£ç `
      });
    }

    return analysis;
  }

  // ä¾èµ–åˆ†æ
  analyzeDependencies(packageJson: any): DependencyAnalysis {
    const analysis: DependencyAnalysis = {
      totalDependencies: 0,
      outdatedDependencies: [],
      vulnerabilities: [],
      recommendations: []
    };

    const allDependencies = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };

    analysis.totalDependencies = Object.keys(allDependencies).length;

    // æ£€æŸ¥è¿‡æ—¶çš„ä¾èµ–
    for (const [name, version] of Object.entries(allDependencies)) {
      // è¿™é‡Œåº”è¯¥è°ƒç”¨npm registry APIæ£€æŸ¥æœ€æ–°ç‰ˆæœ¬
      // ç®€åŒ–å®ç°
      if (this.isOutdated(name, version as string)) {
        analysis.outdatedDependencies.push({
          name,
          currentVersion: version as string,
          latestVersion: 'latest' // å®é™…åº”è¯¥ä»registryè·å–
        });
      }
    }

    // å®‰å…¨æ¼æ´æ£€æŸ¥
    analysis.vulnerabilities = this.checkVulnerabilities(allDependencies);

    return analysis;
  }

  private calculateCyclomaticComplexity(sourceCode: string): number {
    // ç®€åŒ–çš„åœˆå¤æ‚åº¦è®¡ç®—
    const complexityKeywords = ['if', 'else', 'while', 'for', 'switch', 'case', 'catch', '&&', '||', '?'];
    let complexity = 1; // åŸºç¡€å¤æ‚åº¦

    for (const keyword of complexityKeywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, 'g');
      const matches = sourceCode.match(regex);
      if (matches) {
        complexity += matches.length;
      }
    }

    return complexity;
  }

  private calculateCognitiveComplexity(sourceCode: string): number {
    // ç®€åŒ–çš„è®¤çŸ¥å¤æ‚åº¦è®¡ç®—
    // å®é™…å®ç°éœ€è¦æ›´å¤æ‚çš„ASTåˆ†æ
    return this.calculateCyclomaticComplexity(sourceCode) * 0.8;
  }

  private countLinesOfCode(sourceCode: string): number {
    return sourceCode.split('\n').filter(line => line.trim().length > 0).length;
  }

  private calculateMaintainabilityIndex(analysis: ComplexityAnalysis): number {
    // å¯ç»´æŠ¤æ€§æŒ‡æ•°è®¡ç®—å…¬å¼
    const volume = analysis.linesOfCode * Math.log2(analysis.linesOfCode);
    const complexity = analysis.cyclomaticComplexity;
    
    return Math.max(0, (171 - 5.2 * Math.log(volume) - 0.23 * complexity - 16.2 * Math.log(analysis.linesOfCode)) * 100 / 171);
  }

  private calculateTechnicalDebt(analysis: ComplexityAnalysis): number {
    // æŠ€æœ¯å€ºåŠ¡ä¼°ç®—ï¼ˆä»¥å°æ—¶ä¸ºå•ä½ï¼‰
    let debt = 0;

    if (analysis.cyclomaticComplexity > 10) {
      debt += (analysis.cyclomaticComplexity - 10) * 0.5;
    }

    if (analysis.maintainabilityIndex < 70) {
      debt += (70 - analysis.maintainabilityIndex) * 0.1;
    }

    return debt;
  }

  private findDuplicateBlocks(file1: string, file2: string): DuplicateBlock[] {
    // ç®€åŒ–çš„é‡å¤ä»£ç æ£€æµ‹
    const blocks: DuplicateBlock[] = [];
    const lines1 = file1.split('\n');
    const lines2 = file2.split('\n');

    // æŸ¥æ‰¾è¿ç»­çš„ç›¸åŒè¡Œ
    for (let i = 0; i < lines1.length - 5; i++) {
      for (let j = 0; j < lines2.length - 5; j++) {
        let matchLength = 0;
        while (
          i + matchLength < lines1.length &&
          j + matchLength < lines2.length &&
          lines1[i + matchLength].trim() === lines2[j + matchLength].trim() &&
          lines1[i + matchLength].trim().length > 0
        ) {
          matchLength++;
        }

        if (matchLength >= 6) { // è‡³å°‘6è¡Œé‡å¤
          blocks.push({
            file1: 'file1',
            file2: 'file2',
            startLine1: i + 1,
            startLine2: j + 1,
            lines: matchLength
          });
        }
      }
    }

    return blocks;
  }

  private isOutdated(name: string, version: string): boolean {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è°ƒç”¨npm registry API
    return Math.random() > 0.8; // 20%çš„æ¦‚ç‡è®¤ä¸ºæ˜¯è¿‡æ—¶çš„
  }

  private checkVulnerabilities(dependencies: Record<string, string>): SecurityVulnerability[] {
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥è°ƒç”¨å®‰å…¨æ•°æ®åº“API
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const [name, version] of Object.entries(dependencies)) {
      if (Math.random() > 0.95) { // 5%çš„æ¦‚ç‡æœ‰æ¼æ´
        vulnerabilities.push({
          package: name,
          version,
          severity: 'medium',
          description: `${name} å­˜åœ¨å®‰å…¨æ¼æ´`,
          recommendation: `å‡çº§åˆ°æœ€æ–°ç‰ˆæœ¬`
        });
      }
    }

    return vulnerabilities;
  }
}

// æ¥å£å®šä¹‰
interface ComplexityAnalysis {
  filePath: string;
  cyclomaticComplexity: number;
  cognitiveComplexity: number;
  linesOfCode: number;
  maintainabilityIndex: number;
  technicalDebt: number;
}

interface CoverageAnalysis {
  overall: {
    lines: number;
    functions: number;
    branches: number;
    statements: number;
  };
  files: FileCoverageAnalysis[];
  recommendations: QualityRecommendation[];
}

interface FileCoverageAnalysis {
  filePath: string;
  lines: number;
  functions: number;
  branches: number;
  statements: number;
  uncoveredLines: number[];
}

interface DuplicationAnalysis {
  duplicateBlocks: DuplicateBlock[];
  duplicationRatio: number;
  recommendations: QualityRecommendation[];
}

interface DuplicateBlock {
  file1: string;
  file2: string;
  startLine1: number;
  startLine2: number;
  lines: number;
}

interface DependencyAnalysis {
  totalDependencies: number;
  outdatedDependencies: OutdatedDependency[];
  vulnerabilities: SecurityVulnerability[];
  recommendations: QualityRecommendation[];
}

interface OutdatedDependency {
  name: string;
  currentVersion: string;
  latestVersion: string;
}

interface SecurityVulnerability {
  package: string;
  version: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  recommendation: string;
}

interface QualityRecommendation {
  type: string;
  priority: 'low' | 'medium' | 'high';
  file?: string;
  message: string;
}

interface QualityMetric {
  name: string;
  value: number;
  timestamp: number;
  threshold: number;
}

interface CoverageReport {
  total: {
    lines: { pct: number };
    functions: { pct: number };
    branches: { pct: number };
    statements: { pct: number };
  };
  files: Record<string, {
    lines: { pct: number; uncovered: number[] };
    functions: { pct: number };
    branches: { pct: number };
    statements: { pct: number };
  }>;
}
```

### ğŸ”„ CI/CDæµç¨‹é…ç½®

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint check
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: Type check
        run: npm run type-check

      - name: Security audit
        run: npm audit --audit-level moderate

  # å•å…ƒæµ‹è¯•
  unit-tests:
    runs-on: ubuntu-latest
    needs: quality-check
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # é›†æˆæµ‹è¯•
  integration-tests:
    runs-on: ubuntu-latest
    needs: quality-check
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run database migrations
        run: npm run migration:run
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: test_db

      - name: Run integration tests
        run: npm run test:integration
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: test_db
          REDIS_HOST: localhost
          REDIS_PORT: 6379

  # E2Eæµ‹è¯•
  e2e-tests:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Run E2E tests
        run: npm run test:e2e
        env:
          DB_HOST: localhost
          DB_PORT: 5432
          DB_USERNAME: postgres
          DB_PASSWORD: postgres
          DB_DATABASE: test_db
          REDIS_HOST: localhost
          REDIS_PORT: 6379

  # æ„å»ºDockeré•œåƒ
  build-image:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, e2e-tests]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT

  # å®‰å…¨æ‰«æ
  security-scan:
    runs-on: ubuntu-latest
    needs: build-image
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build-image.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-image, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: staging
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying ${{ needs.build-image.outputs.image }} to staging environment"
          # è¿™é‡Œæ·»åŠ å®é™…çš„éƒ¨ç½²è„šæœ¬

  # éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
  deploy-production:
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying ${{ needs.build-image.outputs.image }} to production environment"
          # è¿™é‡Œæ·»åŠ å®é™…çš„éƒ¨ç½²è„šæœ¬

# Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm ci --only=production && npm cache clean --force

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN npm run build

# ç”Ÿäº§é•œåƒ
FROM node:18-alpine AS production

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nestjs -u 1001

WORKDIR /app

# å¤åˆ¶ä¾èµ–å’Œæ„å»ºäº§ç‰©
COPY --from=builder --chown=nestjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nestjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nestjs:nodejs /app/package*.json ./

# åˆ‡æ¢åˆ°érootç”¨æˆ·
USER nestjs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# å¯åŠ¨åº”ç”¨
CMD ["node", "dist/main"]

# docker-compose.yml (ç”¨äºæœ¬åœ°å¼€å‘)
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DB_HOST=postgres
      - DB_PORT=5432
      - DB_USERNAME=postgres
      - DB_PASSWORD=postgres
      - DB_DATABASE=blog_db
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - postgres
      - redis
    volumes:
      - .:/app
      - /app/node_modules
    command: npm run start:dev

  postgres:
    image: postgres:14
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=blog_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app

volumes:
  postgres_data:
  redis_data:
```

## ğŸ¯ å®æˆ˜é¡¹ç›®ï¼šä¼ä¸šçº§åšå®¢ç³»ç»Ÿ

### ğŸ“‹ é¡¹ç›®éœ€æ±‚åˆ†æ

```typescript
// é¡¹ç›®éœ€æ±‚æ–‡æ¡£
export interface ProjectRequirements {
  // åŠŸèƒ½éœ€æ±‚
  functional: {
    userManagement: {
      registration: 'ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½';
      authentication: 'ç”¨æˆ·è®¤è¯åŠŸèƒ½';
      profile: 'ç”¨æˆ·èµ„æ–™ç®¡ç†';
      roleManagement: 'è§’è‰²æƒé™ç®¡ç†';
    };
    
    contentManagement: {
      articleCRUD: 'æ–‡ç« å¢åˆ æ”¹æŸ¥';
      categoryManagement: 'åˆ†ç±»ç®¡ç†';
      tagManagement: 'æ ‡ç­¾ç®¡ç†';
      commentSystem: 'è¯„è®ºç³»ç»Ÿ';
      searchFunction: 'æœç´¢åŠŸèƒ½';
    };
    
    systemFeatures: {
      fileUpload: 'æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½';
      emailNotification: 'é‚®ä»¶é€šçŸ¥';
      caching: 'ç¼“å­˜æœºåˆ¶';
      logging: 'æ—¥å¿—è®°å½•';
      monitoring: 'ç³»ç»Ÿç›‘æ§';
    };
  };
  
  // éåŠŸèƒ½éœ€æ±‚
  nonFunctional: {
    performance: {
      responseTime: 'æ¥å£å“åº”æ—¶é—´ < 200ms';
      throughput: 'æ”¯æŒ1000å¹¶å‘ç”¨æˆ·';
      availability: '99.9%å¯ç”¨æ€§';
    };
    
    security: {
      authentication: 'JWTè®¤è¯æœºåˆ¶';
      authorization: 'RBACæƒé™æ§åˆ¶';
      dataEncryption: 'æ•æ„Ÿæ•°æ®åŠ å¯†';
      inputValidation: 'è¾“å…¥æ•°æ®éªŒè¯';
    };
    
    scalability: {
      horizontal: 'æ”¯æŒæ°´å¹³æ‰©å±•';
      database: 'æ•°æ®åº“è¯»å†™åˆ†ç¦»';
      caching: 'å¤šçº§ç¼“å­˜ç­–ç•¥';
    };
    
    maintainability: {
      codeQuality: 'ä»£ç è´¨é‡æ ‡å‡†';
      documentation: 'å®Œæ•´çš„æ–‡æ¡£';
      testing: 'æµ‹è¯•è¦†ç›–ç‡ > 80%';
      monitoring: 'å®Œå–„çš„ç›‘æ§ä½“ç³»';
    };
  };
}

// ç³»ç»Ÿæ¶æ„è®¾è®¡
export interface SystemArchitecture {
  // åˆ†å±‚æ¶æ„
  layers: {
    presentation: {
      controllers: 'æ§åˆ¶å™¨å±‚';
      dto: 'æ•°æ®ä¼ è¾“å¯¹è±¡';
      guards: 'å®ˆå«å±‚';
      interceptors: 'æ‹¦æˆªå™¨';
    };
    
    business: {
      services: 'ä¸šåŠ¡æœåŠ¡å±‚';
      domainModels: 'é¢†åŸŸæ¨¡å‹';
      businessRules: 'ä¸šåŠ¡è§„åˆ™';
    };
    
    data: {
      repositories: 'æ•°æ®è®¿é—®å±‚';
      entities: 'å®ä½“æ¨¡å‹';
      migrations: 'æ•°æ®åº“è¿ç§»';
    };
    
    infrastructure: {
      database: 'æ•°æ®åº“';
      cache: 'ç¼“å­˜';
      messageQueue: 'æ¶ˆæ¯é˜Ÿåˆ—';
      fileStorage: 'æ–‡ä»¶å­˜å‚¨';
    };
  };
  
  // æ¨¡å—è®¾è®¡
  modules: {
    core: 'æ ¸å¿ƒæ¨¡å—';
    auth: 'è®¤è¯æ¨¡å—';
    user: 'ç”¨æˆ·æ¨¡å—';
    article: 'æ–‡ç« æ¨¡å—';
    comment: 'è¯„è®ºæ¨¡å—';
    file: 'æ–‡ä»¶æ¨¡å—';
    notification: 'é€šçŸ¥æ¨¡å—';
  };
}
```

### ğŸ—ï¸ æ ¸å¿ƒæ¨¡å—å®ç°

```typescript
// æ ¸å¿ƒæ¨¡å— - åº”ç”¨å¯åŠ¨é…ç½®
@Module({
  imports: [
    // é…ç½®æ¨¡å—
    ConfigModule.forRoot({
      isGlobal: true,
      load: [appConfig, databaseConfig, redisConfig, jwtConfig],
      validationSchema: Joi.object({
        NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),
        PORT: Joi.number().default(3000),
        DB_HOST: Joi.string().required(),
        DB_PORT: Joi.number().default(5432),
        DB_USERNAME: Joi.string().required(),
        DB_PASSWORD: Joi.string().required(),
        DB_DATABASE: Joi.string().required(),
        REDIS_HOST: Joi.string().default('localhost'),
        REDIS_PORT: Joi.number().default(6379),
        JWT_SECRET: Joi.string().required(),
        JWT_EXPIRES_IN: Joi.string().default('1h'),
      }),
    }),

    // æ•°æ®åº“æ¨¡å—
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get('database.host'),
        port: configService.get('database.port'),
        username: configService.get('database.username'),
        password: configService.get('database.password'),
        database: configService.get('database.database'),
        entities: [__dirname + '/**/*.entity{.ts,.js}'],
        migrations: [__dirname + '/database/migrations/*{.ts,.js}'],
        synchronize: configService.get('NODE_ENV') === 'development',
        logging: configService.get('database.logging'),
        ssl: configService.get('database.ssl'),
        extra: {
          max: configService.get('database.maxConnections'),
          connectionTimeoutMillis: configService.get('database.acquireTimeout'),
          idleTimeoutMillis: configService.get('database.timeout'),
        },
      }),
      inject: [ConfigService],
    }),

    // Redisç¼“å­˜æ¨¡å—
    CacheModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('redis.host'),
        port: configService.get('redis.port'),
        password: configService.get('redis.password'),
        db: configService.get('redis.db'),
        keyPrefix: configService.get('redis.keyPrefix'),
        ttl: configService.get('redis.ttl'),
      }),
      inject: [ConfigService],
      isGlobal: true,
    }),

    // é™æµæ¨¡å—
    ThrottlerModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        ttl: configService.get('app.rateLimit.ttl'),
        limit: configService.get('app.rateLimit.limit'),
        storage: new ThrottlerStorageRedisService(
          new Redis({
            host: configService.get('redis.host'),
            port: configService.get('redis.port'),
          })
        ),
      }),
      inject: [ConfigService],
    }),

    // äº‹ä»¶æ¨¡å—
    EventEmitterModule.forRoot(),

    // è°ƒåº¦æ¨¡å—
    ScheduleModule.forRoot(),

    // ä¸šåŠ¡æ¨¡å—
    AuthModule,
    UserModule,
    ArticleModule,
    CommentModule,
    FileModule,
    NotificationModule,
    
    // å…±äº«æ¨¡å—
    LoggerModule,
    CacheModule,
    EmailModule,
    HealthModule,
  ],
  providers: [
    // å…¨å±€æä¾›è€…
    {
      provide: APP_GUARD,
      useClass: ThrottlerGuard,
    },
    {
      provide: APP_FILTER,
      useClass: GlobalExceptionFilter,
    },
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLoggingInterceptor,
    },
    {
      provide: APP_INTERCEPTOR,
      useClass: PerformanceInterceptor,
    },
    {
      provide: APP_PIPE,
      useClass: ValidationPipe,
    },
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer): void {
    // é…ç½®ä¸­é—´ä»¶
    consumer
      .apply(
        helmet(), // å®‰å…¨å¤´
        compression(), // å“åº”å‹ç¼©
        cors({
          origin: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
          credentials: true,
        }),
        morgan('combined'), // è¯·æ±‚æ—¥å¿—
      )
      .forRoutes('*');

    // è¯·æ±‚IDä¸­é—´ä»¶
    consumer
      .apply((req: Request, res: Response, next: NextFunction) => {
        req.headers['x-request-id'] = req.headers['x-request-id'] || uuidv4();
        next();
      })
      .forRoutes('*');
  }
}

// åº”ç”¨å¯åŠ¨æ–‡ä»¶
async function bootstrap(): Promise<void> {
  const app = await NestFactory.create(AppModule, {
    logger: ['error', 'warn', 'log', 'debug', 'verbose'],
  });

  const configService = app.get(ConfigService);
  const port = configService.get<number>('app.port');
  const apiPrefix = configService.get<string>('app.apiPrefix');

  // è®¾ç½®APIå‰ç¼€
  app.setGlobalPrefix(apiPrefix);

  // Swaggeræ–‡æ¡£é…ç½®
  if (process.env.NODE_ENV !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('åšå®¢ç³»ç»ŸAPI')
      .setDescription('ä¼ä¸šçº§åšå®¢ç³»ç»ŸAPIæ–‡æ¡£')
      .setVersion('1.0')
      .addBearerAuth()
      .addTag('è®¤è¯', 'ç”¨æˆ·è®¤è¯ç›¸å…³æ¥å£')
      .addTag('ç”¨æˆ·', 'ç”¨æˆ·ç®¡ç†ç›¸å…³æ¥å£')
      .addTag('æ–‡ç« ', 'æ–‡ç« ç®¡ç†ç›¸å…³æ¥å£')
      .addTag('è¯„è®º', 'è¯„è®ºç®¡ç†ç›¸å…³æ¥å£')
      .addTag('æ–‡ä»¶', 'æ–‡ä»¶ç®¡ç†ç›¸å…³æ¥å£')
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup(`${apiPrefix}/docs`, app, document, {
      swaggerOptions: {
        persistAuthorization: true,
      },
    });
  }

  // å¯ç”¨å…³é—­é’©å­
  app.enableShutdownHooks();

  // å¯åŠ¨åº”ç”¨
  await app.listen(port);
  
  console.log(`ğŸš€ åº”ç”¨å·²å¯åŠ¨: http://localhost:${port}/${apiPrefix}`);
  console.log(`ğŸ“š APIæ–‡æ¡£: http://localhost:${port}/${apiPrefix}/docs`);
}

bootstrap().catch((error) => {
  console.error('åº”ç”¨å¯åŠ¨å¤±è´¥:', error);
  process.exit(1);
});
```

## ğŸ“‹ æœ€ä½³å®è·µæ€»ç»“

### âœ… å¼€å‘æœ€ä½³å®è·µæ¸…å•

```typescript
// å¼€å‘æœ€ä½³å®è·µæ£€æŸ¥æ¸…å•
export interface BestPracticesChecklist {
  // ä»£ç è´¨é‡
  codeQuality: {
    âœ…: 'ä½¿ç”¨æœ‰æ„ä¹‰çš„å˜é‡å’Œå‡½æ•°å';
    âœ…: 'éµå¾ªä¸€è‡´çš„å‘½åçº¦å®š';
    âœ…: 'é¿å…ä½¿ç”¨ç¼©å†™å’Œç®€å†™';
  };
  
  // æ¶æ„è®¾è®¡
  architecture: {
    layering: {
      âœ…: 'æ¸…æ™°çš„åˆ†å±‚æ¶æ„';
      âœ…: 'æ­£ç¡®çš„ä¾èµ–æ–¹å‘';
      âœ…: 'é¿å…å¾ªç¯ä¾èµ–';
    };
    
    modules: {
      âœ…: 'æ¨¡å—èŒè´£æ˜ç¡®';
      âœ…: 'åˆç†çš„æ¨¡å—åˆ’åˆ†';
      âœ…: 'æ­£ç¡®çš„æ¨¡å—å¯¼å…¥å¯¼å‡º';
    };
    
    patterns: {
      âœ…: 'ä½¿ç”¨åˆé€‚çš„è®¾è®¡æ¨¡å¼';
      âœ…: 'éµå¾ªSOLIDåŸåˆ™';
      âœ…: 'æ­£ç¡®ä½¿ç”¨è£…é¥°å™¨';
    };
  };
  
  // å®‰å…¨æ€§
  security: {
    authentication: {
      âœ…: 'å®ç°å¼ºè®¤è¯æœºåˆ¶';
      âœ…: 'ä½¿ç”¨å®‰å…¨çš„å¯†ç ç­–ç•¥';
      âœ…: 'å®ç°ä¼šè¯ç®¡ç†';
    };
    
    authorization: {
      âœ…: 'å®ç°ç»†ç²’åº¦æƒé™æ§åˆ¶';
      âœ…: 'ä½¿ç”¨è§’è‰²åŸºè®¿é—®æ§åˆ¶';
      âœ…: 'éªŒè¯ç”¨æˆ·æƒé™';
    };
    
    dataProtection: {
      âœ…: 'æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨';
      âœ…: 'è¾“å…¥æ•°æ®éªŒè¯';
      âœ…: 'é˜²æ­¢SQLæ³¨å…¥';
      âœ…: 'é˜²æ­¢XSSæ”»å‡»';
    };
  };
  
  // æ€§èƒ½ä¼˜åŒ–
  performance: {
    database: {
      âœ…: 'åˆç†ä½¿ç”¨ç´¢å¼•';
      âœ…: 'é¿å…N+1æŸ¥è¯¢é—®é¢˜';
      âœ…: 'ä½¿ç”¨è¿æ¥æ± ';
      âœ…: 'å®ç°æŸ¥è¯¢ä¼˜åŒ–';
    };
    
    caching: {
      âœ…: 'å®ç°å¤šçº§ç¼“å­˜';
      âœ…: 'åˆç†è®¾ç½®ç¼“å­˜TTL';
      âœ…: 'å®ç°ç¼“å­˜å¤±æ•ˆç­–ç•¥';
    };
    
    optimization: {
      âœ…: 'ä½¿ç”¨å¼‚æ­¥å¤„ç†';
      âœ…: 'å®ç°åˆ†é¡µæŸ¥è¯¢';
      âœ…: 'ä¼˜åŒ–å“åº”å¤§å°';
      âœ…: 'ä½¿ç”¨å‹ç¼©';
    };
  };
  
  // æµ‹è¯•
  testing: {
    coverage: {
      âœ…: 'å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%';
      âœ…: 'é›†æˆæµ‹è¯•è¦†ç›–æ ¸å¿ƒæµç¨‹';
      âœ…: 'E2Eæµ‹è¯•è¦†ç›–å…³é”®åœºæ™¯';
    };
    
    quality: {
      âœ…: 'æµ‹è¯•ç”¨ä¾‹æ¸…æ™°æ˜ç¡®';
      âœ…: 'ä½¿ç”¨åˆé€‚çš„æµ‹è¯•å·¥å…·';
      âœ…: 'å®ç°æµ‹è¯•æ•°æ®ç®¡ç†';
      âœ…: 'æµ‹è¯•ç¯å¢ƒéš”ç¦»';
    };
  };
  
  // ç›‘æ§å’Œç»´æŠ¤
  monitoring: {
    logging: {
      âœ…: 'å®ç°ç»“æ„åŒ–æ—¥å¿—';
      âœ…: 'è®°å½•å…³é”®ä¸šåŠ¡äº‹ä»¶';
      âœ…: 'å®ç°æ—¥å¿—çº§åˆ«ç®¡ç†';
    };
    
    metrics: {
      âœ…: 'ç›‘æ§åº”ç”¨æ€§èƒ½æŒ‡æ ‡';
      âœ…: 'ç›‘æ§ä¸šåŠ¡æŒ‡æ ‡';
      âœ…: 'å®ç°å‘Šè­¦æœºåˆ¶';
    };
    
    health: {
      âœ…: 'å®ç°å¥åº·æ£€æŸ¥';
      âœ…: 'ç›‘æ§ä¾èµ–æœåŠ¡çŠ¶æ€';
      âœ…: 'å®ç°ä¼˜é›…å…³é—­';
    };
  };
}

// ä»£ç å®¡æŸ¥æ¸…å•
export interface CodeReviewChecklist {
  // åŠŸèƒ½æ€§
  functionality: {
    âœ…: 'ä»£ç å®ç°ç¬¦åˆéœ€æ±‚';
    âœ…: 'è¾¹ç•Œæ¡ä»¶å¤„ç†æ­£ç¡®';
    âœ…: 'é”™è¯¯å¤„ç†å®Œå–„';
    âœ…: 'ä¸šåŠ¡é€»è¾‘æ­£ç¡®';
  };
  
  // å¯è¯»æ€§
  readability: {
    âœ…: 'ä»£ç ç»“æ„æ¸…æ™°';
    âœ…: 'æ³¨é‡Šå……åˆ†ä¸”å‡†ç¡®';
    âœ…: 'å˜é‡å‘½åæœ‰æ„ä¹‰';
    âœ…: 'ä»£ç æ ¼å¼ä¸€è‡´';
  };
  
  // å¯ç»´æŠ¤æ€§
  maintainability: {
    âœ…: 'ä»£ç å¤ç”¨æ€§å¥½';
    âœ…: 'æ¨¡å—è€¦åˆåº¦ä½';
    âœ…: 'æ˜“äºæ‰©å±•';
    âœ…: 'éµå¾ªç¼–ç è§„èŒƒ';
  };
  
  // æ€§èƒ½
  performance: {
    âœ…: 'ç®—æ³•æ•ˆç‡åˆç†';
    âœ…: 'èµ„æºä½¿ç”¨ä¼˜åŒ–';
    âœ…: 'é¿å…å†…å­˜æ³„æ¼';
    âœ…: 'æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–';
  };
  
  // å®‰å…¨æ€§
  security: {
    âœ…: 'è¾“å…¥éªŒè¯å……åˆ†';
    âœ…: 'æƒé™æ£€æŸ¥æ­£ç¡®';
    âœ…: 'æ•æ„Ÿä¿¡æ¯ä¿æŠ¤';
    âœ…: 'å®‰å…¨ç¼–ç å®è·µ';
  };
}

// éƒ¨ç½²æ¸…å•
export interface DeploymentChecklist {
  // ç¯å¢ƒå‡†å¤‡
  environment: {
    âœ…: 'ç”Ÿäº§ç¯å¢ƒé…ç½®æ­£ç¡®';
    âœ…: 'ç¯å¢ƒå˜é‡è®¾ç½®å®Œæ•´';
    âœ…: 'ä¾èµ–æœåŠ¡å¯ç”¨';
    âœ…: 'ç½‘ç»œé…ç½®æ­£ç¡®';
  };
  
  // æ•°æ®åº“
  database: {
    âœ…: 'æ•°æ®åº“è¿ç§»æ‰§è¡Œ';
    âœ…: 'æ•°æ®å¤‡ä»½å®Œæˆ';
    âœ…: 'ç´¢å¼•åˆ›å»ºå®Œæˆ';
    âœ…: 'æƒé™é…ç½®æ­£ç¡®';
  };
  
  // åº”ç”¨éƒ¨ç½²
  application: {
    âœ…: 'åº”ç”¨æ„å»ºæˆåŠŸ';
    âœ…: 'é…ç½®æ–‡ä»¶æ­£ç¡®';
    âœ…: 'å¥åº·æ£€æŸ¥é€šè¿‡';
    âœ…: 'æ—¥å¿—è¾“å‡ºæ­£å¸¸';
  };
  
  // ç›‘æ§å‘Šè­¦
  monitoring: {
    âœ…: 'ç›‘æ§æŒ‡æ ‡é…ç½®';
    âœ…: 'å‘Šè­¦è§„åˆ™è®¾ç½®';
    âœ…: 'æ—¥å¿—æ”¶é›†é…ç½®';
    âœ…: 'æ€§èƒ½ç›‘æ§å¯ç”¨';
  };
  
  // å®‰å…¨é…ç½®
  security: {
    âœ…: 'é˜²ç«å¢™è§„åˆ™é…ç½®';
    âœ…: 'SSLè¯ä¹¦å®‰è£…';
    âœ…: 'è®¿é—®æ§åˆ¶é…ç½®';
    âœ…: 'å®‰å…¨æ‰«æé€šè¿‡';
  };
}
```

### ğŸ¯ æŒç»­æ”¹è¿›å»ºè®®

```typescript
// æŒç»­æ”¹è¿›æ¡†æ¶
export interface ContinuousImprovementFramework {
  // æŠ€æœ¯å€ºåŠ¡ç®¡ç†
  technicalDebt: {
    identification: {
      codeSmells: 'è¯†åˆ«ä»£ç å¼‚å‘³';
      complexityAnalysis: 'å¤æ‚åº¦åˆ†æ';
      dependencyAnalysis: 'ä¾èµ–åˆ†æ';
      performanceBottlenecks: 'æ€§èƒ½ç“¶é¢ˆè¯†åˆ«';
    };
    
    prioritization: {
      businessImpact: 'ä¸šåŠ¡å½±å“è¯„ä¼°';
      technicalRisk: 'æŠ€æœ¯é£é™©è¯„ä¼°';
      effortEstimation: 'å·¥ä½œé‡ä¼°ç®—';
      costBenefitAnalysis: 'æˆæœ¬æ•ˆç›Šåˆ†æ';
    };
    
    resolution: {
      refactoringPlan: 'é‡æ„è®¡åˆ’';
      incrementalImprovement: 'æ¸è¿›å¼æ”¹è¿›';
      architecturalChanges: 'æ¶æ„è°ƒæ•´';
      toolingUpgrade: 'å·¥å…·å‡çº§';
    };
  };
  
  // æ€§èƒ½ä¼˜åŒ–
  performanceOptimization: {
    monitoring: {
      responseTime: 'å“åº”æ—¶é—´ç›‘æ§';
      throughput: 'ååé‡ç›‘æ§';
      resourceUsage: 'èµ„æºä½¿ç”¨ç›‘æ§';
      errorRate: 'é”™è¯¯ç‡ç›‘æ§';
    };
    
    analysis: {
      bottleneckIdentification: 'ç“¶é¢ˆè¯†åˆ«';
      rootCauseAnalysis: 'æ ¹å› åˆ†æ';
      impactAssessment: 'å½±å“è¯„ä¼°';
      optimizationOpportunities: 'ä¼˜åŒ–æœºä¼šè¯†åˆ«';
    };
    
    optimization: {
      codeOptimization: 'ä»£ç ä¼˜åŒ–';
      databaseOptimization: 'æ•°æ®åº“ä¼˜åŒ–';
      cachingStrategy: 'ç¼“å­˜ç­–ç•¥ä¼˜åŒ–';
      infrastructureScaling: 'åŸºç¡€è®¾æ–½æ‰©å±•';
    };
  };
  
  // å›¢é˜Ÿèƒ½åŠ›æå‡
  teamCapabilityBuilding: {
    skillAssessment: {
      technicalSkills: 'æŠ€æœ¯æŠ€èƒ½è¯„ä¼°';
      domainKnowledge: 'é¢†åŸŸçŸ¥è¯†è¯„ä¼°';
      toolProficiency: 'å·¥å…·ç†Ÿç»ƒåº¦è¯„ä¼°';
      bestPracticesAdherence: 'æœ€ä½³å®è·µéµå¾ªåº¦';
    };
    
    trainingPlan: {
      technicalTraining: 'æŠ€æœ¯åŸ¹è®­è®¡åˆ’';
      codeReviewSessions: 'ä»£ç å®¡æŸ¥ä¼šè®®';
      knowledgeSharing: 'çŸ¥è¯†åˆ†äº«ä¼š';
      mentorship: 'å¯¼å¸ˆåˆ¶åº¦';
    };
    
    processImprovement: {
      developmentWorkflow: 'å¼€å‘æµç¨‹ä¼˜åŒ–';
      codeQualityStandards: 'ä»£ç è´¨é‡æ ‡å‡†';
      testingStrategy: 'æµ‹è¯•ç­–ç•¥æ”¹è¿›';
      deploymentProcess: 'éƒ¨ç½²æµç¨‹ä¼˜åŒ–';
    };
  };
}
```

## ğŸ“ å­¦ä¹ æ€»ç»“

é€šè¿‡ç¬¬7ç« çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æŒæ¡äº†ï¼š

1. **ä¼ä¸šçº§æ¶æ„è®¾è®¡**ï¼šåˆ†å±‚æ¶æ„ã€æ¨¡å—åŒ–è®¾è®¡ã€SOLIDåŸåˆ™åº”ç”¨
2. **ä»£ç ç»„ç»‡è§„èŒƒ**ï¼šç›®å½•ç»“æ„ã€å‘½åè§„èŒƒã€æ¨¡å—ç»„ç»‡
3. **é…ç½®ç®¡ç†ä½“ç³»**ï¼šç¯å¢ƒé…ç½®ã€æ•æ„Ÿä¿¡æ¯ç®¡ç†ã€é…ç½®éªŒè¯
4. **é”™è¯¯å¤„ç†æœºåˆ¶**ï¼šç»Ÿä¸€å¼‚å¸¸å¤„ç†ã€ä¸šåŠ¡å¼‚å¸¸è®¾è®¡ã€é”™è¯¯æ—¥å¿—è®°å½•
5. **æ—¥å¿—ç›‘æ§ç³»ç»Ÿ**ï¼šç»“æ„åŒ–æ—¥å¿—ã€æ€§èƒ½ç›‘æ§ã€ä¸šåŠ¡æ—¥å¿—
6. **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**ï¼šå¤šçº§ç¼“å­˜ã€æ•°æ®åº“ä¼˜åŒ–ã€æŸ¥è¯¢åˆ†æ
7. **å·¥ç¨‹åŒ–å·¥å…·é“¾**ï¼šä»£ç è´¨é‡å·¥å…·ã€è‡ªåŠ¨åŒ–æµ‹è¯•ã€CI/CDæµç¨‹
8. **è´¨é‡ä¿è¯ä½“ç³»**ï¼šä»£ç è´¨é‡ç›‘æ§ã€æµ‹è¯•ç­–ç•¥ã€æŒç»­æ”¹è¿›

è¿™äº›çŸ¥è¯†ä¸ºæˆ‘ä»¬æ„å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤ã€å¯æ‰©å±•çš„ä¼ä¸šçº§NestJSåº”ç”¨å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¾®æœåŠ¡æ¶æ„è®¾è®¡ï¼Œè¿›ä¸€æ­¥æå‡ç³»ç»Ÿçš„å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
</rewritten_file>