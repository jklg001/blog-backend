# ğŸ“š ç¬¬7ç« ï¼šé¡¹ç›®æ¶æ„ä¸æœ€ä½³å®è·µ

> **ä»ç†è®ºåˆ°å®è·µ** - æ„å»ºä¼ä¸šçº§NestJSé¡¹ç›®æ¶æ„ä¸å·¥ç¨‹åŒ–ä½“ç³»

## ğŸ¯ ç« èŠ‚æ¦‚è¿°

åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å·²ç»æŒæ¡äº†NestJSçš„æ ¸å¿ƒæŠ€æœ¯å’Œè®¤è¯æœºåˆ¶ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•å°†è¿™äº›æŠ€æœ¯æ•´åˆåˆ°ä¸€ä¸ªå®Œæ•´çš„ä¼ä¸šçº§é¡¹ç›®æ¶æ„ä¸­ï¼Œå»ºç«‹è§„èŒƒçš„å¼€å‘æµç¨‹å’Œè´¨é‡ä¿è¯ä½“ç³»ã€‚

### ğŸ—ï¸ æœ¬ç« å­¦ä¹ è·¯å¾„

```mermaid
graph TD
    A[é¡¹ç›®æ¶æ„è®¾è®¡] --> B[åˆ†å±‚æ¶æ„å®ç°]
    B --> C[ä»£ç ç»„ç»‡è§„èŒƒ]
    C --> D[é…ç½®ç®¡ç†ä½“ç³»]
    D --> E[é”™è¯¯å¤„ç†æœºåˆ¶]
    E --> F[æ—¥å¿—ç›‘æ§ç³»ç»Ÿ]
    F --> G[æ€§èƒ½ä¼˜åŒ–ç­–ç•¥]
    G --> H[å·¥ç¨‹åŒ–å·¥å…·é“¾]
    H --> I[è´¨é‡ä¿è¯ä½“ç³»]
    
    style A fill:#e1f5fe
    style B fill:#e8f5e8
    style C fill:#fff3e0
    style D fill:#ffebee
    style E fill:#f3e5f5
    style F fill:#e0f2f1
    style G fill:#fce4ec
    style H fill:#f1f8e9
    style I fill:#fff8e1
```

## ğŸ¯ å­¦ä¹ ç›®æ ‡

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å°†èƒ½å¤Ÿï¼š

- ğŸ—ï¸ **è®¾è®¡ä¼ä¸šçº§æ¶æ„**ï¼šæŒæ¡åˆ†å±‚æ¶æ„å’Œæ¨¡å—åŒ–è®¾è®¡åŸåˆ™
- ğŸ“ **å»ºç«‹ä»£ç è§„èŒƒ**ï¼šåˆ¶å®šå›¢é˜Ÿä»£ç è§„èŒƒå’Œæœ€ä½³å®è·µæ ‡å‡†
- ğŸ”§ **æ„å»ºå·¥ç¨‹åŒ–ä½“ç³»**ï¼šå»ºç«‹å®Œæ•´çš„å¼€å‘ã€æµ‹è¯•ã€éƒ¨ç½²æµç¨‹
- ğŸ“Š **å®ç°è´¨é‡ä¿è¯**ï¼šå»ºç«‹ä»£ç è´¨é‡ç›‘æ§å’ŒæŒç»­æ”¹è¿›æœºåˆ¶
- âš¡ **ä¼˜åŒ–é¡¹ç›®æ€§èƒ½**ï¼šæŒæ¡æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–ç­–ç•¥
- ğŸ¯ **åº”ç”¨æœ€ä½³å®è·µ**ï¼šéµå¾ªä¼ä¸šçº§å¼€å‘æ ‡å‡†å’Œè§„èŒƒ

## ğŸ—ï¸ ä¼ä¸šçº§é¡¹ç›®æ¶æ„è®¾è®¡

### ğŸ¨ æ¶æ„è®¾è®¡åŸåˆ™

#### ğŸ  ç”Ÿæ´»ç±»æ¯”ï¼šåŸå¸‚è§„åˆ’

æƒ³è±¡é¡¹ç›®æ¶æ„å°±åƒè§„åˆ’ä¸€åº§ç°ä»£åŒ–åŸå¸‚ï¼š

```
ğŸ™ï¸ åŸå¸‚è§„åˆ’ï¼ˆé¡¹ç›®æ¶æ„ï¼‰
â”œâ”€â”€ ğŸ¢ å•†ä¸šåŒºï¼ˆä¸šåŠ¡å±‚ï¼‰
â”œâ”€â”€ ğŸ  ä½å®…åŒºï¼ˆæ•°æ®å±‚ï¼‰
â”œâ”€â”€ ğŸš‡ äº¤é€šç½‘ï¼ˆé€šä¿¡å±‚ï¼‰
â”œâ”€â”€ ğŸ¥ å…¬å…±è®¾æ–½ï¼ˆåŸºç¡€è®¾æ–½ï¼‰
â”œâ”€â”€ ğŸ“‹ è§„åˆ’æ³•è§„ï¼ˆä»£ç è§„èŒƒï¼‰
â””â”€â”€ ğŸš¨ å®‰å…¨ç³»ç»Ÿï¼ˆç›‘æ§å‘Šè­¦ï¼‰

ğŸ¯ è®¾è®¡åŸåˆ™å¯¹æ¯”
â”œâ”€â”€ ğŸ“ åˆ†åŒºè§„åˆ’ â†’ åˆ†å±‚æ¶æ„
â”œâ”€â”€ ğŸ›£ï¸ äº¤é€šä¾¿åˆ© â†’ æ¨¡å—é€šä¿¡
â”œâ”€â”€ ğŸ—ï¸ å¯æ‰©å±•æ€§ â†’ ç³»ç»Ÿæ‰©å±•
â”œâ”€â”€ ğŸ”§ ç»´æŠ¤ä¾¿åˆ© â†’ ä»£ç ç»´æŠ¤
â”œâ”€â”€ ğŸ›¡ï¸ å®‰å…¨å¯é  â†’ ç³»ç»Ÿå®‰å…¨
â””â”€â”€ ğŸ“Š ç›‘æ§ç®¡ç† â†’ ç³»ç»Ÿç›‘æ§
```

#### ğŸ¯ SOLIDè®¾è®¡åŸåˆ™åœ¨æ¶æ„ä¸­çš„åº”ç”¨

```typescript
// SOLIDåŸåˆ™åœ¨NestJSæ¶æ„ä¸­çš„ä½“ç°
interface SOLIDInArchitecture {
  // S - å•ä¸€èŒè´£åŸåˆ™
  singleResponsibility: {
    principle: 'æ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½é¢†åŸŸ';
    implementation: {
      userModule: 'åªå¤„ç†ç”¨æˆ·ç›¸å…³åŠŸèƒ½';
      authModule: 'åªå¤„ç†è®¤è¯ç›¸å…³åŠŸèƒ½';
      articleModule: 'åªå¤„ç†æ–‡ç« ç›¸å…³åŠŸèƒ½';
    };
  };
  
  // O - å¼€é—­åŸåˆ™
  openClosed: {
    principle: 'å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­';
    implementation: {
      interfaces: 'é€šè¿‡æ¥å£å®šä¹‰å¥‘çº¦';
      plugins: 'é€šè¿‡æ’ä»¶æœºåˆ¶æ‰©å±•åŠŸèƒ½';
      strategies: 'é€šè¿‡ç­–ç•¥æ¨¡å¼æ”¯æŒå¤šç§å®ç°';
    };
  };
  
  // L - é‡Œæ°æ›¿æ¢åŸåˆ™
  liskovSubstitution: {
    principle: 'å­ç±»å¯ä»¥æ›¿æ¢çˆ¶ç±»';
    implementation: {
      repositories: 'ä¸åŒæ•°æ®åº“å®ç°å¯ä»¥äº’æ¢';
      services: 'ä¸åŒæœåŠ¡å®ç°å¯ä»¥äº’æ¢';
      guards: 'ä¸åŒè®¤è¯å®ˆå«å¯ä»¥äº’æ¢';
    };
  };
  
  // I - æ¥å£éš”ç¦»åŸåˆ™
  interfaceSegregation: {
    principle: 'å®¢æˆ·ç«¯ä¸åº”ä¾èµ–ä¸éœ€è¦çš„æ¥å£';
    implementation: {
      specificInterfaces: 'å®šä¹‰å…·ä½“çš„æ¥å£';
      roleBasedInterfaces: 'åŸºäºè§’è‰²çš„æ¥å£è®¾è®¡';
      minimalDependencies: 'æœ€å°åŒ–ä¾èµ–å…³ç³»';
    };
  };
  
  // D - ä¾èµ–å€’ç½®åŸåˆ™
  dependencyInversion: {
    principle: 'ä¾èµ–æŠ½è±¡è€Œä¸æ˜¯å…·ä½“å®ç°';
    implementation: {
      dependencyInjection: 'NestJSçš„ä¾èµ–æ³¨å…¥';
      abstractRepositories: 'æŠ½è±¡çš„ä»“å‚¨æ¨¡å¼';
      configurationAbstraction: 'é…ç½®æŠ½è±¡åŒ–';
    };
  };
}
```

### ğŸ—ï¸ åˆ†å±‚æ¶æ„è®¾è®¡

#### ğŸ“Š ç»å…¸ä¸‰å±‚æ¶æ„

```mermaid
graph TD
    A[è¡¨ç°å±‚ Presentation Layer] --> B[ä¸šåŠ¡å±‚ Business Layer]
    B --> C[æ•°æ®å±‚ Data Layer]
    
    A1[Controllers] --> A
    A2[DTOs] --> A
    A3[Pipes] --> A
    A4[Guards] --> A
    
    B1[Services] --> B
    B2[Business Logic] --> B
    B3[Domain Models] --> B
    
    C1[Repositories] --> C
    C2[Entities] --> C
    C3[Database] --> C
    
    style A fill:#e1f5fe
    style B fill:#e8f5e8
    style C fill:#fff3e0
```

**åˆ†å±‚æ¶æ„å®ç°**ï¼š

```typescript
// è¡¨ç°å±‚ - æ§åˆ¶å™¨
@Controller('articles')
@ApiTags('æ–‡ç« ç®¡ç†')
export class ArticleController {
  constructor(private readonly articleService: ArticleService) {}

  @Get()
  @ApiOperation({ summary: 'è·å–æ–‡ç« åˆ—è¡¨' })
  async findAll(@Query() query: FindArticlesDto): Promise<ArticleListResponseDto> {
    return this.articleService.findAll(query);
  }

  @Post()
  @UseGuards(JwtAuthGuard)
  @ApiOperation({ summary: 'åˆ›å»ºæ–‡ç« ' })
  async create(
    @Body() createArticleDto: CreateArticleDto,
    @CurrentUser() user: UserEntity
  ): Promise<ArticleResponseDto> {
    return this.articleService.create(createArticleDto, user);
  }
}

// ä¸šåŠ¡å±‚ - æœåŠ¡
@Injectable()
export class ArticleService {
  constructor(
    private readonly articleRepository: ArticleRepository,
    private readonly userService: UserService,
    private readonly cacheService: CacheService,
    private readonly eventEmitter: EventEmitter2
  ) {}

  async findAll(query: FindArticlesDto): Promise<ArticleListResponseDto> {
    // ä¸šåŠ¡é€»è¾‘å¤„ç†
    const cacheKey = `articles:${JSON.stringify(query)}`;
    
    // å°è¯•ä»ç¼“å­˜è·å–
    const cached = await this.cacheService.get(cacheKey);
    if (cached) {
      return cached;
    }

    // ä»æ•°æ®åº“æŸ¥è¯¢
    const [articles, total] = await this.articleRepository.findAndCount({
      where: this.buildWhereCondition(query),
      order: { createdAt: 'DESC' },
      skip: (query.page - 1) * query.limit,
      take: query.limit,
      relations: ['author', 'tags']
    });

    const result = {
      data: articles.map(article => this.transformToDto(article)),
      pagination: {
        page: query.page,
        limit: query.limit,
        total,
        totalPages: Math.ceil(total / query.limit)
      }
    };

    // ç¼“å­˜ç»“æœ
    await this.cacheService.set(cacheKey, result, 300); // 5åˆ†é’Ÿç¼“å­˜

    return result;
  }

  async create(createArticleDto: CreateArticleDto, author: UserEntity): Promise<ArticleResponseDto> {
    // ä¸šåŠ¡è§„åˆ™éªŒè¯
    await this.validateArticleCreation(createArticleDto, author);

    // åˆ›å»ºæ–‡ç« å®ä½“
    const article = this.articleRepository.create({
      ...createArticleDto,
      author,
      slug: this.generateSlug(createArticleDto.title),
      readingTime: this.calculateReadingTime(createArticleDto.content)
    });

    // ä¿å­˜åˆ°æ•°æ®åº“
    const savedArticle = await this.articleRepository.save(article);

    // å‘å¸ƒäº‹ä»¶
    this.eventEmitter.emit('article.created', {
      articleId: savedArticle.id,
      authorId: author.id
    });

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await this.cacheService.del('articles:*');

    return this.transformToDto(savedArticle);
  }

  private async validateArticleCreation(dto: CreateArticleDto, author: UserEntity): Promise<void> {
    // æ£€æŸ¥ç”¨æˆ·æƒé™
    if (!author.canCreateArticle()) {
      throw new ForbiddenException('ç”¨æˆ·æ²¡æœ‰åˆ›å»ºæ–‡ç« çš„æƒé™');
    }

    // æ£€æŸ¥æ ‡é¢˜é‡å¤
    const existingArticle = await this.articleRepository.findOne({
      where: { title: dto.title }
    });

    if (existingArticle) {
      throw new ConflictException('æ–‡ç« æ ‡é¢˜å·²å­˜åœ¨');
    }

    // æ£€æŸ¥å†…å®¹é•¿åº¦
    if (dto.content.length < 100) {
      throw new BadRequestException('æ–‡ç« å†…å®¹ä¸èƒ½å°‘äº100å­—');
    }
  }

  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  private calculateReadingTime(content: string): number {
    const wordsPerMinute = 200;
    const wordCount = content.split(/\s+/).length;
    return Math.ceil(wordCount / wordsPerMinute);
  }

  private transformToDto(article: ArticleEntity): ArticleResponseDto {
    return {
      id: article.id,
      title: article.title,
      content: article.content,
      summary: article.summary,
      slug: article.slug,
      readingTime: article.readingTime,
      publishedAt: article.publishedAt,
      author: {
        id: article.author.id,
        username: article.author.username,
        avatar: article.author.avatar
      },
      tags: article.tags?.map(tag => ({
        id: tag.id,
        name: tag.name
      })) || [],
      createdAt: article.createdAt,
      updatedAt: article.updatedAt
    };
  }
}

// æ•°æ®å±‚ - ä»“å‚¨
@Injectable()
export class ArticleRepository extends Repository<ArticleEntity> {
  constructor(
    @InjectRepository(ArticleEntity)
    private repository: Repository<ArticleEntity>
  ) {
    super(repository.target, repository.manager, repository.queryRunner);
  }

  async findBySlug(slug: string): Promise<ArticleEntity | null> {
    return this.repository.findOne({
      where: { slug },
      relations: ['author', 'tags']
    });
  }

  async findPublishedArticles(options: FindManyOptions<ArticleEntity>): Promise<[ArticleEntity[], number]> {
    return this.repository.findAndCount({
      ...options,
      where: {
        ...options.where,
        publishedAt: Not(IsNull())
      }
    });
  }

  async incrementViewCount(id: string): Promise<void> {
    await this.repository.increment({ id }, 'viewCount', 1);
  }
}
```

#### ğŸ¯ é¢†åŸŸé©±åŠ¨è®¾è®¡ï¼ˆDDDï¼‰æ¶æ„

```typescript
// é¢†åŸŸå®ä½“
export class ArticleEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @Column('text')
  content: string;

  @Column()
  slug: string;

  @Column({ default: 0 })
  viewCount: number;

  @Column({ default: 0 })
  readingTime: number;

  @Column({ nullable: true })
  publishedAt: Date;

  @ManyToOne(() => UserEntity, user => user.articles)
  author: UserEntity;

  @ManyToMany(() => TagEntity, tag => tag.articles)
  @JoinTable()
  tags: TagEntity[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // é¢†åŸŸæ–¹æ³•
  publish(): void {
    if (this.publishedAt) {
      throw new Error('æ–‡ç« å·²ç»å‘å¸ƒ');
    }
    this.publishedAt = new Date();
  }

  unpublish(): void {
    if (!this.publishedAt) {
      throw new Error('æ–‡ç« å°šæœªå‘å¸ƒ');
    }
    this.publishedAt = null;
  }

  isPublished(): boolean {
    return this.publishedAt !== null;
  }

  canBeEditedBy(user: UserEntity): boolean {
    return this.author.id === user.id || user.hasRole('admin');
  }

  updateContent(title: string, content: string): void {
    if (this.isPublished()) {
      throw new Error('å·²å‘å¸ƒçš„æ–‡ç« ä¸èƒ½ä¿®æ”¹å†…å®¹');
    }
    
    this.title = title;
    this.content = content;
    this.slug = this.generateSlug(title);
    this.readingTime = this.calculateReadingTime(content);
  }

  private generateSlug(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }

  private calculateReadingTime(content: string): number {
    const wordsPerMinute = 200;
    const wordCount = content.split(/\s+/).length;
    return Math.ceil(wordCount / wordsPerMinute);
  }
}

// é¢†åŸŸæœåŠ¡
@Injectable()
export class ArticleDomainService {
  constructor(
    private readonly articleRepository: ArticleRepository,
    private readonly eventBus: EventBus
  ) {}

  async publishArticle(articleId: string, publisherId: string): Promise<void> {
    const article = await this.articleRepository.findById(articleId);
    if (!article) {
      throw new NotFoundException('æ–‡ç« ä¸å­˜åœ¨');
    }

    const publisher = await this.userRepository.findById(publisherId);
    if (!article.canBeEditedBy(publisher)) {
      throw new ForbiddenException('æ²¡æœ‰æƒé™å‘å¸ƒæ­¤æ–‡ç« ');
    }

    // é¢†åŸŸé€»è¾‘
    article.publish();
    
    await this.articleRepository.save(article);

    // å‘å¸ƒé¢†åŸŸäº‹ä»¶
    await this.eventBus.publish(new ArticlePublishedEvent(article.id, publisher.id));
  }
}

// é¢†åŸŸäº‹ä»¶
export class ArticlePublishedEvent {
  constructor(
    public readonly articleId: string,
    public readonly publisherId: string,
    public readonly publishedAt: Date = new Date()
  ) {}
}

// äº‹ä»¶å¤„ç†å™¨
@EventsHandler(ArticlePublishedEvent)
export class ArticlePublishedHandler implements IEventHandler<ArticlePublishedEvent> {
  constructor(
    private readonly notificationService: NotificationService,
    private readonly searchService: SearchService,
    private readonly cacheService: CacheService
  ) {}

  async handle(event: ArticlePublishedEvent): Promise<void> {
    // å‘é€é€šçŸ¥
    await this.notificationService.notifyFollowers(event.publisherId, {
      type: 'article_published',
      articleId: event.articleId
    });

    // æ›´æ–°æœç´¢ç´¢å¼•
    await this.searchService.indexArticle(event.articleId);

    // æ¸…é™¤ç¼“å­˜
    await this.cacheService.del('articles:*');
    await this.cacheService.del(`user:${event.publisherId}:articles`);
  }
}
``` 

## ğŸ“ ä»£ç ç»„ç»‡è§„èŒƒ

### ğŸ—‚ï¸ é¡¹ç›®ç›®å½•ç»“æ„

```
src/
â”œâ”€â”€ common/                 # å…¬å…±æ¨¡å—
â”‚   â”œâ”€â”€ decorators/         # è‡ªå®šä¹‰è£…é¥°å™¨
â”‚   â”œâ”€â”€ filters/           # å¼‚å¸¸è¿‡æ»¤å™¨
â”‚   â”œâ”€â”€ guards/            # å®ˆå«
â”‚   â”œâ”€â”€ interceptors/      # æ‹¦æˆªå™¨
â”‚   â”œâ”€â”€ pipes/             # ç®¡é“
â”‚   â”œâ”€â”€ interfaces/        # å…¬å…±æ¥å£
â”‚   â”œâ”€â”€ constants/         # å¸¸é‡å®šä¹‰
â”‚   â”œâ”€â”€ utils/             # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ types/             # ç±»å‹å®šä¹‰
â”œâ”€â”€ config/                # é…ç½®æ¨¡å—
â”‚   â”œâ”€â”€ database.config.ts
â”‚   â”œâ”€â”€ redis.config.ts
â”‚   â”œâ”€â”€ jwt.config.ts
â”‚   â””â”€â”€ app.config.ts
â”œâ”€â”€ modules/               # ä¸šåŠ¡æ¨¡å—
â”‚   â”œâ”€â”€ auth/              # è®¤è¯æ¨¡å—
â”‚   â”œâ”€â”€ user/              # ç”¨æˆ·æ¨¡å—
â”‚   â””â”€â”€ article/           # æ–‡ç« æ¨¡å—
â”œâ”€â”€ database/              # æ•°æ®åº“ç›¸å…³
â”‚   â”œâ”€â”€ migrations/        # æ•°æ®åº“è¿ç§»
â”‚   â”œâ”€â”€ seeds/             # æ•°æ®ç§å­
â”‚   â””â”€â”€ factories/         # æ•°æ®å·¥å‚
â”œâ”€â”€ shared/                # å…±äº«æ¨¡å—
â”‚   â”œâ”€â”€ cache/             # ç¼“å­˜æ¨¡å—
â”‚   â”œâ”€â”€ logger/            # æ—¥å¿—æ¨¡å—
â”‚   â”œâ”€â”€ email/             # é‚®ä»¶æ¨¡å—
â”‚   â””â”€â”€ upload/            # æ–‡ä»¶ä¸Šä¼ æ¨¡å—
â”œâ”€â”€ app.module.ts          # æ ¹æ¨¡å—
â””â”€â”€ main.ts                # åº”ç”¨å…¥å£
```

### ğŸ“ å‘½åè§„èŒƒ

```typescript
// æ–‡ä»¶å‘½åè§„èŒƒ
interface NamingConventions {
  files: {
    controllers: 'user.controller.ts';
    services: 'user.service.ts';
    repositories: 'user.repository.ts';
    entities: 'user.entity.ts';
    dto: 'create-user.dto.ts';
    interfaces: 'user.interface.ts';
    guards: 'jwt-auth.guard.ts';
    pipes: 'validation.pipe.ts';
    filters: 'http-exception.filter.ts';
    interceptors: 'logging.interceptor.ts';
    modules: 'user.module.ts';
  };
  
  classes: {
    controllers: 'UserController';
    services: 'UserService';
    repositories: 'UserRepository';
    entities: 'UserEntity';
    dto: 'CreateUserDto';
    interfaces: 'IUserService';
    guards: 'JwtAuthGuard';
    pipes: 'ValidationPipe';
    filters: 'HttpExceptionFilter';
    interceptors: 'LoggingInterceptor';
    modules: 'UserModule';
  };
}
```

## âš™ï¸ é…ç½®ç®¡ç†ä½“ç³»

### ğŸ”§ ç¯å¢ƒé…ç½®ç®¡ç†

```typescript
// config/app.config.ts
export interface AppConfig {
  port: number;
  environment: string;
  apiPrefix: string;
  corsOrigins: string[];
  rateLimit: {
    ttl: number;
    limit: number;
  };
}

export default (): { app: AppConfig } => ({
  app: {
    port: parseInt(process.env.PORT, 10) || 3000,
    environment: process.env.NODE_ENV || 'development',
    apiPrefix: process.env.API_PREFIX || 'api/v1',
    corsOrigins: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
    rateLimit: {
      ttl: parseInt(process.env.RATE_LIMIT_TTL, 10) || 60,
      limit: parseInt(process.env.RATE_LIMIT_MAX, 10) || 100
    }
  }
});

// é…ç½®éªŒè¯
import { IsString, IsNumber, IsBoolean, IsOptional, IsIn } from 'class-validator';
import { Transform } from 'class-transformer';

export class EnvironmentVariables {
  @IsString()
  NODE_ENV: string;

  @IsNumber()
  @Transform(({ value }) => parseInt(value, 10))
  PORT: number;

  @IsString()
  DB_HOST: string;

  @IsNumber()
  @Transform(({ value }) => parseInt(value, 10))
  DB_PORT: number;

  @IsString()
  DB_USERNAME: string;

  @IsString()
  DB_PASSWORD: string;

  @IsString()
  DB_DATABASE: string;

  @IsIn(['postgres', 'mysql', 'sqlite'])
  DB_TYPE: string;

  @IsString()
  JWT_SECRET: string;

  @IsString()
  JWT_EXPIRES_IN: string;
}
```

## âš ï¸ é”™è¯¯å¤„ç†æœºåˆ¶

### ğŸ¯ ç»Ÿä¸€å¼‚å¸¸å¤„ç†

```typescript
// è‡ªå®šä¹‰å¼‚å¸¸ç±»
export class BusinessException extends Error {
  constructor(
    public readonly code: string,
    public readonly message: string,
    public readonly statusCode: number = 400,
    public readonly details?: any
  ) {
    super(message);
    this.name = 'BusinessException';
  }
}

export class ValidationException extends BusinessException {
  constructor(message: string, details?: any) {
    super('VALIDATION_ERROR', message, 400, details);
    this.name = 'ValidationException';
  }
}

export class ResourceNotFoundException extends BusinessException {
  constructor(resource: string, id: string) {
    super('RESOURCE_NOT_FOUND', `${resource} with id ${id} not found`, 404);
    this.name = 'ResourceNotFoundException';
  }
}

// å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  constructor(private readonly logger: Logger) {}

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const errorResponse = this.buildErrorResponse(exception, request);
    
    // è®°å½•é”™è¯¯æ—¥å¿—
    this.logError(exception, request, errorResponse);

    response.status(errorResponse.statusCode).json(errorResponse);
  }

  private buildErrorResponse(exception: unknown, request: Request): ErrorResponseDto {
    let statusCode = 500;
    let message = 'Internal server error';
    let code = 'INTERNAL_ERROR';
    let details: any = null;

    if (exception instanceof BusinessException) {
      statusCode = exception.statusCode;
      message = exception.message;
      code = exception.code;
      details = exception.details;
    } else if (exception instanceof HttpException) {
      statusCode = exception.getStatus();
      const response = exception.getResponse();
      
      if (typeof response === 'object' && response !== null) {
        message = (response as any).message || message;
        code = (response as any).error || 'HTTP_ERROR';
        details = (response as any).details;
      } else {
        message = response as string;
      }
    }

    return {
      statusCode,
      message,
      code,
      details,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      requestId: request.headers['x-request-id'] as string
    };
  }

  private logError(exception: unknown, request: Request, errorResponse: ErrorResponseDto): void {
    const { statusCode, message, code } = errorResponse;
    const { method, url, headers, body } = request;

    const logData = {
      statusCode,
      message,
      code,
      method,
      url,
      userAgent: headers['user-agent'],
      ip: request.ip,
      requestId: headers['x-request-id'],
      body: this.sanitizeBody(body),
      stack: exception instanceof Error ? exception.stack : undefined
    };

    if (statusCode >= 500) {
      this.logger.error('æœåŠ¡å™¨å†…éƒ¨é”™è¯¯', logData, 'GlobalExceptionFilter');
    } else if (statusCode >= 400) {
      this.logger.warn('å®¢æˆ·ç«¯é”™è¯¯', logData, 'GlobalExceptionFilter');
    }
  }

  private sanitizeBody(body: any): any {
    if (!body) return body;

    const sanitized = { ...body };
    const sensitiveFields = ['password', 'token', 'secret', 'key'];
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '***';
      }
    });

    return sanitized;
  }
}

// é”™è¯¯å“åº”DTO
export class ErrorResponseDto {
  @ApiProperty({ description: 'HTTPçŠ¶æ€ç ' })
  statusCode: number;

  @ApiProperty({ description: 'é”™è¯¯æ¶ˆæ¯' })
  message: string;

  @ApiProperty({ description: 'é”™è¯¯ä»£ç ' })
  code: string;

  @ApiProperty({ description: 'é”™è¯¯è¯¦æƒ…', required: false })
  details?: any;

  @ApiProperty({ description: 'æ—¶é—´æˆ³' })
  timestamp: string;

  @ApiProperty({ description: 'è¯·æ±‚è·¯å¾„' })
  path: string;

  @ApiProperty({ description: 'è¯·æ±‚æ–¹æ³•' })
  method: string;

  @ApiProperty({ description: 'è¯·æ±‚ID' })
  requestId: string;
} 