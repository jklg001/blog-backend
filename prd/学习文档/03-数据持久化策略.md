# æ•°æ®æŒä¹…åŒ–ç­–ç•¥

> ä»å‰ç«¯çš„çŠ¶æ€ç®¡ç†åˆ°åç«¯çš„æ•°æ®æŒä¹…åŒ–

## ğŸ¤” ä»€ä¹ˆæ˜¯æ•°æ®æŒä¹…åŒ–ï¼Ÿ

### å‰ç«¯çš„çŠ¶æ€ç®¡ç†

åœ¨å‰ç«¯ï¼Œä½ å¯èƒ½è¿™æ ·ç®¡ç†æ•°æ®ï¼š

```tsx
// å‰ç«¯çŠ¶æ€ç®¡ç†
function UserApp() {
  const [users, setUsers] = useState([]);        // å†…å­˜çŠ¶æ€
  const [currentUser, setCurrentUser] = useState(null);
  
  // æ•°æ®åªåœ¨ç»„ä»¶ç”Ÿå‘½å‘¨æœŸå†…å­˜åœ¨
  useEffect(() => {
    // ä»APIè·å–æ•°æ®
    fetchUsers().then(setUsers);
  }, []);
  
  // é¡µé¢åˆ·æ–°åæ•°æ®ä¸¢å¤±
  const addUser = (user) => {
    setUsers([...users, user]);  // åªæ›´æ–°å†…å­˜
  };
  
  return <UserList users={users} onAdd={addUser} />;
}
```

**å‰ç«¯æ•°æ®ç‰¹ç‚¹**ï¼š
- âœ… å“åº”å¿«é€Ÿï¼ˆå†…å­˜æ“ä½œï¼‰
- âŒ åˆ·æ–°å³ä¸¢å¤±
- âŒ å¤šæ ‡ç­¾é¡µä¸å…±äº«
- âŒ æ— æ³•æŒä¹…ä¿å­˜

### åç«¯çš„æ•°æ®æŒä¹…åŒ–

```typescript
// åç«¯æ•°æ®æŒä¹…åŒ–
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>  // æ•°æ®åº“æ“ä½œ
  ) {}
  
  async create(userData: CreateUserDto): Promise<User> {
    const user = this.userRepository.create(userData);
    return this.userRepository.save(user);  // æŒä¹…åŒ–åˆ°æ•°æ®åº“
  }
  
  async findAll(): Promise<User[]> {
    return this.userRepository.find();  // ä»æ•°æ®åº“æŸ¥è¯¢
  }
}
```

**åç«¯æ•°æ®ç‰¹ç‚¹**ï¼š
- âœ… æ°¸ä¹…ä¿å­˜
- âœ… å¤šç”¨æˆ·å…±äº«
- âœ… äº‹åŠ¡å®‰å…¨
- âœ… å¹¶å‘æ§åˆ¶

## ğŸ”„ æ•°æ®æµå¯¹æ¯”

### å‰ç«¯æ•°æ®æµ
```
ç”¨æˆ·äº¤äº’ â†’ æ›´æ–°State â†’ é‡æ–°æ¸²æŸ“ â†’ (åˆ·æ–°ä¸¢å¤±)
    â†“
APIè°ƒç”¨ â†’ æœåŠ¡å™¨ â†’ æ›´æ–°UI
```

### åç«¯æ•°æ®æµ
```
HTTPè¯·æ±‚ â†’ Controller â†’ Service â†’ Repository â†’ Database
                                        â†“
Response â† DTO â† Entity â† æŸ¥è¯¢ç»“æœ â† SQLæŸ¥è¯¢
```

## ğŸ—ï¸ ORMçš„æ¦‚å¿µ

### ä»€ä¹ˆæ˜¯ORMï¼Ÿ

**Object-Relational Mappingï¼ˆå¯¹è±¡å…³ç³»æ˜ å°„ï¼‰**

**å‰ç«¯ç±»æ¯”**ï¼š
```tsx
// å‰ç«¯çš„æ•°æ®æ˜ å°„ï¼ˆç±»ä¼¼ORMçš„æ€æƒ³ï¼‰
interface User {
  id: number;
  name: string;
  email: string;
}

// APIå“åº”æ•°æ®æ˜ å°„
const mapApiResponse = (apiData: any): User => ({
  id: apiData.user_id,        // å­—æ®µæ˜ å°„
  name: apiData.full_name,    // å­—æ®µæ˜ å°„
  email: apiData.email_addr,  // å­—æ®µæ˜ å°„
});

// ä½¿ç”¨ï¼š
const users = apiResponse.map(mapApiResponse);
```

**åç«¯ORM**ï¼š
```typescript
// Entityå®šä¹‰ï¼ˆç±»ä¼¼å‰ç«¯çš„Interface + æ˜ å°„é€»è¾‘ï¼‰
@Entity('blog_user_accounts')  // æ˜ å°„åˆ°æ•°æ®åº“è¡¨
export class User {
  @PrimaryGeneratedColumn()    // æ˜ å°„åˆ°ä¸»é”®
  id: number;
  
  @Column({ length: 50 })      // æ˜ å°„åˆ°VARCHAR(50)
  username: string;
  
  @Column({ unique: true })    // æ˜ å°„åˆ°UNIQUEçº¦æŸ
  email: string;
  
  @CreateDateColumn()          // è‡ªåŠ¨æ˜ å°„æ—¶é—´æˆ³
  createdAt: Date;
}
```

### ORMçš„ä»·å€¼

| ä¼ ç»ŸSQLå¼€å‘ | ORMå¼€å‘ | å‰ç«¯å¯¹æ¯” |
|------------|---------|---------|
| æ‰‹å†™SQLè¯­å¥ | å¯¹è±¡æ–¹æ³•è°ƒç”¨ | æ‰‹åŠ¨DOMæ“ä½œ vs Virtual DOM |
| å­—ç¬¦ä¸²æ‹¼æ¥ | ç±»å‹å®‰å…¨ | å­—ç¬¦ä¸²æ¨¡æ¿ vs JSX |
| æ‰‹åŠ¨æ˜ å°„ | è‡ªåŠ¨æ˜ å°„ | æ‰‹åŠ¨æ•°æ®å¤„ç† vs è‡ªåŠ¨ç»‘å®š |
| æ•°æ®åº“ç»‘å®š | æ•°æ®åº“æ— å…³ | æµè§ˆå™¨å…¼å®¹ vs æ¡†æ¶æŠ½è±¡ |

## ğŸ” TypeORM è¯¦è§£

### 1. å®ä½“å®šä¹‰ (Entity)

#### åŸºç¡€å®ä½“
```typescript
// src/user/entity/user.entity.ts
@Entity('blog_user_accounts')
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ length: 50, comment: 'ç”¨æˆ·å' })
  username: string;
  
  @Column({ length: 100, unique: true, comment: 'é‚®ç®±' })
  email: string;
  
  @CreateDateColumn({ type: 'timestamp', comment: 'åˆ›å»ºæ—¶é—´' })
  createdAt: Date;
  
  @UpdateDateColumn({ type: 'timestamp', comment: 'æ›´æ–°æ—¶é—´' })
  updatedAt: Date;
}
```

**å‰ç«¯ç±»æ¯”**ï¼š
```tsx
// å‰ç«¯çš„æ•°æ®æ¨¡å‹å®šä¹‰
interface User {
  id: number;
  username: string;
  email: string;
  createdAt: string;
  updatedAt: string;
}

// ä½¿ç”¨Zodåšè¿è¡Œæ—¶éªŒè¯ï¼ˆç±»ä¼¼Entityçš„è£…é¥°å™¨ï¼‰
const UserSchema = z.object({
  id: z.number(),
  username: z.string().max(50),
  email: z.string().email(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});
```

#### å®ä½“å…³ç³»

```typescript
// src/article/entity/article.entity.ts
@Entity('blog_articles')
export class Article {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  title: string;
  
  @Column({ type: 'int', comment: 'ä½œè€…ID' })
  authorId: number;
  
  // å¤šå¯¹ä¸€å…³ç³»ï¼šå¤šç¯‡æ–‡ç« å¯¹åº”ä¸€ä¸ªä½œè€…
  @ManyToOne(() => User, { nullable: false })
  @JoinColumn({ name: 'authorId' })
  author: User;
}
```

**å‰ç«¯æ•°æ®å…³ç³»å¤„ç†**ï¼š
```tsx
// å‰ç«¯å¤„ç†å…³è”æ•°æ®
interface Article {
  id: number;
  title: string;
  authorId: number;
  author?: User;  // å¯é€‰å…³è”æ•°æ®
}

// å‰ç«¯éœ€è¦æ‰‹åŠ¨å¤„ç†å…³è”
const ArticleWithAuthor = ({ article }: { article: Article }) => {
  const [author, setAuthor] = useState<User | null>(null);
  
  useEffect(() => {
    if (article.authorId && !article.author) {
      fetchUser(article.authorId).then(setAuthor);  // æ‰‹åŠ¨åŠ è½½å…³è”æ•°æ®
    }
  }, [article.authorId]);
  
  const displayAuthor = article.author || author;
  
  return (
    <div>
      <h3>{article.title}</h3>
      <p>ä½œè€…: {displayAuthor?.username}</p>
    </div>
  );
};
```

### 2. Repository æ¨¡å¼

#### åŸºç¡€æŸ¥è¯¢
```typescript
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>
  ) {}
  
  // æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
  async findAll(): Promise<User[]> {
    return this.userRepository.find();
  }
  
  // æ ¹æ®IDæŸ¥è¯¢
  async findById(id: number): Promise<User> {
    return this.userRepository.findOne({ where: { id } });
  }
  
  // æ¡ä»¶æŸ¥è¯¢
  async findByEmail(email: string): Promise<User> {
    return this.userRepository.findOne({ 
      where: { email },
      relations: ['articles']  // åŠ è½½å…³è”æ•°æ®
    });
  }
}
```

**å‰ç«¯æ•°æ®æŸ¥è¯¢å¯¹æ¯”**ï¼š
```tsx
// å‰ç«¯çš„æ•°æ®æŸ¥è¯¢é€»è¾‘
class UserApiService {
  // æŸ¥è¯¢æ‰€æœ‰ç”¨æˆ·
  async findAll(): Promise<User[]> {
    const response = await fetch('/api/users');
    return response.json();
  }
  
  // æ ¹æ®IDæŸ¥è¯¢
  async findById(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }
  
  // æ¡ä»¶æŸ¥è¯¢
  async findByEmail(email: string): Promise<User> {
    const response = await fetch(`/api/users?email=${email}&include=articles`);
    return response.json();
  }
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
function UserProfile({ userId }: { userId: number }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    userService.findById(userId)
      .then(setUser)
      .finally(() => setLoading(false));
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  return <div>{user?.username}</div>;
}
```

#### é«˜çº§æŸ¥è¯¢
```typescript
// å¤æ‚æŸ¥è¯¢ç¤ºä¾‹
async findArticlesWithAuthors(): Promise<Article[]> {
  return this.articleRepository.find({
    relations: ['author'],           // åŠ è½½ä½œè€…ä¿¡æ¯
    where: {
      status: ArticleStatus.PUBLISHED,
      author: {
        status: 'active'             // åªæŸ¥è¯¢æ´»è·ƒç”¨æˆ·çš„æ–‡ç« 
      }
    },
    order: { createdAt: 'DESC' },    // æŒ‰åˆ›å»ºæ—¶é—´å€’åº
    take: 10,                        // é™åˆ¶10æ¡
    skip: 0                          // åˆ†é¡µåç§»
  });
}

// ä½¿ç”¨QueryBuilderæ„å»ºå¤æ‚æŸ¥è¯¢
async findPopularArticles(): Promise<Article[]> {
  return this.articleRepository
    .createQueryBuilder('article')
    .leftJoinAndSelect('article.author', 'user')
    .where('article.viewCount > :minViews', { minViews: 100 })
    .andWhere('user.status = :status', { status: 'active' })
    .orderBy('article.likeCount', 'DESC')
    .limit(5)
    .getMany();
}
```

**å‰ç«¯å¤æ‚æŸ¥è¯¢å¯¹æ¯”**ï¼š
```tsx
// å‰ç«¯éœ€è¦å¤šæ¬¡APIè°ƒç”¨æˆ–å¤æ‚çš„çŠ¶æ€ç®¡ç†
function PopularArticles() {
  const [articles, setArticles] = useState<Article[]>([]);
  const [authors, setAuthors] = useState<Map<number, User>>(new Map());
  
  useEffect(() => {
    const fetchData = async () => {
      // 1. è·å–çƒ­é—¨æ–‡ç« 
      const articlesData = await fetch('/api/articles?minViews=100&sort=likes&limit=5');
      const articlesJson = await articlesData.json();
      
      // 2. è·å–ä½œè€…ä¿¡æ¯ï¼ˆN+1æŸ¥è¯¢é—®é¢˜ï¼‰
      const authorIds = [...new Set(articlesJson.map(a => a.authorId))];
      const authorsPromises = authorIds.map(id => 
        fetch(`/api/users/${id}`).then(r => r.json())
      );
      const authorsData = await Promise.all(authorsPromises);
      
      // 3. æ„å»ºä½œè€…æ˜ å°„
      const authorsMap = new Map();
      authorsData.forEach(author => authorsMap.set(author.id, author));
      
      setArticles(articlesJson);
      setAuthors(authorsMap);
    };
    
    fetchData();
  }, []);
  
  return (
    <div>
      {articles.map(article => (
        <div key={article.id}>
          <h3>{article.title}</h3>
          <p>ä½œè€…: {authors.get(article.authorId)?.username}</p>
        </div>
      ))}
    </div>
  );
}
```

## ğŸ”§ æ•°æ®åº“è¿ç§»å’ŒåŒæ­¥

### 1. è‡ªåŠ¨åŒæ­¥ vs è¿ç§»

#### å¼€å‘ç¯å¢ƒï¼šè‡ªåŠ¨åŒæ­¥
```typescript
// src/app.module.ts
TypeOrmModule.forRoot({
  // ... å…¶ä»–é…ç½®
  synchronize: true,  // è‡ªåŠ¨åŒæ­¥å®ä½“å˜åŒ–åˆ°æ•°æ®åº“
  logging: true,      // æ˜¾ç¤ºSQLæ—¥å¿—
})
```

**ç±»æ¯”å‰ç«¯**ï¼š
```tsx
// å‰ç«¯çš„çƒ­é‡è½½ï¼ˆç±»ä¼¼æ•°æ®åº“è‡ªåŠ¨åŒæ­¥ï¼‰
// ä¿®æ”¹ç»„ä»¶ä»£ç åè‡ªåŠ¨åˆ·æ–°é¡µé¢æ˜¾ç¤ºæœ€æ–°å†…å®¹
function UserProfile({ user }: { user: User }) {
  return <div>{user.name}</div>;  // ä¿®æ”¹è¿™é‡Œä¼šè‡ªåŠ¨æ›´æ–°æµè§ˆå™¨
}
```

#### ç”Ÿäº§ç¯å¢ƒï¼šè¿ç§»æ–‡ä»¶
```typescript
// ç”Ÿäº§ç¯å¢ƒé…ç½®
TypeOrmModule.forRoot({
  // ... å…¶ä»–é…ç½®
  synchronize: false,    // ç¦ç”¨è‡ªåŠ¨åŒæ­¥
  migrationsRun: true,   // å¯åŠ¨æ—¶è¿è¡Œè¿ç§»
  migrations: ['dist/migrations/*.js'],
})
```

**è¿ç§»æ–‡ä»¶ç¤ºä¾‹**ï¼š
```typescript
// migrations/001-create-users-table.ts
export class CreateUsersTable1640995200000 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(new Table({
      name: 'blog_user_accounts',
      columns: [
        {
          name: 'id',
          type: 'int',
          isPrimary: true,
          isGenerated: true,
          generationStrategy: 'increment'
        },
        {
          name: 'username',
          type: 'varchar',
          length: '50'
        },
        // ... å…¶ä»–å­—æ®µ
      ]
    }));
  }
  
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable('blog_user_accounts');
  }
}
```

**å‰ç«¯ç‰ˆæœ¬æ§åˆ¶å¯¹æ¯”**ï¼š
```tsx
// å‰ç«¯çš„ç‰ˆæœ¬æ§åˆ¶ï¼ˆç±»ä¼¼æ•°æ®åº“è¿ç§»ï¼‰
// v1.0.0 - åˆå§‹ç‰ˆæœ¬
interface User {
  id: number;
  name: string;
}

// v1.1.0 - æ·»åŠ é‚®ç®±å­—æ®µ
interface User {
  id: number;
  name: string;
  email?: string;  // æ–°å¢å­—æ®µï¼Œä¿æŒå‘åå…¼å®¹
}

// æ•°æ®è¿ç§»é€»è¾‘
const migrateUserData = (oldUser: any): User => {
  return {
    ...oldUser,
    email: oldUser.email || '',  // ä¸ºè€æ•°æ®æä¾›é»˜è®¤å€¼
  };
};
```

## ğŸ¯ æ•°æ®éªŒè¯å’Œçº¦æŸ

### 1. å®ä½“å±‚éªŒè¯
```typescript
@Entity('blog_user_accounts')
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ 
    length: 50,
    unique: true,
    comment: 'ç”¨æˆ·åï¼Œå¿…é¡»å”¯ä¸€'
  })
  username: string;
  
  @Column({ 
    length: 100, 
    unique: true,
    comment: 'é‚®ç®±åœ°å€'
  })
  email: string;
  
  @Column({
    type: 'enum',
    enum: ['active', 'inactive', 'banned'],
    default: 'active'
  })
  status: string;
}
```

### 2. DTOå±‚éªŒè¯
```typescript
// src/user/dto/create-user.dto.ts
export class CreateUserDto {
  @IsString()
  @Length(2, 50)
  username: string;
  
  @IsEmail()
  email: string;
  
  @IsString()
  @MinLength(6)
  password: string;
}
```

**å‰ç«¯éªŒè¯å¯¹æ¯”**ï¼š
```tsx
// å‰ç«¯è¡¨å•éªŒè¯
import { z } from 'zod';

const CreateUserSchema = z.object({
  username: z.string().min(2).max(50),
  email: z.string().email(),
  password: z.string().min(6),
});

function CreateUserForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // å‰ç«¯éªŒè¯
    const result = CreateUserSchema.safeParse(formData);
    if (!result.success) {
      const fieldErrors: Record<string, string> = {};
      result.error.errors.forEach(err => {
        fieldErrors[err.path[0]] = err.message;
      });
      setErrors(fieldErrors);
      return;
    }
    
    // æäº¤åˆ°åç«¯
    submitUser(result.data);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.username}
        onChange={e => setFormData({...formData, username: e.target.value})}
        placeholder="ç”¨æˆ·å"
      />
      {errors.username && <span>{errors.username}</span>}
      {/* å…¶ä»–å­—æ®µ... */}
    </form>
  );
}
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. é¢„åŠ è½½å…³è”æ•°æ®
```typescript
// âŒ N+1æŸ¥è¯¢é—®é¢˜
async getArticlesWithAuthors(): Promise<any[]> {
  const articles = await this.articleRepository.find();
  
  // æ¯ç¯‡æ–‡ç« éƒ½è¦æŸ¥è¯¢ä¸€æ¬¡ä½œè€…ï¼ˆN+1é—®é¢˜ï¼‰
  for (const article of articles) {
    article.author = await this.userRepository.findOne({ 
      where: { id: article.authorId } 
    });
  }
  
  return articles;
}

// âœ… ä¼˜åŒ–ï¼šé¢„åŠ è½½å…³è”æ•°æ®
async getArticlesWithAuthors(): Promise<Article[]> {
  return this.articleRepository.find({
    relations: ['author']  // ä¸€æ¬¡æŸ¥è¯¢è·å–æ‰€æœ‰æ•°æ®
  });
}
```

**å‰ç«¯ç±»ä¼¼ä¼˜åŒ–**ï¼š
```tsx
// âŒ å‰ç«¯çš„N+1é—®é¢˜
function ArticleList({ articles }: { articles: Article[] }) {
  return (
    <div>
      {articles.map(article => (
        <ArticleItem key={article.id} article={article} />
      ))}
    </div>
  );
}

function ArticleItem({ article }: { article: Article }) {
  const [author, setAuthor] = useState<User | null>(null);
  
  useEffect(() => {
    // æ¯ä¸ªç»„ä»¶éƒ½å‘èµ·ä¸€æ¬¡è¯·æ±‚ï¼ˆN+1é—®é¢˜ï¼‰
    fetchUser(article.authorId).then(setAuthor);
  }, [article.authorId]);
  
  return (
    <div>
      <h3>{article.title}</h3>
      <p>ä½œè€…: {author?.username}</p>
    </div>
  );
}

// âœ… ä¼˜åŒ–ï¼šæ‰¹é‡è·å–æ•°æ®
function ArticleList({ articles }: { articles: Article[] }) {
  const [authors, setAuthors] = useState<Map<number, User>>(new Map());
  
  useEffect(() => {
    // æ‰¹é‡è·å–æ‰€æœ‰ä½œè€…ä¿¡æ¯
    const authorIds = [...new Set(articles.map(a => a.authorId))];
    fetchUsersBatch(authorIds).then(authorsData => {
      const authorsMap = new Map();
      authorsData.forEach(author => authorsMap.set(author.id, author));
      setAuthors(authorsMap);
    });
  }, [articles]);
  
  return (
    <div>
      {articles.map(article => (
        <ArticleItem 
          key={article.id} 
          article={article} 
          author={authors.get(article.authorId)}
        />
      ))}
    </div>
  );
}
```

### 2. æŸ¥è¯¢ä¼˜åŒ–
```typescript
// åˆ†é¡µæŸ¥è¯¢
async findArticlesPaginated(page: number, limit: number): Promise<[Article[], number]> {
  return this.articleRepository.findAndCount({
    relations: ['author'],
    order: { createdAt: 'DESC' },
    skip: (page - 1) * limit,
    take: limit
  });
}

// ç´¢å¼•ä¼˜åŒ–
@Entity('blog_articles')
@Index(['status', 'createdAt'])  // å¤åˆç´¢å¼•
export class Article {
  @Column()
  @Index()  // å•å­—æ®µç´¢å¼•
  status: string;
  
  @CreateDateColumn()
  createdAt: Date;
}
```

## ğŸ“ å­¦ä¹ è¦ç‚¹æ€»ç»“

1. **ORM = å¯¹è±¡ä¸æ•°æ®åº“çš„æ¡¥æ¢**ï¼šç±»ä¼¼å‰ç«¯ç»„ä»¶ä¸DOMçš„å…³ç³»
2. **Repository = æ•°æ®è®¿é—®å±‚**ï¼šç±»ä¼¼å‰ç«¯çš„APIæœåŠ¡å±‚
3. **Entity = æ•°æ®æ¨¡å‹**ï¼šç±»ä¼¼å‰ç«¯çš„TypeScriptæ¥å£
4. **å…³ç³»æ˜ å°„ = æ•°æ®å…³è”**ï¼šåç«¯è‡ªåŠ¨å¤„ç†ï¼Œå‰ç«¯éœ€æ‰‹åŠ¨ç®¡ç†
5. **è¿ç§» = æ•°æ®åº“ç‰ˆæœ¬æ§åˆ¶**ï¼šç±»ä¼¼å‰ç«¯çš„ä»£ç ç‰ˆæœ¬æ§åˆ¶

## ğŸ”— ä¸å‰ç«¯æ¦‚å¿µå¯¹åº”

| åç«¯æ•°æ®åº“æ¦‚å¿µ | å‰ç«¯å¯¹åº” | è¯´æ˜ |
|-------------|---------|------|
| Entity | Interface/Type | æ•°æ®ç»“æ„å®šä¹‰ |
| Repository | API Service | æ•°æ®æ“ä½œæ¥å£ |
| Migration | Version Control | å˜æ›´ç®¡ç† |
| Transaction | çŠ¶æ€æ‰¹é‡æ›´æ–° | åŸå­æ€§æ“ä½œ |
| Index | ç¼“å­˜ç­–ç•¥ | æ€§èƒ½ä¼˜åŒ– |
| Validation | Form Validation | æ•°æ®éªŒè¯ |

æŒæ¡äº†æ•°æ®æŒä¹…åŒ–ï¼Œä½ å°±ç†è§£äº†åç«¯æ•°æ®ç®¡ç†çš„æ ¸å¿ƒï¼ 