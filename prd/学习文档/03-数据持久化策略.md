# 数据持久化策略

> 从前端的状态管理到后端的数据持久化

## 🤔 什么是数据持久化？

### 前端的状态管理

在前端，你可能这样管理数据：

```tsx
// 前端状态管理
function UserApp() {
  const [users, setUsers] = useState([]);        // 内存状态
  const [currentUser, setCurrentUser] = useState(null);
  
  // 数据只在组件生命周期内存在
  useEffect(() => {
    // 从API获取数据
    fetchUsers().then(setUsers);
  }, []);
  
  // 页面刷新后数据丢失
  const addUser = (user) => {
    setUsers([...users, user]);  // 只更新内存
  };
  
  return <UserList users={users} onAdd={addUser} />;
}
```

**前端数据特点**：
- ✅ 响应快速（内存操作）
- ❌ 刷新即丢失
- ❌ 多标签页不共享
- ❌ 无法持久保存

### 后端的数据持久化

```typescript
// 后端数据持久化
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>  // 数据库操作
  ) {}
  
  async create(userData: CreateUserDto): Promise<User> {
    const user = this.userRepository.create(userData);
    return this.userRepository.save(user);  // 持久化到数据库
  }
  
  async findAll(): Promise<User[]> {
    return this.userRepository.find();  // 从数据库查询
  }
}
```

**后端数据特点**：
- ✅ 永久保存
- ✅ 多用户共享
- ✅ 事务安全
- ✅ 并发控制

## 🔄 数据流对比

### 前端数据流
```
用户交互 → 更新State → 重新渲染 → (刷新丢失)
    ↓
API调用 → 服务器 → 更新UI
```

### 后端数据流
```
HTTP请求 → Controller → Service → Repository → Database
                                        ↓
Response ← DTO ← Entity ← 查询结果 ← SQL查询
```

## 🏗️ ORM的概念

### 什么是ORM？

**Object-Relational Mapping（对象关系映射）**

**前端类比**：
```tsx
// 前端的数据映射（类似ORM的思想）
interface User {
  id: number;
  name: string;
  email: string;
}

// API响应数据映射
const mapApiResponse = (apiData: any): User => ({
  id: apiData.user_id,        // 字段映射
  name: apiData.full_name,    // 字段映射
  email: apiData.email_addr,  // 字段映射
});

// 使用：
const users = apiResponse.map(mapApiResponse);
```

**后端ORM**：
```typescript
// Entity定义（类似前端的Interface + 映射逻辑）
@Entity('blog_user_accounts')  // 映射到数据库表
export class User {
  @PrimaryGeneratedColumn()    // 映射到主键
  id: number;
  
  @Column({ length: 50 })      // 映射到VARCHAR(50)
  username: string;
  
  @Column({ unique: true })    // 映射到UNIQUE约束
  email: string;
  
  @CreateDateColumn()          // 自动映射时间戳
  createdAt: Date;
}
```

### ORM的价值

| 传统SQL开发 | ORM开发 | 前端对比 |
|------------|---------|---------|
| 手写SQL语句 | 对象方法调用 | 手动DOM操作 vs Virtual DOM |
| 字符串拼接 | 类型安全 | 字符串模板 vs JSX |
| 手动映射 | 自动映射 | 手动数据处理 vs 自动绑定 |
| 数据库绑定 | 数据库无关 | 浏览器兼容 vs 框架抽象 |

## 🔍 TypeORM 详解

### 1. 实体定义 (Entity)

#### 基础实体
```typescript
// src/user/entity/user.entity.ts
@Entity('blog_user_accounts')
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ length: 50, comment: '用户名' })
  username: string;
  
  @Column({ length: 100, unique: true, comment: '邮箱' })
  email: string;
  
  @CreateDateColumn({ type: 'timestamp', comment: '创建时间' })
  createdAt: Date;
  
  @UpdateDateColumn({ type: 'timestamp', comment: '更新时间' })
  updatedAt: Date;
}
```

**前端类比**：
```tsx
// 前端的数据模型定义
interface User {
  id: number;
  username: string;
  email: string;
  createdAt: string;
  updatedAt: string;
}

// 使用Zod做运行时验证（类似Entity的装饰器）
const UserSchema = z.object({
  id: z.number(),
  username: z.string().max(50),
  email: z.string().email(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});
```

#### 实体关系

```typescript
// src/article/entity/article.entity.ts
@Entity('blog_articles')
export class Article {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column()
  title: string;
  
  @Column({ type: 'int', comment: '作者ID' })
  authorId: number;
  
  // 多对一关系：多篇文章对应一个作者
  @ManyToOne(() => User, { nullable: false })
  @JoinColumn({ name: 'authorId' })
  author: User;
}
```

**前端数据关系处理**：
```tsx
// 前端处理关联数据
interface Article {
  id: number;
  title: string;
  authorId: number;
  author?: User;  // 可选关联数据
}

// 前端需要手动处理关联
const ArticleWithAuthor = ({ article }: { article: Article }) => {
  const [author, setAuthor] = useState<User | null>(null);
  
  useEffect(() => {
    if (article.authorId && !article.author) {
      fetchUser(article.authorId).then(setAuthor);  // 手动加载关联数据
    }
  }, [article.authorId]);
  
  const displayAuthor = article.author || author;
  
  return (
    <div>
      <h3>{article.title}</h3>
      <p>作者: {displayAuthor?.username}</p>
    </div>
  );
};
```

### 2. Repository 模式

#### 基础查询
```typescript
@Injectable()
export class UserService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>
  ) {}
  
  // 查询所有用户
  async findAll(): Promise<User[]> {
    return this.userRepository.find();
  }
  
  // 根据ID查询
  async findById(id: number): Promise<User> {
    return this.userRepository.findOne({ where: { id } });
  }
  
  // 条件查询
  async findByEmail(email: string): Promise<User> {
    return this.userRepository.findOne({ 
      where: { email },
      relations: ['articles']  // 加载关联数据
    });
  }
}
```

**前端数据查询对比**：
```tsx
// 前端的数据查询逻辑
class UserApiService {
  // 查询所有用户
  async findAll(): Promise<User[]> {
    const response = await fetch('/api/users');
    return response.json();
  }
  
  // 根据ID查询
  async findById(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }
  
  // 条件查询
  async findByEmail(email: string): Promise<User> {
    const response = await fetch(`/api/users?email=${email}&include=articles`);
    return response.json();
  }
}

// 在组件中使用
function UserProfile({ userId }: { userId: number }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    userService.findById(userId)
      .then(setUser)
      .finally(() => setLoading(false));
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  return <div>{user?.username}</div>;
}
```

#### 高级查询
```typescript
// 复杂查询示例
async findArticlesWithAuthors(): Promise<Article[]> {
  return this.articleRepository.find({
    relations: ['author'],           // 加载作者信息
    where: {
      status: ArticleStatus.PUBLISHED,
      author: {
        status: 'active'             // 只查询活跃用户的文章
      }
    },
    order: { createdAt: 'DESC' },    // 按创建时间倒序
    take: 10,                        // 限制10条
    skip: 0                          // 分页偏移
  });
}

// 使用QueryBuilder构建复杂查询
async findPopularArticles(): Promise<Article[]> {
  return this.articleRepository
    .createQueryBuilder('article')
    .leftJoinAndSelect('article.author', 'user')
    .where('article.viewCount > :minViews', { minViews: 100 })
    .andWhere('user.status = :status', { status: 'active' })
    .orderBy('article.likeCount', 'DESC')
    .limit(5)
    .getMany();
}
```

**前端复杂查询对比**：
```tsx
// 前端需要多次API调用或复杂的状态管理
function PopularArticles() {
  const [articles, setArticles] = useState<Article[]>([]);
  const [authors, setAuthors] = useState<Map<number, User>>(new Map());
  
  useEffect(() => {
    const fetchData = async () => {
      // 1. 获取热门文章
      const articlesData = await fetch('/api/articles?minViews=100&sort=likes&limit=5');
      const articlesJson = await articlesData.json();
      
      // 2. 获取作者信息（N+1查询问题）
      const authorIds = [...new Set(articlesJson.map(a => a.authorId))];
      const authorsPromises = authorIds.map(id => 
        fetch(`/api/users/${id}`).then(r => r.json())
      );
      const authorsData = await Promise.all(authorsPromises);
      
      // 3. 构建作者映射
      const authorsMap = new Map();
      authorsData.forEach(author => authorsMap.set(author.id, author));
      
      setArticles(articlesJson);
      setAuthors(authorsMap);
    };
    
    fetchData();
  }, []);
  
  return (
    <div>
      {articles.map(article => (
        <div key={article.id}>
          <h3>{article.title}</h3>
          <p>作者: {authors.get(article.authorId)?.username}</p>
        </div>
      ))}
    </div>
  );
}
```

## 🔧 数据库迁移和同步

### 1. 自动同步 vs 迁移

#### 开发环境：自动同步
```typescript
// src/app.module.ts
TypeOrmModule.forRoot({
  // ... 其他配置
  synchronize: true,  // 自动同步实体变化到数据库
  logging: true,      // 显示SQL日志
})
```

**类比前端**：
```tsx
// 前端的热重载（类似数据库自动同步）
// 修改组件代码后自动刷新页面显示最新内容
function UserProfile({ user }: { user: User }) {
  return <div>{user.name}</div>;  // 修改这里会自动更新浏览器
}
```

#### 生产环境：迁移文件
```typescript
// 生产环境配置
TypeOrmModule.forRoot({
  // ... 其他配置
  synchronize: false,    // 禁用自动同步
  migrationsRun: true,   // 启动时运行迁移
  migrations: ['dist/migrations/*.js'],
})
```

**迁移文件示例**：
```typescript
// migrations/001-create-users-table.ts
export class CreateUsersTable1640995200000 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(new Table({
      name: 'blog_user_accounts',
      columns: [
        {
          name: 'id',
          type: 'int',
          isPrimary: true,
          isGenerated: true,
          generationStrategy: 'increment'
        },
        {
          name: 'username',
          type: 'varchar',
          length: '50'
        },
        // ... 其他字段
      ]
    }));
  }
  
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable('blog_user_accounts');
  }
}
```

**前端版本控制对比**：
```tsx
// 前端的版本控制（类似数据库迁移）
// v1.0.0 - 初始版本
interface User {
  id: number;
  name: string;
}

// v1.1.0 - 添加邮箱字段
interface User {
  id: number;
  name: string;
  email?: string;  // 新增字段，保持向后兼容
}

// 数据迁移逻辑
const migrateUserData = (oldUser: any): User => {
  return {
    ...oldUser,
    email: oldUser.email || '',  // 为老数据提供默认值
  };
};
```

## 🎯 数据验证和约束

### 1. 实体层验证
```typescript
@Entity('blog_user_accounts')
export class User {
  @PrimaryGeneratedColumn()
  id: number;
  
  @Column({ 
    length: 50,
    unique: true,
    comment: '用户名，必须唯一'
  })
  username: string;
  
  @Column({ 
    length: 100, 
    unique: true,
    comment: '邮箱地址'
  })
  email: string;
  
  @Column({
    type: 'enum',
    enum: ['active', 'inactive', 'banned'],
    default: 'active'
  })
  status: string;
}
```

### 2. DTO层验证
```typescript
// src/user/dto/create-user.dto.ts
export class CreateUserDto {
  @IsString()
  @Length(2, 50)
  username: string;
  
  @IsEmail()
  email: string;
  
  @IsString()
  @MinLength(6)
  password: string;
}
```

**前端验证对比**：
```tsx
// 前端表单验证
import { z } from 'zod';

const CreateUserSchema = z.object({
  username: z.string().min(2).max(50),
  email: z.string().email(),
  password: z.string().min(6),
});

function CreateUserForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: ''
  });
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // 前端验证
    const result = CreateUserSchema.safeParse(formData);
    if (!result.success) {
      const fieldErrors: Record<string, string> = {};
      result.error.errors.forEach(err => {
        fieldErrors[err.path[0]] = err.message;
      });
      setErrors(fieldErrors);
      return;
    }
    
    // 提交到后端
    submitUser(result.data);
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.username}
        onChange={e => setFormData({...formData, username: e.target.value})}
        placeholder="用户名"
      />
      {errors.username && <span>{errors.username}</span>}
      {/* 其他字段... */}
    </form>
  );
}
```

## 🚀 性能优化策略

### 1. 预加载关联数据
```typescript
// ❌ N+1查询问题
async getArticlesWithAuthors(): Promise<any[]> {
  const articles = await this.articleRepository.find();
  
  // 每篇文章都要查询一次作者（N+1问题）
  for (const article of articles) {
    article.author = await this.userRepository.findOne({ 
      where: { id: article.authorId } 
    });
  }
  
  return articles;
}

// ✅ 优化：预加载关联数据
async getArticlesWithAuthors(): Promise<Article[]> {
  return this.articleRepository.find({
    relations: ['author']  // 一次查询获取所有数据
  });
}
```

**前端类似优化**：
```tsx
// ❌ 前端的N+1问题
function ArticleList({ articles }: { articles: Article[] }) {
  return (
    <div>
      {articles.map(article => (
        <ArticleItem key={article.id} article={article} />
      ))}
    </div>
  );
}

function ArticleItem({ article }: { article: Article }) {
  const [author, setAuthor] = useState<User | null>(null);
  
  useEffect(() => {
    // 每个组件都发起一次请求（N+1问题）
    fetchUser(article.authorId).then(setAuthor);
  }, [article.authorId]);
  
  return (
    <div>
      <h3>{article.title}</h3>
      <p>作者: {author?.username}</p>
    </div>
  );
}

// ✅ 优化：批量获取数据
function ArticleList({ articles }: { articles: Article[] }) {
  const [authors, setAuthors] = useState<Map<number, User>>(new Map());
  
  useEffect(() => {
    // 批量获取所有作者信息
    const authorIds = [...new Set(articles.map(a => a.authorId))];
    fetchUsersBatch(authorIds).then(authorsData => {
      const authorsMap = new Map();
      authorsData.forEach(author => authorsMap.set(author.id, author));
      setAuthors(authorsMap);
    });
  }, [articles]);
  
  return (
    <div>
      {articles.map(article => (
        <ArticleItem 
          key={article.id} 
          article={article} 
          author={authors.get(article.authorId)}
        />
      ))}
    </div>
  );
}
```

### 2. 查询优化
```typescript
// 分页查询
async findArticlesPaginated(page: number, limit: number): Promise<[Article[], number]> {
  return this.articleRepository.findAndCount({
    relations: ['author'],
    order: { createdAt: 'DESC' },
    skip: (page - 1) * limit,
    take: limit
  });
}

// 索引优化
@Entity('blog_articles')
@Index(['status', 'createdAt'])  // 复合索引
export class Article {
  @Column()
  @Index()  // 单字段索引
  status: string;
  
  @CreateDateColumn()
  createdAt: Date;
}
```

## 🎓 学习要点总结

1. **ORM = 对象与数据库的桥梁**：类似前端组件与DOM的关系
2. **Repository = 数据访问层**：类似前端的API服务层
3. **Entity = 数据模型**：类似前端的TypeScript接口
4. **关系映射 = 数据关联**：后端自动处理，前端需手动管理
5. **迁移 = 数据库版本控制**：类似前端的代码版本控制

## 🔗 与前端概念对应

| 后端数据库概念 | 前端对应 | 说明 |
|-------------|---------|------|
| Entity | Interface/Type | 数据结构定义 |
| Repository | API Service | 数据操作接口 |
| Migration | Version Control | 变更管理 |
| Transaction | 状态批量更新 | 原子性操作 |
| Index | 缓存策略 | 性能优化 |
| Validation | Form Validation | 数据验证 |

掌握了数据持久化，你就理解了后端数据管理的核心！ 