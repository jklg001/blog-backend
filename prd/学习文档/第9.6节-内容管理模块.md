# ç¬¬9.6èŠ‚ å†…å®¹ç®¡ç†æ¨¡å—

> **å†…å®¹ä¸ºç‹** - ä¼ä¸šçº§å†…å®¹ç®¡ç†ç³»ç»Ÿçš„è®¾è®¡ä¸å®ç°

## ğŸ“š æœ¬èŠ‚å­¦ä¹ ç›®æ ‡

### ğŸ¯ çŸ¥è¯†ç›®æ ‡
- [ ] **æŒæ¡æ–‡ç« CRUDæ“ä½œ**ï¼šå­¦ä¼šè®¾è®¡å®Œæ•´çš„æ–‡ç« ç®¡ç†åŠŸèƒ½
- [ ] **ç†è§£åˆ†ç±»æ ‡ç­¾ç³»ç»Ÿ**ï¼šæŒæ¡å†…å®¹åˆ†ç±»å’Œæ ‡ç­¾çš„è®¾è®¡æ¨¡å¼
- [ ] **å­¦ä¼šæ–‡ä»¶ä¸Šä¼ å¤„ç†**ï¼šå®ç°å®‰å…¨çš„æ–‡ä»¶ä¸Šä¼ å’Œç®¡ç†
- [ ] **æŒæ¡å¯Œæ–‡æœ¬ç¼–è¾‘**ï¼šé›†æˆMarkdownç¼–è¾‘å™¨å’Œå†…å®¹å¤„ç†

### ğŸ› ï¸ æŠ€èƒ½ç›®æ ‡
- [ ] èƒ½å¤Ÿå®ç°å®Œæ•´çš„æ–‡ç« ç®¡ç†ç³»ç»Ÿ
- [ ] èƒ½å¤Ÿè®¾è®¡çµæ´»çš„åˆ†ç±»æ ‡ç­¾ä½“ç³»
- [ ] èƒ½å¤Ÿå¤„ç†æ–‡ä»¶ä¸Šä¼ å’Œå­˜å‚¨
- [ ] èƒ½å¤Ÿå®ç°å†…å®¹æœç´¢å’Œç­›é€‰

### â° å­¦ä¹ æ—¶é•¿
- **ç†è®ºå­¦ä¹ **ï¼š2-3å°æ—¶
- **å®è·µå¼€å‘**ï¼š4-6å°æ—¶
- **æ€»è®¡æ—¶é•¿**ï¼š6-9å°æ—¶

---

## 9.6.1 æ–‡ç« CRUDæ“ä½œå®ç°

### ğŸ“ æ–‡ç« å®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/article/entities/article.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  ManyToMany,
  OneToMany,
  JoinTable,
  Index,
} from 'typeorm';
import { User } from '../../user/entities/user.entity';
import { Category } from './category.entity';
import { Tag } from './tag.entity';
import { Comment } from '../../comment/entities/comment.entity';

export enum ArticleStatus {
  DRAFT = 'draft',
  PUBLISHED = 'published',
  ARCHIVED = 'archived',
}

@Entity('articles')
export class Article {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ length: 255 })
  @Index()
  title: string;

  @Column({ unique: true, length: 255 })
  @Index()
  slug: string;

  @Column({ type: 'text', nullable: true })
  summary: string;

  @Column({ type: 'longtext' })
  content: string;

  @Column({
    type: 'enum',
    enum: ArticleStatus,
    default: ArticleStatus.DRAFT,
  })
  @Index()
  status: ArticleStatus;

  @Column({ name: 'featured_image', nullable: true })
  featuredImage: string;

  @Column({ name: 'view_count', default: 0 })
  viewCount: number;

  @Column({ name: 'like_count', default: 0 })
  likeCount: number;

  @Column({ name: 'comment_count', default: 0 })
  commentCount: number;

  @Column({ name: 'is_featured', default: false })
  isFeatured: boolean;

  @Column({ name: 'published_at', nullable: true })
  @Index()
  publishedAt: Date;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // å…³è”å…³ç³»
  @ManyToOne(() => User, user => user.articles)
  author: User;

  @ManyToOne(() => Category, category => category.articles)
  category: Category;

  @ManyToMany(() => Tag, tag => tag.articles)
  @JoinTable({
    name: 'article_tags',
    joinColumn: { name: 'article_id' },
    inverseJoinColumn: { name: 'tag_id' },
  })
  tags: Tag[];

  @OneToMany(() => Comment, comment => comment.article)
  comments: Comment[];
}
```

### ğŸ“‹ DTOè®¾è®¡

**åˆ›å»ºsrc/modules/article/dto/create-article.dto.ts**ï¼š
```typescript
import {
  IsString,
  IsOptional,
  IsArray,
  IsUUID,
  MinLength,
  MaxLength,
  IsEnum,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';
import { ArticleStatus } from '../entities/article.entity';

export class CreateArticleDto {
  @ApiProperty({ description: 'æ–‡ç« æ ‡é¢˜' })
  @IsString()
  @MinLength(1)
  @MaxLength(255)
  title: string;

  @ApiProperty({ description: 'æ–‡ç« æ‘˜è¦', required: false })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  summary?: string;

  @ApiProperty({ description: 'æ–‡ç« å†…å®¹' })
  @IsString()
  @MinLength(1)
  content: string;

  @ApiProperty({ description: 'åˆ†ç±»ID', required: false })
  @IsOptional()
  @IsUUID()
  categoryId?: string;

  @ApiProperty({ description: 'æ ‡ç­¾IDåˆ—è¡¨', required: false })
  @IsOptional()
  @IsArray()
  @IsUUID('4', { each: true })
  tagIds?: string[];

  @ApiProperty({ description: 'ç‰¹è‰²å›¾ç‰‡URL', required: false })
  @IsOptional()
  @IsString()
  featuredImage?: string;

  @ApiProperty({ description: 'æ–‡ç« çŠ¶æ€', enum: ArticleStatus })
  @IsEnum(ArticleStatus)
  status: ArticleStatus;
}
```

### ğŸ› ï¸ æ–‡ç« æœåŠ¡å®ç°

**åˆ›å»ºsrc/modules/article/article.service.ts**ï¼š
```typescript
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Article, ArticleStatus } from './entities/article.entity';
import { Category } from './entities/category.entity';
import { Tag } from './entities/tag.entity';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';
import { QueryArticleDto } from './dto/query-article.dto';

@Injectable()
export class ArticleService {
  constructor(
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
    @InjectRepository(Category)
    private readonly categoryRepository: Repository<Category>,
    @InjectRepository(Tag)
    private readonly tagRepository: Repository<Tag>,
  ) {}

  /**
   * åˆ›å»ºæ–‡ç« 
   */
  async create(createArticleDto: CreateArticleDto, authorId: string) {
    const { categoryId, tagIds, ...articleData } = createArticleDto;

    // ç”ŸæˆURLåˆ«å
    const slug = await this.generateSlug(articleData.title);

    // è·å–åˆ†ç±»
    let category = null;
    if (categoryId) {
      category = await this.categoryRepository.findOne({
        where: { id: categoryId },
      });
    }

    // è·å–æ ‡ç­¾
    let tags = [];
    if (tagIds && tagIds.length > 0) {
      tags = await this.tagRepository.findByIds(tagIds);
    }

    const article = this.articleRepository.create({
      ...articleData,
      slug,
      author: { id: authorId },
      category,
      tags,
      publishedAt: articleData.status === ArticleStatus.PUBLISHED ? new Date() : null,
    });

    return this.articleRepository.save(article);
  }

  /**
   * æŸ¥è¯¢æ–‡ç« åˆ—è¡¨
   */
  async findAll(queryDto: QueryArticleDto) {
    const {
      page = 1,
      limit = 20,
      status,
      categoryId,
      tagId,
      authorId,
      search,
      sortBy = 'createdAt',
      sortOrder = 'DESC',
    } = queryDto;

    const queryBuilder = this.articleRepository
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')
      .leftJoinAndSelect('article.category', 'category')
      .leftJoinAndSelect('article.tags', 'tags');

    // çŠ¶æ€ç­›é€‰
    if (status) {
      queryBuilder.andWhere('article.status = :status', { status });
    }

    // åˆ†ç±»ç­›é€‰
    if (categoryId) {
      queryBuilder.andWhere('article.categoryId = :categoryId', { categoryId });
    }

    // æ ‡ç­¾ç­›é€‰
    if (tagId) {
      queryBuilder.andWhere('tags.id = :tagId', { tagId });
    }

    // ä½œè€…ç­›é€‰
    if (authorId) {
      queryBuilder.andWhere('article.authorId = :authorId', { authorId });
    }

    // æœç´¢
    if (search) {
      queryBuilder.andWhere(
        '(article.title LIKE :search OR article.content LIKE :search)',
        { search: `%${search}%` }
      );
    }

    // æ’åº
    queryBuilder.orderBy(`article.${sortBy}`, sortOrder as 'ASC' | 'DESC');

    // åˆ†é¡µ
    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    const [items, total] = await queryBuilder.getManyAndCount();

    return {
      items,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  /**
   * è·å–æ–‡ç« è¯¦æƒ…
   */
  async findOne(id: string) {
    const article = await this.articleRepository.findOne({
      where: { id },
      relations: ['author', 'category', 'tags'],
    });

    if (!article) {
      throw new NotFoundException('æ–‡ç« ä¸å­˜åœ¨');
    }

    // å¢åŠ æµè§ˆé‡
    await this.articleRepository.increment({ id }, 'viewCount', 1);

    return article;
  }

  /**
   * æ›´æ–°æ–‡ç« 
   */
  async update(id: string, updateArticleDto: UpdateArticleDto, userId: string) {
    const article = await this.findOne(id);

    // æƒé™æ£€æŸ¥
    if (article.author.id !== userId) {
      throw new ForbiddenException('æ— æƒé™ä¿®æ”¹æ­¤æ–‡ç« ');
    }

    const { categoryId, tagIds, ...updateData } = updateArticleDto;

    // æ›´æ–°åˆ†ç±»
    if (categoryId !== undefined) {
      if (categoryId) {
        const category = await this.categoryRepository.findOne({
          where: { id: categoryId },
        });
        article.category = category;
      } else {
        article.category = null;
      }
    }

    // æ›´æ–°æ ‡ç­¾
    if (tagIds !== undefined) {
      if (tagIds.length > 0) {
        const tags = await this.tagRepository.findByIds(tagIds);
        article.tags = tags;
      } else {
        article.tags = [];
      }
    }

    // æ›´æ–°å‘å¸ƒæ—¶é—´
    if (updateData.status === ArticleStatus.PUBLISHED && !article.publishedAt) {
      updateData.publishedAt = new Date();
    }

    Object.assign(article, updateData);
    return this.articleRepository.save(article);
  }

  /**
   * åˆ é™¤æ–‡ç« 
   */
  async remove(id: string, userId: string) {
    const article = await this.findOne(id);

    // æƒé™æ£€æŸ¥
    if (article.author.id !== userId) {
      throw new ForbiddenException('æ— æƒé™åˆ é™¤æ­¤æ–‡ç« ');
    }

    await this.articleRepository.remove(article);
    return { message: 'æ–‡ç« åˆ é™¤æˆåŠŸ' };
  }

  /**
   * ç”ŸæˆURLåˆ«å
   */
  private async generateSlug(title: string): Promise<string> {
    let baseSlug = title
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');

    let slug = baseSlug;
    let counter = 1;

    while (await this.articleRepository.findOne({ where: { slug } })) {
      slug = `${baseSlug}-${counter}`;
      counter++;
    }

    return slug;
  }
}
```

---

## 9.6.2 åˆ†ç±»æ ‡ç­¾ç³»ç»Ÿè®¾è®¡

### ğŸ·ï¸ åˆ†ç±»å®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/article/entities/category.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  ManyToOne,
  Tree,
  TreeChildren,
  TreeParent,
} from 'typeorm';
import { Article } from './article.entity';

@Entity('categories')
@Tree('closure-table')
export class Category {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true, length: 100 })
  name: string;

  @Column({ unique: true, length: 100 })
  slug: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({ name: 'sort_order', default: 0 })
  sortOrder: number;

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @Column({ name: 'article_count', default: 0 })
  articleCount: number;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // æ ‘å½¢ç»“æ„
  @TreeChildren()
  children: Category[];

  @TreeParent()
  parent: Category;

  // å…³è”æ–‡ç« 
  @OneToMany(() => Article, article => article.category)
  articles: Article[];
}
```

### ğŸ·ï¸ æ ‡ç­¾å®ä½“è®¾è®¡

**åˆ›å»ºsrc/modules/article/entities/tag.entity.ts**ï¼š
```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
} from 'typeorm';
import { Article } from './article.entity';

@Entity('tags')
export class Tag {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true, length: 50 })
  name: string;

  @Column({ unique: true, length: 50 })
  slug: string;

  @Column({ type: 'text', nullable: true })
  description: string;

  @Column({ length: 7, default: '#007bff' })
  color: string;

  @Column({ name: 'usage_count', default: 0 })
  usageCount: number;

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  @ManyToMany(() => Article, article => article.tags)
  articles: Article[];
}
```

### ğŸ› ï¸ åˆ†ç±»æ ‡ç­¾æœåŠ¡

**åˆ›å»ºsrc/modules/article/category.service.ts**ï¼š
```typescript
@Injectable()
export class CategoryService {
  constructor(
    @InjectRepository(Category)
    private readonly categoryRepository: Repository<Category>,
  ) {}

  async create(createCategoryDto: CreateCategoryDto) {
    const slug = this.generateSlug(createCategoryDto.name);
    
    const category = this.categoryRepository.create({
      ...createCategoryDto,
      slug,
    });

    return this.categoryRepository.save(category);
  }

  async findAll() {
    return this.categoryRepository.findTrees();
  }

  async findOne(id: string) {
    const category = await this.categoryRepository.findOne({
      where: { id },
      relations: ['children', 'parent'],
    });

    if (!category) {
      throw new NotFoundException('åˆ†ç±»ä¸å­˜åœ¨');
    }

    return category;
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }
}
```

---

## 9.6.3 æ–‡ä»¶ä¸Šä¼ å¤„ç†

### ğŸ“ æ–‡ä»¶ä¸Šä¼ é…ç½®

**åˆ›å»ºsrc/modules/upload/upload.module.ts**ï¼š
```typescript
import { Module } from '@nestjs/common';
import { MulterModule } from '@nestjs/platform-express';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { diskStorage } from 'multer';
import { extname } from 'path';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';

@Module({
  imports: [
    MulterModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (configService: ConfigService) => ({
        storage: diskStorage({
          destination: configService.get<string>('upload.dest'),
          filename: (req, file, callback) => {
            const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
            const ext = extname(file.originalname);
            callback(null, `${file.fieldname}-${uniqueSuffix}${ext}`);
          },
        }),
        fileFilter: (req, file, callback) => {
          const allowedTypes = /jpeg|jpg|png|gif|webp/;
          const extName = allowedTypes.test(extname(file.originalname).toLowerCase());
          const mimeType = allowedTypes.test(file.mimetype);
          
          if (mimeType && extName) {
            return callback(null, true);
          } else {
            callback(new Error('åªå…è®¸ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶'), false);
          }
        },
        limits: {
          fileSize: configService.get<number>('upload.maxFileSize'),
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [UploadController],
  providers: [UploadService],
})
export class UploadModule {}
```

### ğŸ“¤ ä¸Šä¼ æ§åˆ¶å™¨

**åˆ›å»ºsrc/modules/upload/upload.controller.ts**ï¼š
```typescript
import {
  Controller,
  Post,
  UseInterceptors,
  UploadedFile,
  UseGuards,
  BadRequestException,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { AuthGuard } from '@nestjs/passport';
import { ApiTags, ApiOperation, ApiConsumes, ApiBody } from '@nestjs/swagger';
import { UploadService } from './upload.service';

@ApiTags('æ–‡ä»¶ä¸Šä¼ ')
@Controller('upload')
@UseGuards(AuthGuard('jwt'))
export class UploadController {
  constructor(private readonly uploadService: UploadService) {}

  @Post('image')
  @UseInterceptors(FileInterceptor('file'))
  @ApiOperation({ summary: 'ä¸Šä¼ å›¾ç‰‡' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          format: 'binary',
        },
      },
    },
  })
  async uploadImage(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶');
    }

    const result = await this.uploadService.saveFile(file);
    
    return {
      success: true,
      message: 'æ–‡ä»¶ä¸Šä¼ æˆåŠŸ',
      data: result,
    };
  }
}
```

---

## 9.6.4 å¯Œæ–‡æœ¬ç¼–è¾‘å™¨é›†æˆ

### âœï¸ Markdownç¼–è¾‘å™¨æ”¯æŒ

**åˆ›å»ºsrc/shared/utils/markdown.util.ts**ï¼š
```typescript
import * as marked from 'marked';
import * as DOMPurify from 'dompurify';

export class MarkdownUtil {
  private static renderer = new marked.Renderer();

  static {
    // é…ç½®markedé€‰é¡¹
    marked.setOptions({
      renderer: this.renderer,
      highlight: function(code, lang) {
        // è¿™é‡Œå¯ä»¥é›†æˆä»£ç é«˜äº®åº“
        return code;
      },
      pedantic: false,
      gfm: true,
      breaks: false,
      sanitize: false,
      smartLists: true,
      smartypants: false,
      xhtml: false,
    });
  }

  /**
   * Markdownè½¬HTML
   */
  static toHtml(markdown: string): string {
    const html = marked(markdown);
    return DOMPurify.sanitize(html);
  }

  /**
   * æå–æ‘˜è¦
   */
  static extractSummary(markdown: string, maxLength: number = 200): string {
    const text = markdown
      .replace(/#{1,6}\s+/g, '') // ç§»é™¤æ ‡é¢˜æ ‡è®°
      .replace(/\*\*(.*?)\*\*/g, '$1') // ç§»é™¤ç²—ä½“æ ‡è®°
      .replace(/\*(.*?)\*/g, '$1') // ç§»é™¤æ–œä½“æ ‡è®°
      .replace(/\[(.*?)\]\(.*?\)/g, '$1') // ç§»é™¤é“¾æ¥ï¼Œä¿ç•™æ–‡æœ¬
      .replace(/```[\s\S]*?```/g, '') // ç§»é™¤ä»£ç å—
      .replace(/`(.*?)`/g, '$1') // ç§»é™¤è¡Œå†…ä»£ç æ ‡è®°
      .replace(/\n+/g, ' ') // æ›¿æ¢æ¢è¡Œä¸ºç©ºæ ¼
      .trim();

    return text.length > maxLength 
      ? text.substring(0, maxLength) + '...' 
      : text;
  }

  /**
   * è®¡ç®—é˜…è¯»æ—¶é—´
   */
  static calculateReadingTime(content: string): number {
    const wordsPerMinute = 200; // å¹³å‡é˜…è¯»é€Ÿåº¦
    const words = content.split(/\s+/).length;
    return Math.ceil(words / wordsPerMinute);
  }
}
```

### ğŸ“Š å†…å®¹ç»Ÿè®¡æœåŠ¡

**åˆ›å»ºsrc/modules/article/article-stats.service.ts**ï¼š
```typescript
@Injectable()
export class ArticleStatsService {
  constructor(
    @InjectRepository(Article)
    private readonly articleRepository: Repository<Article>,
  ) {}

  /**
   * è·å–æ–‡ç« ç»Ÿè®¡ä¿¡æ¯
   */
  async getStats() {
    const [
      totalArticles,
      publishedArticles,
      draftArticles,
      totalViews,
    ] = await Promise.all([
      this.articleRepository.count(),
      this.articleRepository.count({ where: { status: ArticleStatus.PUBLISHED } }),
      this.articleRepository.count({ where: { status: ArticleStatus.DRAFT } }),
      this.articleRepository
        .createQueryBuilder('article')
        .select('SUM(article.viewCount)', 'total')
        .getRawOne(),
    ]);

    return {
      totalArticles,
      publishedArticles,
      draftArticles,
      totalViews: parseInt(totalViews.total) || 0,
    };
  }

  /**
   * è·å–çƒ­é—¨æ–‡ç« 
   */
  async getPopularArticles(limit: number = 10) {
    return this.articleRepository.find({
      where: { status: ArticleStatus.PUBLISHED },
      order: { viewCount: 'DESC' },
      take: limit,
      relations: ['author', 'category'],
    });
  }
}
```

---

## ğŸ“Š æœ¬èŠ‚æ€»ç»“

### ğŸ¯ å…³é”®è¦ç‚¹å›é¡¾

1. **æ–‡ç« ç®¡ç†è¦åŠŸèƒ½å®Œæ•´**
   - æ”¯æŒCRUDæ“ä½œå’ŒçŠ¶æ€ç®¡ç†
   - å®ç°æƒé™æ§åˆ¶å’Œæ•°æ®éªŒè¯
   - æä¾›æœç´¢å’Œç­›é€‰åŠŸèƒ½

2. **åˆ†ç±»æ ‡ç­¾è¦çµæ´»è®¾è®¡**
   - æ”¯æŒæ ‘å½¢åˆ†ç±»ç»“æ„
   - æ ‡ç­¾ç³»ç»Ÿä¾¿äºå†…å®¹ç»„ç»‡
   - ç»Ÿè®¡ä¿¡æ¯è¾…åŠ©ç®¡ç†

3. **æ–‡ä»¶ä¸Šä¼ è¦å®‰å…¨å¯é **
   - æ–‡ä»¶ç±»å‹å’Œå¤§å°é™åˆ¶
   - å®‰å…¨çš„å­˜å‚¨è·¯å¾„
   - é”™è¯¯å¤„ç†å’ŒéªŒè¯

4. **å†…å®¹ç¼–è¾‘è¦ç”¨æˆ·å‹å¥½**
   - Markdownç¼–è¾‘å™¨æ”¯æŒ
   - å†…å®¹é¢„å¤„ç†å’Œç»Ÿè®¡
   - å¯Œæ–‡æœ¬åŠŸèƒ½é›†æˆ

### ğŸ“ å®è·µç»ƒä¹ 

#### ç»ƒä¹ 1ï¼šå®Œæ•´æ–‡ç« ç³»ç»Ÿ
**ä»»åŠ¡**ï¼šå®ç°å®Œæ•´çš„æ–‡ç« ç®¡ç†åŠŸèƒ½
**è¦æ±‚**ï¼š
- å®ç°æ–‡ç« CRUDæ“ä½œ
- æ·»åŠ åˆ†ç±»æ ‡ç­¾åŠŸèƒ½
- å®ç°æœç´¢å’Œç­›é€‰
- æ·»åŠ æƒé™æ§åˆ¶

#### ç»ƒä¹ 2ï¼šæ–‡ä»¶ä¸Šä¼ ç³»ç»Ÿ
**ä»»åŠ¡**ï¼šå®ç°å®‰å…¨çš„æ–‡ä»¶ä¸Šä¼ 
**è¦æ±‚**ï¼š
- é…ç½®æ–‡ä»¶ä¸Šä¼ ä¸­é—´ä»¶
- å®ç°æ–‡ä»¶ç±»å‹éªŒè¯
- æ·»åŠ æ–‡ä»¶å¤§å°é™åˆ¶
- å®ç°æ–‡ä»¶ç®¡ç†åŠŸèƒ½

### ğŸ” è‡ªæˆ‘æ£€æµ‹

- [ ] æˆ‘èƒ½å¤Ÿå®ç°å®Œæ•´çš„æ–‡ç« ç®¡ç†åŠŸèƒ½
- [ ] æˆ‘ç†è§£åˆ†ç±»æ ‡ç­¾ç³»ç»Ÿçš„è®¾è®¡
- [ ] æˆ‘æŒæ¡äº†æ–‡ä»¶ä¸Šä¼ çš„å¤„ç†æ–¹æ³•
- [ ] æˆ‘äº†è§£Markdownç¼–è¾‘å™¨çš„é›†æˆ

### ğŸ¯ ä¸‹ä¸€æ­¥å­¦ä¹ 

å®Œæˆæœ¬èŠ‚å­¦ä¹ åï¼Œä½ å·²ç»æŒæ¡äº†ï¼š
- âœ… æ–‡ç« CRUDæ“ä½œå®ç°
- âœ… åˆ†ç±»æ ‡ç­¾ç³»ç»Ÿè®¾è®¡
- âœ… æ–‡ä»¶ä¸Šä¼ å¤„ç†
- âœ… å¯Œæ–‡æœ¬ç¼–è¾‘å™¨é›†æˆ

**å‡†å¤‡å¥½è¿›å…¥ç¬¬9.7èŠ‚äº†å—ï¼Ÿ** ğŸš€

åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å®ç°äº’åŠ¨åŠŸèƒ½æ¨¡å—ï¼ŒåŒ…æ‹¬ï¼š
- ğŸ’¬ è¯„è®ºç³»ç»Ÿå®ç°
- ğŸ‘ ç‚¹èµæ”¶è—åŠŸèƒ½
- ï¿½ï¿½ ç”¨æˆ·å…³æ³¨ç³»ç»Ÿ
- ğŸ”” é€šçŸ¥æœºåˆ¶è®¾è®¡ 