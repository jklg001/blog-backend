# ç¬¬3ç«  ä¾èµ–æ³¨å…¥åŸç†æ·±åº¦è§£æ

> **ä»æ§åˆ¶åè½¬åˆ°ä¾èµ–æ³¨å…¥** - æ·±å…¥ç†è§£ç°ä»£æ¡†æ¶çš„æ ¸å¿ƒè®¾è®¡æ¨¡å¼

## ğŸ“š æœ¬ç« å­¦ä¹ ç›®æ ‡

### ğŸ¯ çŸ¥è¯†ç›®æ ‡
- [ ] **ç†è§£IoCå®¹å™¨**ï¼šæ·±å…¥æŒæ¡æ§åˆ¶åè½¬å®¹å™¨çš„å·¥ä½œåŸç†å’Œè®¾è®¡æ€æƒ³
- [ ] **æŒæ¡DIæœºåˆ¶**ï¼šç†è§£ä¾èµ–æ³¨å…¥çš„å„ç§å®ç°æ–¹å¼å’Œåº”ç”¨åœºæ™¯
- [ ] **ç†Ÿæ‚‰è£…é¥°å™¨ç³»ç»Ÿ**ï¼šæŒæ¡NestJSè£…é¥°å™¨çš„ä½¿ç”¨å’Œè‡ªå®šä¹‰æ–¹æ³•
- [ ] **ç†è§£ç”Ÿå‘½å‘¨æœŸ**ï¼šæŒæ¡ä¾èµ–å¯¹è±¡çš„åˆ›å»ºã€ç®¡ç†å’Œé”€æ¯æœºåˆ¶
- [ ] **æŒæ¡é«˜çº§ç‰¹æ€§**ï¼šå­¦ä¼šä½¿ç”¨æ¡ä»¶æ³¨å…¥ã€åŠ¨æ€æ¨¡å—ç­‰é«˜çº§åŠŸèƒ½

### ğŸ› ï¸ æŠ€èƒ½ç›®æ ‡
- [ ] èƒ½å¤Ÿè®¾è®¡å’Œå®ç°è‡ªå®šä¹‰çš„ä¾èµ–æ³¨å…¥å®¹å™¨
- [ ] èƒ½å¤Ÿæ­£ç¡®é…ç½®å’Œä½¿ç”¨NestJSçš„ä¾èµ–æ³¨å…¥ç³»ç»Ÿ
- [ ] èƒ½å¤Ÿå¤„ç†å¤æ‚çš„ä¾èµ–å…³ç³»å’Œå¾ªç¯ä¾èµ–é—®é¢˜
- [ ] èƒ½å¤Ÿä¼˜åŒ–ä¾èµ–æ³¨å…¥çš„æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨

### â° å­¦ä¹ æ—¶é•¿
- **ç†è®ºå­¦ä¹ **ï¼š5-6å°æ—¶
- **å®è·µç»ƒä¹ **ï¼š6-7å°æ—¶
- **é¡¹ç›®å®æˆ˜**ï¼š2-3å°æ—¶
- **æ€»è®¡æ—¶é•¿**ï¼š13-16å°æ—¶

### ğŸ“‹ å‰ç½®çŸ¥è¯†æ£€æŸ¥
åœ¨å¼€å§‹æœ¬ç« å­¦ä¹ å‰ï¼Œè¯·ç¡®ä¿æ‚¨å·²æŒæ¡ä»¥ä¸‹çŸ¥è¯†ï¼š
- [ ] ç¬¬1ç« ï¼šåç«¯æ¶æ„æ€ç»´å¯¼å¼•ï¼ˆå¿…é¡»å®Œæˆï¼‰
- [ ] ç¬¬2ç« ï¼šNestJSæ¨¡å—ç³»ç»Ÿè¯¦è§£ï¼ˆå¿…é¡»å®Œæˆï¼‰
- [ ] TypeScriptè£…é¥°å™¨è¯­æ³•å’Œå…ƒæ•°æ®åå°„
- [ ] é¢å‘å¯¹è±¡ç¼–ç¨‹çš„é«˜çº§æ¦‚å¿µï¼ˆæ¥å£ã€æŠ½è±¡ç±»ã€æ³›å‹ï¼‰
- [ ] è®¾è®¡æ¨¡å¼åŸºç¡€ï¼ˆå·¥å‚æ¨¡å¼ã€å•ä¾‹æ¨¡å¼ï¼‰

---

## 3.1 æ§åˆ¶åè½¬ï¼ˆIoCï¼‰åŸºç¡€

### 3.1.1 ä»€ä¹ˆæ˜¯æ§åˆ¶åè½¬ï¼Ÿ

#### ğŸ’¡ é€šä¿—æ˜“æ‡‚çš„å®šä¹‰

**æ§åˆ¶åè½¬å°±åƒé¤å…ç”¨é¤æ¨¡å¼çš„è½¬å˜**ï¼š

**ä¼ ç»Ÿæ¨¡å¼ï¼ˆè‡ªå·±æ§åˆ¶ï¼‰**ï¼š
- ğŸ  **åœ¨å®¶åšé¥­**ï¼šè‡ªå·±ä¹°èœã€æ´—èœã€åšé¥­ã€æ´—ç¢—
- ğŸ”§ **å…¨ç¨‹æ§åˆ¶**ï¼šæ¯ä¸ªæ­¥éª¤éƒ½è¦è‡ªå·±ç®¡ç†
- ğŸ˜° **è´£ä»»é‡å¤§**ï¼šå‡ºé—®é¢˜è¦è‡ªå·±è§£å†³

**æ§åˆ¶åè½¬æ¨¡å¼ï¼ˆäº¤ç»™ä¸“ä¸šçš„ï¼‰**ï¼š
- ğŸ½ï¸ **é¤å…ç”¨é¤**ï¼šåªéœ€è¦ç‚¹èœï¼Œå¨å¸ˆè´Ÿè´£åˆ¶ä½œ
- ğŸ¯ **ä¸“æ³¨æ ¸å¿ƒ**ï¼šåªå…³å¿ƒåƒä»€ä¹ˆï¼Œä¸å…³å¿ƒæ€ä¹ˆåš
- ğŸ›¡ï¸ **ä¸“ä¸šä¿éšœ**ï¼šå¨å¸ˆè´Ÿè´£é£Ÿç‰©è´¨é‡

#### ğŸ¯ IoCæ ¸å¿ƒæ¦‚å¿µå›¾è§£

```mermaid
mindmap
  root((æ§åˆ¶åè½¬IoC))
    ä¼ ç»Ÿæ¨¡å¼
      å¯¹è±¡è‡ªå·±åˆ›å»ºä¾èµ–
        newå…³é”®å­—ç›´æ¥åˆ›å»º
        ç¡¬ç¼–ç ä¾èµ–å…³ç³»
        ç´§è€¦åˆè®¾è®¡
        éš¾ä»¥æµ‹è¯•å’Œç»´æŠ¤
      æ§åˆ¶æƒåœ¨å¯¹è±¡å†…éƒ¨
        å¯¹è±¡å†³å®šä½¿ç”¨ä»€ä¹ˆä¾èµ–
        å¯¹è±¡ç®¡ç†ä¾èµ–ç”Ÿå‘½å‘¨æœŸ
        å¯¹è±¡è´Ÿè´£ä¾èµ–é…ç½®
        å¯¹è±¡æ‰¿æ‹…æ‰€æœ‰è´£ä»»
    IoCæ¨¡å¼
      å®¹å™¨åˆ›å»ºå’Œç®¡ç†ä¾èµ–
        å®¹å™¨è´Ÿè´£å¯¹è±¡åˆ›å»º
        å®¹å™¨ç®¡ç†å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ
        å®¹å™¨å¤„ç†ä¾èµ–å…³ç³»
        å®¹å™¨æä¾›é…ç½®ç®¡ç†
      æ§åˆ¶æƒè½¬ç§»åˆ°å¤–éƒ¨
        å¤–éƒ¨å®¹å™¨æ§åˆ¶ä¾èµ–
        å¯¹è±¡è¢«åŠ¨æ¥æ”¶ä¾èµ–
        æ¾è€¦åˆè®¾è®¡
        æ˜“äºæµ‹è¯•å’Œæ‰©å±•
    å®ç°æ–¹å¼
      ä¾èµ–æ³¨å…¥DI
        æ„é€ å‡½æ•°æ³¨å…¥
        å±æ€§æ³¨å…¥
        æ–¹æ³•æ³¨å…¥
        æ¥å£æ³¨å…¥
      æœåŠ¡å®šä½å™¨
        ä¸»åŠ¨æŸ¥æ‰¾æœåŠ¡
        æ³¨å†ŒæœåŠ¡æ˜ å°„
        è¿è¡Œæ—¶è§£æ
        é›†ä¸­å¼ç®¡ç†
      å·¥å‚æ¨¡å¼
        å·¥å‚åˆ›å»ºå¯¹è±¡
        éšè—åˆ›å»ºé€»è¾‘
        ç»Ÿä¸€åˆ›å»ºæ¥å£
        æ”¯æŒå¤šç§å®ç°
```

#### ğŸŒ ç°å®åº”ç”¨åœºæ™¯ä¸¾ä¾‹

**åœºæ™¯1ï¼šç”µå•†è®¢å•å¤„ç†ç³»ç»Ÿ**

**ä¼ ç»Ÿæ–¹å¼ï¼ˆæ²¡æœ‰IoCï¼‰**ï¼š
```typescript
// âŒ ç´§è€¦åˆçš„è®¾è®¡
class OrderService {
  private paymentService: PaymentService;
  private inventoryService: InventoryService;
  private emailService: EmailService;
  
  constructor() {
    // ç¡¬ç¼–ç ä¾èµ–åˆ›å»º
    this.paymentService = new PaymentService();
    this.inventoryService = new InventoryService();
    this.emailService = new EmailService();
  }
  
  async processOrder(order: Order): Promise<void> {
    // ä¸šåŠ¡é€»è¾‘...
  }
}

// é—®é¢˜ï¼š
// 1. éš¾ä»¥æµ‹è¯•ï¼ˆæ— æ³•mockä¾èµ–ï¼‰
// 2. éš¾ä»¥æ‰©å±•ï¼ˆæ›´æ¢å®ç°éœ€è¦ä¿®æ”¹ä»£ç ï¼‰
// 3. è¿åå¼€é—­åŸåˆ™
// 4. ä¾èµ–å…³ç³»å¤æ‚æ—¶éš¾ä»¥ç®¡ç†
```

**IoCæ–¹å¼ï¼ˆæ§åˆ¶åè½¬ï¼‰**ï¼š
```typescript
// âœ… æ¾è€¦åˆçš„è®¾è®¡
interface IPaymentService {
  processPayment(amount: number): Promise<boolean>;
}

interface IInventoryService {
  checkStock(productId: string): Promise<boolean>;
  reserveStock(productId: string, quantity: number): Promise<void>;
}

interface IEmailService {
  sendOrderConfirmation(email: string, order: Order): Promise<void>;
}

@Injectable()
class OrderService {
  constructor(
    private paymentService: IPaymentService,      // ä¾èµ–æ³¨å…¥
    private inventoryService: IInventoryService,  // ä¾èµ–æ³¨å…¥
    private emailService: IEmailService          // ä¾èµ–æ³¨å…¥
  ) {}
  
  async processOrder(order: Order): Promise<void> {
    // 1. æ£€æŸ¥åº“å­˜
    const hasStock = await this.inventoryService.checkStock(order.productId);
    if (!hasStock) {
      throw new Error('åº“å­˜ä¸è¶³');
    }
    
    // 2. å¤„ç†æ”¯ä»˜
    const paymentSuccess = await this.paymentService.processPayment(order.amount);
    if (!paymentSuccess) {
      throw new Error('æ”¯ä»˜å¤±è´¥');
    }
    
    // 3. é¢„ç•™åº“å­˜
    await this.inventoryService.reserveStock(order.productId, order.quantity);
    
    // 4. å‘é€ç¡®è®¤é‚®ä»¶
    await this.emailService.sendOrderConfirmation(order.customerEmail, order);
  }
}

// ä¼˜åŠ¿ï¼š
// 1. æ˜“äºæµ‹è¯•ï¼ˆå¯ä»¥æ³¨å…¥mockå¯¹è±¡ï¼‰
// 2. æ˜“äºæ‰©å±•ï¼ˆå¯ä»¥æ³¨å…¥ä¸åŒçš„å®ç°ï¼‰
// 3. ç¬¦åˆSOLIDåŸåˆ™
// 4. ä¾èµ–å…³ç³»æ¸…æ™°æ˜ç¡®
```

**åœºæ™¯2ï¼šæ—¥å¿—ç³»ç»Ÿçš„æ¼”è¿›**

**é˜¶æ®µ1ï¼šç¡¬ç¼–ç æ—¥å¿—**
```typescript
class UserService {
  async createUser(userData: CreateUserDto): Promise<User> {
    // ç¡¬ç¼–ç æ—¥å¿—è¾“å‡º
    console.log(`Creating user: ${userData.email}`);
    
    const user = await this.userRepository.save(userData);
    
    console.log(`User created with ID: ${user.id}`);
    return user;
  }
}
```

**é˜¶æ®µ2ï¼šIoCæ—¥å¿—ç³»ç»Ÿ**
```typescript
interface ILogger {
  log(message: string, context?: string): void;
  error(message: string, error?: Error): void;
  warn(message: string): void;
  debug(message: string): void;
}

@Injectable()
class ConsoleLogger implements ILogger {
  log(message: string, context?: string): void {
    console.log(`[${context || 'APP'}] ${message}`);
  }
  
  error(message: string, error?: Error): void {
    console.error(`[ERROR] ${message}`, error);
  }
  
  warn(message: string): void {
    console.warn(`[WARN] ${message}`);
  }
  
  debug(message: string): void {
    console.debug(`[DEBUG] ${message}`);
  }
}

@Injectable()
class FileLogger implements ILogger {
  log(message: string, context?: string): void {
    // å†™å…¥æ–‡ä»¶é€»è¾‘
    this.writeToFile(`[${context || 'APP'}] ${message}`);
  }
  
  // ... å…¶ä»–æ–¹æ³•å®ç°
  
  private writeToFile(message: string): void {
    // æ–‡ä»¶å†™å…¥å®ç°
  }
}

@Injectable()
class UserService {
  constructor(
    private userRepository: UserRepository,
    private logger: ILogger  // æ³¨å…¥æ—¥å¿—æœåŠ¡
  ) {}
  
  async createUser(userData: CreateUserDto): Promise<User> {
    this.logger.log(`Creating user: ${userData.email}`, 'UserService');
    
    try {
      const user = await this.userRepository.save(userData);
      this.logger.log(`User created with ID: ${user.id}`, 'UserService');
      return user;
    } catch (error) {
      this.logger.error(`Failed to create user: ${userData.email}`, error);
      throw error;
    }
  }
}
```

**åœºæ™¯3ï¼šæ•°æ®åº“è¿æ¥ç®¡ç†**

```typescript
// ä¼ ç»Ÿæ–¹å¼ï¼šæ¯ä¸ªæœåŠ¡è‡ªå·±ç®¡ç†æ•°æ®åº“è¿æ¥
class UserService {
  private connection: DatabaseConnection;
  
  constructor() {
    // æ¯ä¸ªæœåŠ¡éƒ½è¦è‡ªå·±åˆ›å»ºè¿æ¥
    this.connection = new DatabaseConnection({
      host: 'localhost',
      port: 5432,
      database: 'myapp',
      username: 'user',
      password: 'password'
    });
  }
}

// IoCæ–¹å¼ï¼šç»Ÿä¸€ç®¡ç†æ•°æ®åº“è¿æ¥
@Injectable()
class DatabaseService {
  private connection: DatabaseConnection;
  
  constructor(@Inject('DATABASE_CONFIG') private config: DatabaseConfig) {
    this.connection = new DatabaseConnection(config);
  }
  
  getConnection(): DatabaseConnection {
    return this.connection;
  }
}

@Injectable()
class UserService {
  constructor(private databaseService: DatabaseService) {}
  
  async findUser(id: string): Promise<User> {
    const connection = this.databaseService.getConnection();
    return connection.query('SELECT * FROM users WHERE id = $1', [id]);
  }
}
```

#### ğŸ” æ·±åº¦è§£æ

**IoCçš„æ ¸å¿ƒä»·å€¼**ï¼š

1. **é™ä½è€¦åˆåº¦**ï¼š
   - å¯¹è±¡ä¸å†ç›´æ¥ä¾èµ–å…·ä½“å®ç°
   - é€šè¿‡æ¥å£æˆ–æŠ½è±¡ç±»å®šä¹‰å¥‘çº¦
   - å®ç°å¯ä»¥éšæ—¶æ›¿æ¢è€Œä¸å½±å“ä½¿ç”¨æ–¹

2. **æé«˜å¯æµ‹è¯•æ€§**ï¼š
   - å¯ä»¥è½»æ¾æ³¨å…¥Mockå¯¹è±¡è¿›è¡Œå•å…ƒæµ‹è¯•
   - æµ‹è¯•æ—¶å¯ä»¥éš”ç¦»å¤–éƒ¨ä¾èµ–
   - æ”¯æŒæµ‹è¯•é©±åŠ¨å¼€å‘ï¼ˆTDDï¼‰

3. **å¢å¼ºå¯æ‰©å±•æ€§**ï¼š
   - æ–°åŠŸèƒ½å¯ä»¥é€šè¿‡æ–°çš„å®ç°ç±»æ·»åŠ 
   - ä¸éœ€è¦ä¿®æ”¹ç°æœ‰ä»£ç 
   - ç¬¦åˆå¼€é—­åŸåˆ™

4. **ç®€åŒ–é…ç½®ç®¡ç†**ï¼š
   - é›†ä¸­ç®¡ç†å¯¹è±¡çš„åˆ›å»ºå’Œé…ç½®
   - æ”¯æŒç¯å¢ƒç›¸å…³çš„é…ç½®åˆ‡æ¢
   - å‡å°‘é‡å¤çš„é…ç½®ä»£ç 

### 3.1.2 ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰è¯¦è§£

#### ğŸ—ï¸ ä¾èµ–æ³¨å…¥çš„å››ç§æ–¹å¼

##### 1ï¸âƒ£ æ„é€ å‡½æ•°æ³¨å…¥ï¼ˆConstructor Injectionï¼‰

**å®šä¹‰**ï¼šé€šè¿‡æ„é€ å‡½æ•°å‚æ•°ä¼ å…¥ä¾èµ–å¯¹è±¡ã€‚

**ä¼˜ç‚¹**ï¼š
- ä¾èµ–å…³ç³»æ˜ç¡®ï¼Œåœ¨å¯¹è±¡åˆ›å»ºæ—¶å°±ç¡®å®š
- ä¿è¯å¯¹è±¡åˆ›å»ºåä¾èµ–å®Œæ•´å¯ç”¨
- æ”¯æŒä¸å¯å˜å¯¹è±¡è®¾è®¡
- ä¾¿äºè¿›è¡Œä¾èµ–éªŒè¯

**å®ç°ç¤ºä¾‹**ï¼š
```typescript
interface IEmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>;
}

interface IUserRepository {
  save(user: User): Promise<User>;
  findByEmail(email: string): Promise<User | null>;
}

@Injectable()
class UserService {
  // æ„é€ å‡½æ•°æ³¨å…¥ - NestJSæ¨èæ–¹å¼
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailService: IEmailService,
    private readonly logger: ILogger
  ) {
    // å¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­è¿›è¡Œä¾èµ–éªŒè¯
    if (!userRepository) {
      throw new Error('UserRepository is required');
    }
    if (!emailService) {
      throw new Error('EmailService is required');
    }
  }
  
  async registerUser(userData: CreateUserDto): Promise<User> {
    // ä¾èµ–å·²ç»åœ¨æ„é€ æ—¶æ³¨å…¥ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨
    this.logger.log(`Registering user: ${userData.email}`);
    
    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
    const existingUser = await this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new ConflictException('ç”¨æˆ·å·²å­˜åœ¨');
    }
    
    // åˆ›å»ºç”¨æˆ·
    const user = await this.userRepository.save(userData);
    
    // å‘é€æ¬¢è¿é‚®ä»¶
    await this.emailService.sendEmail(
      user.email,
      'æ¬¢è¿æ³¨å†Œ',
      'æ„Ÿè°¢æ‚¨çš„æ³¨å†Œï¼'
    );
    
    this.logger.log(`User registered successfully: ${user.id}`);
    return user;
  }
}
```

##### 2ï¸âƒ£ å±æ€§æ³¨å…¥ï¼ˆProperty Injectionï¼‰

**å®šä¹‰**ï¼šé€šè¿‡å¯¹è±¡å±æ€§ç›´æ¥æ³¨å…¥ä¾èµ–ã€‚

**ä¼˜ç‚¹**ï¼š
- è¯­æ³•ç®€æ´ï¼Œæ˜“äºç†è§£
- æ”¯æŒå¯é€‰ä¾èµ–
- å¯ä»¥åœ¨å¯¹è±¡åˆ›å»ºååŠ¨æ€è®¾ç½®

**ç¼ºç‚¹**ï¼š
- ä¾èµ–å…³ç³»ä¸å¤Ÿæ˜ç¡®
- å¯èƒ½å¯¼è‡´å¯¹è±¡åœ¨ä¸å®Œæ•´çŠ¶æ€ä¸‹è¢«ä½¿ç”¨
- éš¾ä»¥ä¿è¯ä¾èµ–çš„ä¸å¯å˜æ€§

**å®ç°ç¤ºä¾‹**ï¼š
```typescript
@Injectable()
class NotificationService {
  // å±æ€§æ³¨å…¥ - ä½¿ç”¨@Injectè£…é¥°å™¨
  @Inject('EMAIL_SERVICE')
  private emailService: IEmailService;
  
  @Inject('SMS_SERVICE')
  private smsService: ISmsService;
  
  // å¯é€‰ä¾èµ–
  @Optional()
  @Inject('PUSH_SERVICE')
  private pushService?: IPushService;
  
  async sendNotification(
    message: string, 
    recipient: string, 
    type: 'email' | 'sms' | 'push'
  ): Promise<void> {
    switch (type) {
      case 'email':
        await this.emailService.sendEmail(recipient, 'Notification', message);
        break;
      case 'sms':
        await this.smsService.sendSms(recipient, message);
        break;
      case 'push':
        if (this.pushService) {
          await this.pushService.sendPush(recipient, message);
        } else {
          console.warn('Push service not available');
        }
        break;
    }
  }
}
```

##### 3ï¸âƒ£ æ–¹æ³•æ³¨å…¥ï¼ˆMethod Injectionï¼‰

**å®šä¹‰**ï¼šé€šè¿‡ç‰¹å®šæ–¹æ³•æ³¨å…¥ä¾èµ–å¯¹è±¡ã€‚

**ä¼˜ç‚¹**ï¼š
- æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€æ³¨å…¥
- å¯ä»¥æ ¹æ®æ¡ä»¶é€‰æ‹©ä¸åŒçš„ä¾èµ–
- é€‚åˆå¤„ç†å¤æ‚çš„ä¾èµ–é€»è¾‘

**å®ç°ç¤ºä¾‹**ï¼š
```typescript
@Injectable()
class PaymentService {
  private paymentProviders: Map<string, IPaymentProvider> = new Map();
  
  // æ–¹æ³•æ³¨å…¥ - æ³¨å…¥å¤šä¸ªæ”¯ä»˜æä¾›å•†
  @Inject('PAYMENT_PROVIDERS')
  setPaymentProviders(providers: IPaymentProvider[]): void {
    providers.forEach(provider => {
      this.paymentProviders.set(provider.getName(), provider);
    });
  }
  
  async processPayment(
    amount: number, 
    currency: string, 
    providerName: string
  ): Promise<PaymentResult> {
    const provider = this.paymentProviders.get(providerName);
    
    if (!provider) {
      throw new Error(`Payment provider ${providerName} not found`);
    }
    
    return provider.processPayment(amount, currency);
  }
  
  getAvailableProviders(): string[] {
    return Array.from(this.paymentProviders.keys());
  }
}
```

##### 4ï¸âƒ£ æ¥å£æ³¨å…¥ï¼ˆInterface Injectionï¼‰

**å®šä¹‰**ï¼šé€šè¿‡å®ç°ç‰¹å®šæ¥å£æ¥æ¥æ”¶ä¾èµ–æ³¨å…¥ã€‚

**å®ç°ç¤ºä¾‹**ï¼š
```typescript
// å®šä¹‰æ³¨å…¥æ¥å£
interface ILoggerAware {
  setLogger(logger: ILogger): void;
}

interface ICacheAware {
  setCache(cache: ICache): void;
}

@Injectable()
class ProductService implements ILoggerAware, ICacheAware {
  private logger: ILogger;
  private cache: ICache;
  
  // å®ç°æ¥å£æ³¨å…¥æ–¹æ³•
  setLogger(logger: ILogger): void {
    this.logger = logger;
  }
  
  setCache(cache: ICache): void {
    this.cache = cache;
  }
  
  async getProduct(id: string): Promise<Product> {
    this.logger?.log(`Getting product: ${id}`);
    
    // å…ˆä»ç¼“å­˜è·å–
    const cached = await this.cache?.get(`product:${id}`);
    if (cached) {
      this.logger?.log(`Product found in cache: ${id}`);
      return cached;
    }
    
    // ä»æ•°æ®åº“è·å–
    const product = await this.productRepository.findById(id);
    
    // å­˜å…¥ç¼“å­˜
    if (product && this.cache) {
      await this.cache.set(`product:${id}`, product, 3600);
    }
    
    return product;
  }
}
```

#### ğŸ’¡ ä¾èµ–æ³¨å…¥æœ€ä½³å®è·µ

**1. ä¼˜å…ˆä½¿ç”¨æ„é€ å‡½æ•°æ³¨å…¥**
```typescript
// âœ… æ¨èï¼šæ„é€ å‡½æ•°æ³¨å…¥
@Injectable()
class UserService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly emailService: EmailService
  ) {}
}

// âŒ ä¸æ¨èï¼šå±æ€§æ³¨å…¥ï¼ˆé™¤éæœ‰ç‰¹æ®Šéœ€æ±‚ï¼‰
@Injectable()
class UserService {
  @Inject()
  private userRepository: UserRepository;
}
```

**2. ä½¿ç”¨æ¥å£å®šä¹‰ä¾èµ–å¥‘çº¦**
```typescript
// âœ… æ¨èï¼šä¾èµ–æ¥å£è€Œä¸æ˜¯å…·ä½“å®ç°
interface IEmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>;
}

@Injectable()
class UserService {
  constructor(private emailService: IEmailService) {}
}

// âŒ ä¸æ¨èï¼šç›´æ¥ä¾èµ–å…·ä½“å®ç°
@Injectable()
class UserService {
  constructor(private emailService: SmtpEmailService) {}
}
```

**3. åˆç†ä½¿ç”¨å¯é€‰ä¾èµ–**
```typescript
@Injectable()
class AnalyticsService {
  constructor(
    private eventTracker: IEventTracker,
    @Optional() private logger?: ILogger  // å¯é€‰ä¾èµ–
  ) {}
  
  trackEvent(event: string, data: any): void {
    this.eventTracker.track(event, data);
    this.logger?.log(`Event tracked: ${event}`);  // å®‰å…¨è°ƒç”¨
  }
}
```

---

## 3.2 NestJSä¾èµ–æ³¨å…¥ç³»ç»Ÿ

### 3.2.1 NestJS IoCå®¹å™¨æ¶æ„

#### ğŸ—ï¸ å®¹å™¨æ¶æ„å›¾è§£

```mermaid
graph TB
    A[NestJSåº”ç”¨] --> B[å…¨å±€å®¹å™¨]
    B --> C[æ¨¡å—å®¹å™¨1]
    B --> D[æ¨¡å—å®¹å™¨2]
    B --> E[æ¨¡å—å®¹å™¨N]
    
    C --> F[æ§åˆ¶å™¨å®ä¾‹]
    C --> G[æœåŠ¡å®ä¾‹]
    C --> H[æä¾›è€…å®ä¾‹]
    
    D --> I[æ§åˆ¶å™¨å®ä¾‹]
    D --> J[æœåŠ¡å®ä¾‹]
    D --> K[æä¾›è€…å®ä¾‹]
    
    F --> L[ä¾èµ–æ³¨å…¥]
    G --> L
    H --> L
    
    L --> M[å®ä¾‹ç¼“å­˜]
    L --> N[ç”Ÿå‘½å‘¨æœŸç®¡ç†]
    L --> O[å¾ªç¯ä¾èµ–æ£€æµ‹]
    
    style B fill:#e1f5fe
    style C fill:#e8f5e8
    style D fill:#e8f5e8
    style E fill:#e8f5e8
    style L fill:#fff3e0
```

#### ğŸ”§ æä¾›è€…ï¼ˆProviderï¼‰è¯¦è§£

**æä¾›è€…æ˜¯NestJSä¾èµ–æ³¨å…¥ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µ**ï¼Œå®ƒå®šä¹‰äº†å¦‚ä½•åˆ›å»ºå’Œç®¡ç†ä¾èµ–å¯¹è±¡ã€‚

##### 1ï¸âƒ£ ç±»æä¾›è€…ï¼ˆClass Providerï¼‰

```typescript
// æœ€ç®€å•çš„æä¾›è€…å½¢å¼
@Injectable()
class UserService {
  findAll(): User[] {
    return [];
  }
}

@Module({
  providers: [UserService],  // ç®€å†™å½¢å¼
  // ç­‰ä»·äºï¼š
  // providers: [
  //   {
  //     provide: UserService,
  //     useClass: UserService,
  //   }
  // ],
})
export class UserModule {}
```

##### 2ï¸âƒ£ å€¼æä¾›è€…ï¼ˆValue Providerï¼‰

```typescript
// æä¾›å¸¸é‡å€¼
const DATABASE_CONFIG = {
  host: 'localhost',
  port: 5432,
  database: 'myapp',
  username: 'user',
  password: 'password'
};

@Module({
  providers: [
    {
      provide: 'DATABASE_CONFIG',
      useValue: DATABASE_CONFIG,
    },
    // ä¹Ÿå¯ä»¥æä¾›ç®€å•å€¼
    {
      provide: 'API_VERSION',
      useValue: 'v1',
    },
    // æä¾›å‡½æ•°
    {
      provide: 'CURRENT_TIME',
      useValue: () => new Date(),
    }
  ],
})
export class ConfigModule {}

// ä½¿ç”¨å€¼æä¾›è€…
@Injectable()
class DatabaseService {
  constructor(
    @Inject('DATABASE_CONFIG') private config: any,
    @Inject('API_VERSION') private version: string
  ) {
    console.log(`Database config:`, this.config);
    console.log(`API version: ${this.version}`);
  }
}
```

##### 3ï¸âƒ£ å·¥å‚æä¾›è€…ï¼ˆFactory Providerï¼‰

```typescript
// å¤æ‚çš„å¯¹è±¡åˆ›å»ºé€»è¾‘
@Module({
  providers: [
    {
      provide: 'DATABASE_CONNECTION',
      useFactory: async (config: DatabaseConfig, logger: ILogger) => {
        logger.log('Creating database connection...');
        
        const connection = new DatabaseConnection(config);
        await connection.connect();
        
        logger.log('Database connection established');
        return connection;
      },
      inject: ['DATABASE_CONFIG', 'LOGGER'],  // å·¥å‚å‡½æ•°çš„ä¾èµ–
    },
    // æ¡ä»¶æ€§åˆ›å»º
    {
      provide: 'CACHE_SERVICE',
      useFactory: (config: AppConfig) => {
        if (config.environment === 'production') {
          return new RedisCache(config.redis);
        } else {
          return new MemoryCache();
        }
      },
      inject: ['APP_CONFIG'],
    }
  ],
})
export class DatabaseModule {}
```

##### 4ï¸âƒ£ åˆ«åæä¾›è€…ï¼ˆAlias Providerï¼‰

```typescript
@Injectable()
class PostgreSQLUserRepository implements IUserRepository {
  // PostgreSQLå®ç°
}

@Injectable()
class MongoUserRepository implements IUserRepository {
  // MongoDBå®ç°
}

@Module({
  providers: [
    PostgreSQLUserRepository,
    MongoUserRepository,
    // åˆ›å»ºåˆ«åï¼Œæ ¹æ®ç¯å¢ƒé€‰æ‹©å®ç°
    {
      provide: 'UserRepository',
      useExisting: process.env.DB_TYPE === 'mongo' 
        ? MongoUserRepository 
        : PostgreSQLUserRepository,
    }
  ],
})
export class UserModule {}

// ä½¿ç”¨åˆ«å
@Injectable()
class UserService {
  constructor(
    @Inject('UserRepository') private userRepository: IUserRepository
  ) {}
}
```

#### ğŸ”„ ä¾èµ–æ³¨å…¥çš„ç”Ÿå‘½å‘¨æœŸ

##### 1ï¸âƒ£ å•ä¾‹æ¨¡å¼ï¼ˆSingletonï¼‰- é»˜è®¤

```typescript
@Injectable()
class SingletonService {
  private counter = 0;
  
  increment(): number {
    return ++this.counter;
  }
  
  getCount(): number {
    return this.counter;
  }
}

// æµ‹è¯•å•ä¾‹è¡Œä¸º
@Controller('test')
class TestController {
  constructor(private singletonService: SingletonService) {}
  
  @Get('count')
  getCount(): number {
    this.singletonService.increment();
    return this.singletonService.getCount();  // æ¯æ¬¡è°ƒç”¨éƒ½ä¼šé€’å¢
  }
}
```

##### 2ï¸âƒ£ è¯·æ±‚ä½œç”¨åŸŸï¼ˆRequest Scopeï¼‰

```typescript
@Injectable({ scope: Scope.REQUEST })
class RequestScopedService {
  private readonly id = Math.random();
  
  getId(): number {
    return this.id;
  }
}

// æ¯ä¸ªHTTPè¯·æ±‚éƒ½ä¼šåˆ›å»ºæ–°çš„å®ä¾‹
@Controller('test')
class TestController {
  constructor(private requestService: RequestScopedService) {}
  
  @Get('id')
  getId(): number {
    return this.requestService.getId();  // æ¯ä¸ªè¯·æ±‚è¿”å›ä¸åŒçš„ID
  }
}
```

##### 3ï¸âƒ£ ç¬æ€ä½œç”¨åŸŸï¼ˆTransient Scopeï¼‰

```typescript
@Injectable({ scope: Scope.TRANSIENT })
class TransientService {
  private readonly id = Math.random();
  
  getId(): number {
    return this.id;
  }
}

@Injectable()
class ServiceA {
  constructor(private transientService: TransientService) {}
  
  getId(): number {
    return this.transientService.getId();
  }
}

@Injectable()
class ServiceB {
  constructor(private transientService: TransientService) {}
  
  getId(): number {
    return this.transientService.getId();
  }
}

// ServiceAå’ŒServiceBä¼šå¾—åˆ°ä¸åŒçš„TransientServiceå®ä¾‹
```

#### âš ï¸ å¾ªç¯ä¾èµ–å¤„ç†

**å¾ªç¯ä¾èµ–æ˜¯æŒ‡ä¸¤ä¸ªæˆ–å¤šä¸ªç±»ç›¸äº’ä¾èµ–çš„æƒ…å†µ**ã€‚

##### é—®é¢˜ç¤ºä¾‹ï¼š
```typescript
// âŒ å¾ªç¯ä¾èµ–é—®é¢˜
@Injectable()
class UserService {
  constructor(private orderService: OrderService) {}  // ä¾èµ–OrderService
}

@Injectable()
class OrderService {
  constructor(private userService: UserService) {}    // ä¾èµ–UserService
}
```

##### è§£å†³æ–¹æ¡ˆ1ï¼šä½¿ç”¨forwardRef
```typescript
// âœ… ä½¿ç”¨forwardRefè§£å†³å¾ªç¯ä¾èµ–
@Injectable()
class UserService {
  constructor(
    @Inject(forwardRef(() => OrderService))
    private orderService: OrderService
  ) {}
  
  async getUserOrders(userId: string): Promise<Order[]> {
    return this.orderService.getOrdersByUserId(userId);
  }
}

@Injectable()
class OrderService {
  constructor(
    @Inject(forwardRef(() => UserService))
    private userService: UserService
  ) {}
  
  async getOrdersByUserId(userId: string): Promise<Order[]> {
    const user = await this.userService.findById(userId);
    if (!user) {
      throw new NotFoundException('User not found');
    }
    // æŸ¥è¯¢è®¢å•é€»è¾‘...
    return [];
  }
}
```

##### è§£å†³æ–¹æ¡ˆ2ï¼šé‡æ„è®¾è®¡é¿å…å¾ªç¯ä¾èµ–
```typescript
// âœ… æ›´å¥½çš„è®¾è®¡ï¼šé¿å…å¾ªç¯ä¾èµ–
interface IUserRepository {
  findById(id: string): Promise<User>;
}

interface IOrderRepository {
  findByUserId(userId: string): Promise<Order[]>;
}

@Injectable()
class UserService {
  constructor(private userRepository: IUserRepository) {}
  
  async findById(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
}

@Injectable()
class OrderService {
  constructor(
    private orderRepository: IOrderRepository,
    private userRepository: IUserRepository  // ç›´æ¥ä¾èµ–Repositoryè€Œä¸æ˜¯Service
  ) {}
  
  async getOrdersByUserId(userId: string): Promise<Order[]> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return this.orderRepository.findByUserId(userId);
  }
}

// æˆ–è€…åˆ›å»ºä¸€ä¸ªèšåˆæœåŠ¡
@Injectable()
class UserOrderService {
  constructor(
    private userService: UserService,
    private orderService: OrderService
  ) {}
  
  async getUserWithOrders(userId: string): Promise<UserWithOrders> {
    const user = await this.userService.findById(userId);
    const orders = await this.orderService.getOrdersByUserId(userId);
    
    return {
      user,
      orders
    };
  }
}
```

### 3.2.2 è‡ªå®šä¹‰è£…é¥°å™¨å’Œæä¾›è€…

#### ğŸ¨ åˆ›å»ºè‡ªå®šä¹‰è£…é¥°å™¨

##### 1ï¸âƒ£ å‚æ•°è£…é¥°å™¨

```typescript
// åˆ›å»ºè·å–å½“å‰ç”¨æˆ·çš„è£…é¥°å™¨
export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): User => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);

// åˆ›å»ºè·å–è¯·æ±‚IPçš„è£…é¥°å™¨
export const ClientIp = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): string => {
    const request = ctx.switchToHttp().getRequest();
    return request.ip || request.connection.remoteAddress;
  },
);

// ä½¿ç”¨è‡ªå®šä¹‰è£…é¥°å™¨
@Controller('users')
export class UserController {
  @Get('profile')
  @UseGuards(JwtAuthGuard)
  getProfile(@CurrentUser() user: User): User {
    return user;
  }
  
  @Post('login')
  async login(
    @Body() loginDto: LoginDto,
    @ClientIp() ip: string
  ): Promise<LoginResponse> {
    console.log(`Login attempt from IP: ${ip}`);
    return this.authService.login(loginDto);
  }
}
```

##### 2ï¸âƒ£ æ–¹æ³•è£…é¥°å™¨

```typescript
// åˆ›å»ºç¼“å­˜è£…é¥°å™¨
export function Cache(ttl: number = 300) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    const cacheMap = new Map<string, { value: any; expiry: number }>();
    
    descriptor.value = async function (...args: any[]) {
      const cacheKey = `${propertyName}_${JSON.stringify(args)}`;
      const cached = cacheMap.get(cacheKey);
      
      if (cached && cached.expiry > Date.now()) {
        console.log(`Cache hit for ${cacheKey}`);
        return cached.value;
      }
      
      const result = await method.apply(this, args);
      cacheMap.set(cacheKey, {
        value: result,
        expiry: Date.now() + ttl * 1000
      });
      
      console.log(`Cache set for ${cacheKey}`);
      return result;
    };
  };
}

// ä½¿ç”¨ç¼“å­˜è£…é¥°å™¨
@Injectable()
class ProductService {
  @Cache(600)  // ç¼“å­˜10åˆ†é’Ÿ
  async getProduct(id: string): Promise<Product> {
    console.log(`Fetching product ${id} from database`);
    // æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
    await new Promise(resolve => setTimeout(resolve, 1000));
    return { id, name: `Product ${id}`, price: 100 };
  }
}
```

##### 3ï¸âƒ£ ç±»è£…é¥°å™¨

```typescript
// åˆ›å»ºè‡ªåŠ¨æ—¥å¿—è£…é¥°å™¨
export function AutoLog(context: string) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
      constructor(...args: any[]) {
        super(...args);
        console.log(`${context} instance created`);
      }
    };
  };
}

// ä½¿ç”¨è‡ªåŠ¨æ—¥å¿—è£…é¥°å™¨
@AutoLog('UserService')
@Injectable()
class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async findAll(): Promise<User[]> {
    return this.userRepository.find();
  }
}
```

#### ğŸ­ åŠ¨æ€æ¨¡å—å’Œæä¾›è€…

##### 1ï¸âƒ£ åŠ¨æ€æ¨¡å—

```typescript
// åˆ›å»ºå¯é…ç½®çš„æ•°æ®åº“æ¨¡å—
export interface DatabaseModuleOptions {
  host: string;
  port: number;
  database: string;
  username: string;
  password: string;
}

@Module({})
export class DatabaseModule {
  static forRoot(options: DatabaseModuleOptions): DynamicModule {
    return {
      module: DatabaseModule,
      providers: [
        {
          provide: 'DATABASE_OPTIONS',
          useValue: options,
        },
        {
          provide: 'DATABASE_CONNECTION',
          useFactory: async (options: DatabaseModuleOptions) => {
            const connection = new DatabaseConnection(options);
            await connection.connect();
            return connection;
          },
          inject: ['DATABASE_OPTIONS'],
        },
      ],
      exports: ['DATABASE_CONNECTION'],
      global: true,  // å…¨å±€å¯ç”¨
    };
  }
  
  static forRootAsync(options: {
    useFactory: (...args: any[]) => Promise<DatabaseModuleOptions> | DatabaseModuleOptions;
    inject?: any[];
  }): DynamicModule {
    return {
      module: DatabaseModule,
      providers: [
        {
          provide: 'DATABASE_OPTIONS',
          useFactory: options.useFactory,
          inject: options.inject || [],
        },
        {
          provide: 'DATABASE_CONNECTION',
          useFactory: async (options: DatabaseModuleOptions) => {
            const connection = new DatabaseConnection(options);
            await connection.connect();
            return connection;
          },
          inject: ['DATABASE_OPTIONS'],
        },
      ],
      exports: ['DATABASE_CONNECTION'],
      global: true,
    };
  }
}

// ä½¿ç”¨åŠ¨æ€æ¨¡å—
@Module({
  imports: [
    // åŒæ­¥é…ç½®
    DatabaseModule.forRoot({
      host: 'localhost',
      port: 5432,
      database: 'myapp',
      username: 'user',
      password: 'password'
    }),
    
    // å¼‚æ­¥é…ç½®
    DatabaseModule.forRootAsync({
      useFactory: (configService: ConfigService) => ({
        host: configService.get('DB_HOST'),
        port: configService.get('DB_PORT'),
        database: configService.get('DB_NAME'),
        username: configService.get('DB_USER'),
        password: configService.get('DB_PASSWORD'),
      }),
      inject: [ConfigService],
    }),
  ],
})
export class AppModule {}
```

##### 2ï¸âƒ£ æ¡ä»¶æä¾›è€…

```typescript
// æ ¹æ®ç¯å¢ƒæä¾›ä¸åŒçš„æœåŠ¡
@Module({
  providers: [
    {
      provide: 'LOGGER',
      useFactory: (configService: ConfigService) => {
        const env = configService.get('NODE_ENV');
        
        if (env === 'production') {
          return new FileLogger({
            filename: 'app.log',
            level: 'info'
          });
        } else if (env === 'development') {
          return new ConsoleLogger({
            level: 'debug',
            colorize: true
          });
        } else {
          return new NullLogger();  // æµ‹è¯•ç¯å¢ƒä¸è¾“å‡ºæ—¥å¿—
        }
      },
      inject: [ConfigService],
    },
    
    // æ ¹æ®åŠŸèƒ½å¼€å…³æä¾›æœåŠ¡
    {
      provide: 'ANALYTICS_SERVICE',
      useFactory: (configService: ConfigService) => {
        const analyticsEnabled = configService.get('ANALYTICS_ENABLED');
        
        if (analyticsEnabled) {
          return new GoogleAnalyticsService(
            configService.get('GA_TRACKING_ID')
          );
        } else {
          return new NoOpAnalyticsService();  // ç©ºå®ç°
        }
      },
      inject: [ConfigService],
    }
  ],
})
export class AppModule {}
```

---

## 3.3 é«˜çº§ä¾èµ–æ³¨å…¥æ¨¡å¼

### 3.3.1 å¤šé‡å®ç°å’Œç­–ç•¥æ¨¡å¼

#### ğŸ¯ å¤šé‡å®ç°æ³¨å…¥

```typescript
// å®šä¹‰é€šçŸ¥æ¥å£
interface INotificationProvider {
  getName(): string;
  send(message: string, recipient: string): Promise<boolean>;
}

// å®ç°å¤šä¸ªé€šçŸ¥æä¾›è€…
@Injectable()
class EmailNotificationProvider implements INotificationProvider {
  getName(): string {
    return 'email';
  }
  
  async send(message: string, recipient: string): Promise<boolean> {
    console.log(`Sending email to ${recipient}: ${message}`);
    // é‚®ä»¶å‘é€é€»è¾‘
    return true;
  }
}

@Injectable()
class SmsNotificationProvider implements INotificationProvider {
  getName(): string {
    return 'sms';
  }
  
  async send(message: string, recipient: string): Promise<boolean> {
    console.log(`Sending SMS to ${recipient}: ${message}`);
    // çŸ­ä¿¡å‘é€é€»è¾‘
    return true;
  }
}

@Injectable()
class PushNotificationProvider implements INotificationProvider {
  getName(): string {
    return 'push';
  }
  
  async send(message: string, recipient: string): Promise<boolean> {
    console.log(`Sending push notification to ${recipient}: ${message}`);
    // æ¨é€é€šçŸ¥é€»è¾‘
    return true;
  }
}

// é€šçŸ¥æœåŠ¡ç®¡ç†å¤šä¸ªæä¾›è€…
@Injectable()
class NotificationService {
  private providers: Map<string, INotificationProvider> = new Map();
  
  constructor(
    @Inject('NOTIFICATION_PROVIDERS') 
    providers: INotificationProvider[]
  ) {
    providers.forEach(provider => {
      this.providers.set(provider.getName(), provider);
    });
  }
  
  async sendNotification(
    message: string, 
    recipient: string, 
    type: string
  ): Promise<boolean> {
    const provider = this.providers.get(type);
    
    if (!provider) {
      throw new Error(`Notification provider ${type} not found`);
    }
    
    return provider.send(message, recipient);
  }
  
  async sendToAll(message: string, recipient: string): Promise<boolean[]> {
    const results = await Promise.allSettled(
      Array.from(this.providers.values()).map(provider =>
        provider.send(message, recipient)
      )
    );
    
    return results.map(result => 
      result.status === 'fulfilled' ? result.value : false
    );
  }
  
  getAvailableProviders(): string[] {
    return Array.from(this.providers.keys());
  }
}

// æ¨¡å—é…ç½®
@Module({
  providers: [
    EmailNotificationProvider,
    SmsNotificationProvider,
    PushNotificationProvider,
    {
      provide: 'NOTIFICATION_PROVIDERS',
      useFactory: (
        emailProvider: EmailNotificationProvider,
        smsProvider: SmsNotificationProvider,
        pushProvider: PushNotificationProvider
      ) => [emailProvider, smsProvider, pushProvider],
      inject: [
        EmailNotificationProvider,
        SmsNotificationProvider,
        PushNotificationProvider
      ],
    },
    NotificationService,
  ],
  exports: [NotificationService],
})
export class NotificationModule {}
```

#### ğŸ”„ ç­–ç•¥æ¨¡å¼å®ç°

```typescript
// å®šä¹‰æ”¯ä»˜ç­–ç•¥æ¥å£
interface IPaymentStrategy {
  getName(): string;
  processPayment(amount: number, currency: string): Promise<PaymentResult>;
  validatePayment(paymentData: any): boolean;
}

// å®ç°ä¸åŒçš„æ”¯ä»˜ç­–ç•¥
@Injectable()
class CreditCardStrategy implements IPaymentStrategy {
  getName(): string {
    return 'credit_card';
  }
  
  validatePayment(paymentData: any): boolean {
    return paymentData.cardNumber && paymentData.expiryDate && paymentData.cvv;
  }
  
  async processPayment(amount: number, currency: string): Promise<PaymentResult> {
    // ä¿¡ç”¨å¡æ”¯ä»˜é€»è¾‘
    console.log(`Processing credit card payment: ${amount} ${currency}`);
    
    // æ¨¡æ‹Ÿæ”¯ä»˜å¤„ç†
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return {
      success: true,
      transactionId: `cc_${Date.now()}`,
      amount,
      currency,
      fee: amount * 0.029  // 2.9% æ‰‹ç»­è´¹
    };
  }
}

@Injectable()
class PayPalStrategy implements IPaymentStrategy {
  getName(): string {
    return 'paypal';
  }
  
  validatePayment(paymentData: any): boolean {
    return paymentData.email && paymentData.password;
  }
  
  async processPayment(amount: number, currency: string): Promise<PaymentResult> {
    console.log(`Processing PayPal payment: ${amount} ${currency}`);
    
    await new Promise(resolve => setTimeout(resolve, 800));
    
    return {
      success: true,
      transactionId: `pp_${Date.now()}`,
      amount,
      currency,
      fee: amount * 0.034  // 3.4% æ‰‹ç»­è´¹
    };
  }
}

@Injectable()
class AlipayStrategy implements IPaymentStrategy {
  getName(): string {
    return 'alipay';
  }
  
  validatePayment(paymentData: any): boolean {
    return paymentData.account;
  }
  
  async processPayment(amount: number, currency: string): Promise<PaymentResult> {
    console.log(`Processing Alipay payment: ${amount} ${currency}`);
    
    await new Promise(resolve => setTimeout(resolve, 600));
    
    return {
      success: true,
      transactionId: `ap_${Date.now()}`,
      amount,
      currency,
      fee: amount * 0.006  // 0.6% æ‰‹ç»­è´¹
    };
  }
}

// æ”¯ä»˜ä¸Šä¸‹æ–‡æœåŠ¡
@Injectable()
class PaymentContextService {
  private strategies: Map<string, IPaymentStrategy> = new Map();
  
  constructor(
    @Inject('PAYMENT_STRATEGIES') 
    strategies: IPaymentStrategy[]
  ) {
    strategies.forEach(strategy => {
      this.strategies.set(strategy.getName(), strategy);
    });
  }
  
  async processPayment(
    amount: number,
    currency: string,
    paymentMethod: string,
    paymentData: any
  ): Promise<PaymentResult> {
    const strategy = this.strategies.get(paymentMethod);
    
    if (!strategy) {
      throw new BadRequestException(`Payment method ${paymentMethod} not supported`);
    }
    
    if (!strategy.validatePayment(paymentData)) {
      throw new BadRequestException('Invalid payment data');
    }
    
    try {
      const result = await strategy.processPayment(amount, currency);
      
      // è®°å½•æ”¯ä»˜æ—¥å¿—
      console.log(`Payment processed: ${JSON.stringify(result)}`);
      
      return result;
    } catch (error) {
      console.error(`Payment failed: ${error.message}`);
      throw new InternalServerErrorException('Payment processing failed');
    }
  }
  
  getSupportedMethods(): string[] {
    return Array.from(this.strategies.keys());
  }
  
  getMethodInfo(method: string): { name: string; feeRate: number } | null {
    const strategy = this.strategies.get(method);
    if (!strategy) return null;
    
    // è¿™é‡Œå¯ä»¥è¿”å›æ›´è¯¦ç»†çš„æ–¹æ³•ä¿¡æ¯
    return {
      name: strategy.getName(),
      feeRate: this.getFeeRate(method)
    };
  }
  
  private getFeeRate(method: string): number {
    switch (method) {
      case 'credit_card': return 0.029;
      case 'paypal': return 0.034;
      case 'alipay': return 0.006;
      default: return 0;
    }
  }
}

// æ”¯ä»˜æ§åˆ¶å™¨
@Controller('payments')
export class PaymentController {
  constructor(private paymentService: PaymentContextService) {}
  
  @Post('process')
  async processPayment(@Body() paymentDto: ProcessPaymentDto): Promise<PaymentResult> {
    return this.paymentService.processPayment(
      paymentDto.amount,
      paymentDto.currency,
      paymentDto.method,
      paymentDto.paymentData
    );
  }
  
  @Get('methods')
  getSupportedMethods(): string[] {
    return this.paymentService.getSupportedMethods();
  }
}
```

### 3.3.2 è£…é¥°å™¨æ¨¡å¼å’Œä¸­é—´ä»¶

#### ğŸ¨ è£…é¥°å™¨æ¨¡å¼å®ç°

```typescript
// åŸºç¡€æœåŠ¡æ¥å£
interface IUserService {
  getUser(id: string): Promise<User>;
  updateUser(id: string, data: Partial<User>): Promise<User>;
}

// åŸºç¡€ç”¨æˆ·æœåŠ¡
@Injectable()
class BaseUserService implements IUserService {
  constructor(private userRepository: UserRepository) {}
  
  async getUser(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
  
  async updateUser(id: string, data: Partial<User>): Promise<User> {
    return this.userRepository.update(id, data);
  }
}

// ç¼“å­˜è£…é¥°å™¨æœåŠ¡
@Injectable()
class CachedUserService implements IUserService {
  constructor(
    private baseService: IUserService,
    private cacheService: ICacheService
  ) {}
  
  async getUser(id: string): Promise<User> {
    const cacheKey = `user:${id}`;
    
    // å…ˆä»ç¼“å­˜è·å–
    const cached = await this.cacheService.get<User>(cacheKey);
    if (cached) {
      console.log(`Cache hit for user ${id}`);
      return cached;
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»åŸºç¡€æœåŠ¡è·å–
    const user = await this.baseService.getUser(id);
    
    // å­˜å…¥ç¼“å­˜
    await this.cacheService.set(cacheKey, user, 3600);
    console.log(`User ${id} cached`);
    
    return user;
  }
  
  async updateUser(id: string, data: Partial<User>): Promise<User> {
    // æ›´æ–°ç”¨æˆ·
    const user = await this.baseService.updateUser(id, data);
    
    // æ¸…é™¤ç¼“å­˜
    await this.cacheService.delete(`user:${id}`);
    console.log(`Cache cleared for user ${id}`);
    
    return user;
  }
}

// æ—¥å¿—è£…é¥°å™¨æœåŠ¡
@Injectable()
class LoggedUserService implements IUserService {
  constructor(
    private baseService: IUserService,
    private logger: ILogger
  ) {}
  
  async getUser(id: string): Promise<User> {
    this.logger.log(`Getting user ${id}`, 'UserService');
    
    try {
      const user = await this.baseService.getUser(id);
      this.logger.log(`User ${id} retrieved successfully`, 'UserService');
      return user;
    } catch (error) {
      this.logger.error(`Failed to get user ${id}: ${error.message}`, 'UserService');
      throw error;
    }
  }
  
  async updateUser(id: string, data: Partial<User>): Promise<User> {
    this.logger.log(`Updating user ${id}`, 'UserService');
    
    try {
      const user = await this.baseService.updateUser(id, data);
      this.logger.log(`User ${id} updated successfully`, 'UserService');
      return user;
    } catch (error) {
      this.logger.error(`Failed to update user ${id}: ${error.message}`, 'UserService');
      throw error;
    }
  }
}

// æƒé™è£…é¥°å™¨æœåŠ¡
@Injectable()
class AuthorizedUserService implements IUserService {
  constructor(
    private baseService: IUserService,
    private authService: IAuthService
  ) {}
  
  async getUser(id: string): Promise<User> {
    // æ£€æŸ¥æƒé™
    const currentUser = this.authService.getCurrentUser();
    if (!this.canAccessUser(currentUser, id)) {
      throw new ForbiddenException('Access denied');
    }
    
    return this.baseService.getUser(id);
  }
  
  async updateUser(id: string, data: Partial<User>): Promise<User> {
    const currentUser = this.authService.getCurrentUser();
    if (!this.canModifyUser(currentUser, id)) {
      throw new ForbiddenException('Modification denied');
    }
    
    return this.baseService.updateUser(id, data);
  }
  
  private canAccessUser(currentUser: User, targetId: string): boolean {
    return currentUser.id === targetId || currentUser.role === 'admin';
  }
  
  private canModifyUser(currentUser: User, targetId: string): boolean {
    return currentUser.id === targetId || currentUser.role === 'admin';
  }
}

// ç»„åˆè£…é¥°å™¨çš„å·¥å‚
@Injectable()
class UserServiceFactory {
  constructor(
    private userRepository: UserRepository,
    private cacheService: ICacheService,
    private logger: ILogger,
    private authService: IAuthService
  ) {}
  
  createUserService(features: string[] = []): IUserService {
    let service: IUserService = new BaseUserService(this.userRepository);
    
    // æ ¹æ®éœ€è¦çš„åŠŸèƒ½æ·»åŠ è£…é¥°å™¨
    if (features.includes('cache')) {
      service = new CachedUserService(service, this.cacheService);
    }
    
    if (features.includes('logging')) {
      service = new LoggedUserService(service, this.logger);
    }
    
    if (features.includes('auth')) {
      service = new AuthorizedUserService(service, this.authService);
    }
    
    return service;
  }
}

// æ¨¡å—é…ç½®
@Module({
  providers: [
    UserRepository,
    {
      provide: 'USER_SERVICE',
      useFactory: (factory: UserServiceFactory, config: ConfigService) => {
        const features = config.get('USER_SERVICE_FEATURES', []);
        return factory.createUserService(features);
      },
      inject: [UserServiceFactory, ConfigService],
    },
    UserServiceFactory,
  ],
})
export class UserModule {}
```

#### ğŸ”§ ä¸­é—´ä»¶æ¨¡å¼

```typescript
// è¯·æ±‚å¤„ç†ä¸­é—´ä»¶æ¥å£
interface IRequestMiddleware {
  process(request: any, next: () => Promise<any>): Promise<any>;
}

// è®¤è¯ä¸­é—´ä»¶
@Injectable()
class AuthenticationMiddleware implements IRequestMiddleware {
  constructor(private jwtService: JwtService) {}
  
  async process(request: any, next: () => Promise<any>): Promise<any> {
    const token = this.extractToken(request);
    
    if (!token) {
      throw new UnauthorizedException('Token not provided');
    }
    
    try {
      const payload = this.jwtService.verify(token);
      request.user = payload;
      
      console.log(`User authenticated: ${payload.sub}`);
      return next();
    } catch (error) {
      throw new UnauthorizedException('Invalid token');
    }
  }
  
  private extractToken(request: any): string | null {
    const authHeader = request.headers.authorization;
    if (!authHeader) return null;
    
    const [type, token] = authHeader.split(' ');
    return type === 'Bearer' ? token : null;
  }
}

// é™æµä¸­é—´ä»¶
@Injectable()
class RateLimitMiddleware implements IRequestMiddleware {
  private requests: Map<string, number[]> = new Map();
  
  constructor(
    private readonly limit: number = 100,
    private readonly windowMs: number = 60000  // 1åˆ†é’Ÿ
  ) {}
  
  async process(request: any, next: () => Promise<any>): Promise<any> {
    const clientId = this.getClientId(request);
    const now = Date.now();
    
    // è·å–å®¢æˆ·ç«¯çš„è¯·æ±‚è®°å½•
    const clientRequests = this.requests.get(clientId) || [];
    
    // æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•
    const validRequests = clientRequests.filter(
      timestamp => now - timestamp < this.windowMs
    );
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
    if (validRequests.length >= this.limit) {
      throw new TooManyRequestsException('Rate limit exceeded');
    }
    
    // è®°å½•å½“å‰è¯·æ±‚
    validRequests.push(now);
    this.requests.set(clientId, validRequests);
    
    console.log(`Rate limit check passed for ${clientId}: ${validRequests.length}/${this.limit}`);
    return next();
  }
  
  private getClientId(request: any): string {
    return request.user?.id || request.ip || 'anonymous';
  }
}

// æ—¥å¿—ä¸­é—´ä»¶
@Injectable()
class LoggingMiddleware implements IRequestMiddleware {
  constructor(private logger: ILogger) {}
  
  async process(request: any, next: () => Promise<any>): Promise<any> {
    const start = Date.now();
    const { method, url, user } = request;
    
    this.logger.log(`${method} ${url} - User: ${user?.id || 'anonymous'}`, 'Request');
    
    try {
      const result = await next();
      const duration = Date.now() - start;
      
      this.logger.log(`${method} ${url} - Completed in ${duration}ms`, 'Request');
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      
      this.logger.error(
        `${method} ${url} - Failed in ${duration}ms: ${error.message}`,
        'Request'
      );
      throw error;
    }
  }
}

// ä¸­é—´ä»¶ç®¡é“
@Injectable()
class MiddlewarePipeline {
  private middlewares: IRequestMiddleware[] = [];
  
  use(middleware: IRequestMiddleware): this {
    this.middlewares.push(middleware);
    return this;
  }
  
  async execute(request: any, handler: () => Promise<any>): Promise<any> {
    let index = 0;
    
    const next = async (): Promise<any> => {
      if (index >= this.middlewares.length) {
        return handler();
      }
      
      const middleware = this.middlewares[index++];
      return middleware.process(request, next);
    };
    
    return next();
  }
}

// ä½¿ç”¨ä¸­é—´ä»¶ç®¡é“çš„æœåŠ¡
@Injectable()
class ApiService {
  private pipeline: MiddlewarePipeline;
  
  constructor(
    authMiddleware: AuthenticationMiddleware,
    rateLimitMiddleware: RateLimitMiddleware,
    loggingMiddleware: LoggingMiddleware
  ) {
    this.pipeline = new MiddlewarePipeline()
      .use(loggingMiddleware)
      .use(authMiddleware)
      .use(rateLimitMiddleware);
  }
  
  async processRequest(request: any, handler: () => Promise<any>): Promise<any> {
    return this.pipeline.execute(request, handler);
  }
}
```

---

## ğŸ“ æœ¬ç« çŸ¥è¯†æ€»ç»“

### ğŸ§  æ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((ç¬¬3ç« ï¼šä¾èµ–æ³¨å…¥åŸç†))
    æ§åˆ¶åè½¬IoC
      åŸºæœ¬æ¦‚å¿µ
        æ§åˆ¶æƒè½¬ç§»
        ä¾èµ–ç®¡ç†å¤–åŒ–
        æ¾è€¦åˆè®¾è®¡
        æé«˜å¯æµ‹è¯•æ€§
      å®ç°æ–¹å¼
        ä¾èµ–æ³¨å…¥DI
        æœåŠ¡å®šä½å™¨
        å·¥å‚æ¨¡å¼
        æ¨¡æ¿æ–¹æ³•
    ä¾èµ–æ³¨å…¥DI
      æ³¨å…¥æ–¹å¼
        æ„é€ å‡½æ•°æ³¨å…¥
        å±æ€§æ³¨å…¥
        æ–¹æ³•æ³¨å…¥
        æ¥å£æ³¨å…¥
      ç”Ÿå‘½å‘¨æœŸ
        å•ä¾‹æ¨¡å¼
        è¯·æ±‚ä½œç”¨åŸŸ
        ç¬æ€ä½œç”¨åŸŸ
        è‡ªå®šä¹‰ä½œç”¨åŸŸ
    NestJSå®ç°
      IoCå®¹å™¨
        æ¨¡å—å®¹å™¨
        æä¾›è€…ç®¡ç†
        ä¾èµ–è§£æ
        å¾ªç¯ä¾èµ–å¤„ç†
      è£…é¥°å™¨ç³»ç»Ÿ
        Injectableè£…é¥°å™¨
        Injectè£…é¥°å™¨
        Optionalè£…é¥°å™¨
        è‡ªå®šä¹‰è£…é¥°å™¨
    é«˜çº§æ¨¡å¼
      å¤šé‡å®ç°
        ç­–ç•¥æ¨¡å¼
        å·¥å‚æ¨¡å¼
        æ³¨å†Œè¡¨æ¨¡å¼
        æ’ä»¶ç³»ç»Ÿ
      è£…é¥°å™¨æ¨¡å¼
        åŠŸèƒ½å¢å¼º
        æ¨ªåˆ‡å…³æ³¨ç‚¹
        ä¸­é—´ä»¶ç®¡é“
        AOPç¼–ç¨‹
```

### ğŸ“Š çŸ¥è¯†ç‚¹æŒæ¡æ£€æŸ¥è¡¨

#### ğŸ¯ åŸºç¡€æ¦‚å¿µï¼ˆå¿…é¡»æŒæ¡ï¼‰
- [ ] ç†è§£æ§åˆ¶åè½¬ï¼ˆIoCï¼‰çš„æ ¸å¿ƒæ€æƒ³
- [ ] æŒæ¡ä¾èµ–æ³¨å…¥ï¼ˆDIï¼‰çš„å››ç§æ–¹å¼
- [ ] äº†è§£NestJSçš„IoCå®¹å™¨æ¶æ„
- [ ] æŒæ¡æä¾›è€…çš„å„ç§é…ç½®æ–¹å¼

#### ğŸš€ è¿›é˜¶ç†è§£ï¼ˆå»ºè®®æŒæ¡ï¼‰
- [ ] ç†è§£ä¾èµ–å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] èƒ½å¤Ÿå¤„ç†å¾ªç¯ä¾èµ–é—®é¢˜
- [ ] æŒæ¡è‡ªå®šä¹‰è£…é¥°å™¨çš„åˆ›å»º
- [ ] ç†è§£åŠ¨æ€æ¨¡å—çš„è®¾è®¡å’Œä½¿ç”¨

#### ğŸ’ ä¸“å®¶çº§åˆ«ï¼ˆæ·±åº¦ç†è§£ï¼‰
- [ ] èƒ½å¤Ÿè®¾è®¡å¤æ‚çš„ä¾èµ–æ³¨å…¥æ¶æ„
- [ ] æŒæ¡å¤šé‡å®ç°å’Œç­–ç•¥æ¨¡å¼
- [ ] ç†è§£è£…é¥°å™¨æ¨¡å¼å’Œä¸­é—´ä»¶è®¾è®¡
- [ ] èƒ½å¤Ÿä¼˜åŒ–ä¾èµ–æ³¨å…¥çš„æ€§èƒ½

### ğŸ”— ä¸å…¶ä»–ç« èŠ‚çš„å…³è”

```mermaid
graph LR
    A[ç¬¬1ç« ï¼šæ¶æ„æ€ç»´] --> B[ç¬¬3ç« ï¼šä¾èµ–æ³¨å…¥]
    C[ç¬¬2ç« ï¼šæ¨¡å—ç³»ç»Ÿ] --> B
    B --> D[ç¬¬4ç« ï¼šæ•°æ®æŒä¹…åŒ–]
    B --> E[ç¬¬5ç« ï¼šAPIè®¾è®¡]
    B --> F[ç¬¬7ç« ï¼šé¡¹ç›®æ¶æ„]
    
    A --> G[SOLIDåŸåˆ™åº”ç”¨]
    C --> H[æ¨¡å—åŒ–å®è·µ]
    B --> I[IoCå®¹å™¨è®¾è®¡]
    B --> J[è£…é¥°å™¨æ¨¡å¼]
```

---

## ğŸ¯ ç« èŠ‚ç»ƒä¹ ä¸å®æˆ˜

### ğŸ“ æƒ…æ™¯æ¨¡æ‹Ÿç»ƒä¹ é¢˜

#### ç»ƒä¹ 1ï¼šIoCå®¹å™¨è®¾è®¡é¢˜
**åœºæ™¯**ï¼šè®¾è®¡ä¸€ä¸ªç®€å•çš„IoCå®¹å™¨ï¼Œæ”¯æŒåŸºæœ¬çš„ä¾èµ–æ³¨å…¥åŠŸèƒ½ã€‚

**è¦æ±‚**ï¼š
1. æ”¯æŒç±»çš„æ³¨å†Œå’Œè§£æ
2. æ”¯æŒæ„é€ å‡½æ•°æ³¨å…¥
3. æ”¯æŒå•ä¾‹å’Œç¬æ€ç”Ÿå‘½å‘¨æœŸ
4. å¤„ç†ç®€å•çš„å¾ªç¯ä¾èµ–

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆè§£æ</summary>

**IoCå®¹å™¨å®ç°**ï¼š

```typescript
// æœåŠ¡æè¿°ç¬¦
interface ServiceDescriptor {
  token: any;
  implementation?: any;
  factory?: (...args: any[]) => any;
  dependencies?: any[];
  lifetime: 'singleton' | 'transient';
}

// ç®€å•çš„IoCå®¹å™¨å®ç°
class SimpleIoCContainer {
  private services = new Map<any, ServiceDescriptor>();
  private instances = new Map<any, any>();
  private resolving = new Set<any>();
  
  // æ³¨å†ŒæœåŠ¡
  register(descriptor: ServiceDescriptor): void {
    this.services.set(descriptor.token, descriptor);
  }
  
  // æ³¨å†Œå•ä¾‹
  registerSingleton<T>(
    token: any, 
    implementation: new (...args: any[]) => T,
    dependencies: any[] = []
  ): void {
    this.register({
      token,
      implementation,
      dependencies,
      lifetime: 'singleton'
    });
  }
  
  // æ³¨å†Œç¬æ€
  registerTransient<T>(
    token: any, 
    implementation: new (...args: any[]) => T,
    dependencies: any[] = []
  ): void {
    this.register({
      token,
      implementation,
      dependencies,
      lifetime: 'transient'
    });
  }
  
  // æ³¨å†Œå·¥å‚
  registerFactory<T>(
    token: any,
    factory: (...args: any[]) => T,
    dependencies: any[] = [],
    lifetime: 'singleton' | 'transient' = 'singleton'
  ): void {
    this.register({
      token,
      factory,
      dependencies,
      lifetime
    });
  }
  
  // è§£ææœåŠ¡
  resolve<T>(token: any): T {
    // æ£€æŸ¥å¾ªç¯ä¾èµ–
    if (this.resolving.has(token)) {
      throw new Error(`Circular dependency detected for ${token.name || token}`);
    }
    
    const descriptor = this.services.get(token);
    if (!descriptor) {
      throw new Error(`Service ${token.name || token} not registered`);
    }
    
    // å•ä¾‹æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦å·²æœ‰å®ä¾‹
    if (descriptor.lifetime === 'singleton' && this.instances.has(token)) {
      return this.instances.get(token);
    }
    
    // æ ‡è®°æ­£åœ¨è§£æ
    this.resolving.add(token);
    
    try {
      let instance: T;
      
      if (descriptor.factory) {
        // ä½¿ç”¨å·¥å‚å‡½æ•°åˆ›å»º
        const dependencies = this.resolveDependencies(descriptor.dependencies || []);
        instance = descriptor.factory(...dependencies);
      } else if (descriptor.implementation) {
        // ä½¿ç”¨æ„é€ å‡½æ•°åˆ›å»º
        const dependencies = this.resolveDependencies(descriptor.dependencies || []);
        instance = new descriptor.implementation(...dependencies);
      } else {
        throw new Error(`Invalid service descriptor for ${token.name || token}`);
      }
      
      // å•ä¾‹æ¨¡å¼ï¼šç¼“å­˜å®ä¾‹
      if (descriptor.lifetime === 'singleton') {
        this.instances.set(token, instance);
      }
      
      return instance;
    } finally {
      // æ¸…é™¤è§£ææ ‡è®°
      this.resolving.delete(token);
    }
  }
  
  // è§£æä¾èµ–æ•°ç»„
  private resolveDependencies(dependencies: any[]): any[] {
    return dependencies.map(dep => this.resolve(dep));
  }
  
  // æ¸…é™¤æ‰€æœ‰å®ä¾‹ï¼ˆç”¨äºæµ‹è¯•ï¼‰
  clear(): void {
    this.instances.clear();
    this.resolving.clear();
  }
}

// ä½¿ç”¨ç¤ºä¾‹
interface ILogger {
  log(message: string): void;
}

interface IUserRepository {
  findById(id: string): Promise<User>;
}

class ConsoleLogger implements ILogger {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }
}

class UserRepository implements IUserRepository {
  constructor(private logger: ILogger) {}
  
  async findById(id: string): Promise<User> {
    this.logger.log(`Finding user ${id}`);
    return { id, name: `User ${id}` };
  }
}

class UserService {
  constructor(
    private userRepository: IUserRepository,
    private logger: ILogger
  ) {}
  
  async getUser(id: string): Promise<User> {
    this.logger.log(`Getting user ${id}`);
    return this.userRepository.findById(id);
  }
}

// é…ç½®å®¹å™¨
const container = new SimpleIoCContainer();

container.registerSingleton('ILogger', ConsoleLogger);
container.registerSingleton('IUserRepository', UserRepository, ['ILogger']);
container.registerSingleton('UserService', UserService, ['IUserRepository', 'ILogger']);

// ä½¿ç”¨å®¹å™¨
const userService = container.resolve<UserService>('UserService');
userService.getUser('123');
```

**è®¾è®¡äº®ç‚¹**ï¼š
- æ”¯æŒå¤šç§æ³¨å†Œæ–¹å¼ï¼ˆç±»ã€å·¥å‚å‡½æ•°ï¼‰
- å®ç°äº†å•ä¾‹å’Œç¬æ€ç”Ÿå‘½å‘¨æœŸ
- åŒ…å«å¾ªç¯ä¾èµ–æ£€æµ‹
- æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯

</details>

#### ç»ƒä¹ 2ï¼šè£…é¥°å™¨æ¨¡å¼åº”ç”¨é¢˜
**åœºæ™¯**ï¼šä¸ºä¸€ä¸ªæ–‡ä»¶ä¸Šä¼ æœåŠ¡æ·»åŠ å¤šç§åŠŸèƒ½å¢å¼ºï¼Œå¦‚ç—…æ¯’æ‰«æã€æ–‡ä»¶å‹ç¼©ã€ç¼©ç•¥å›¾ç”Ÿæˆç­‰ã€‚

**è¦æ±‚**ï¼š
1. ä½¿ç”¨è£…é¥°å™¨æ¨¡å¼è®¾è®¡
2. æ”¯æŒåŠŸèƒ½çš„çµæ´»ç»„åˆ
3. æ¯ä¸ªè£…é¥°å™¨éƒ½å¯ä»¥ç‹¬ç«‹æµ‹è¯•
4. æ”¯æŒé…ç½®åŒ–çš„åŠŸèƒ½å¯ç”¨/ç¦ç”¨

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆè§£æ</summary>

**è£…é¥°å™¨æ¨¡å¼å®ç°**ï¼š

```typescript
// æ–‡ä»¶ä¸Šä¼ ç»“æœ
interface UploadResult {
  filename: string;
  size: number;
  url: string;
  thumbnailUrl?: string;
  compressed?: boolean;
  virusScanned?: boolean;
  metadata?: any;
}

// æ–‡ä»¶ä¸Šä¼ æœåŠ¡æ¥å£
interface IFileUploadService {
  upload(file: Express.Multer.File): Promise<UploadResult>;
}

// åŸºç¡€æ–‡ä»¶ä¸Šä¼ æœåŠ¡
@Injectable()
class BaseFileUploadService implements IFileUploadService {
  async upload(file: Express.Multer.File): Promise<UploadResult> {
    // åŸºç¡€ä¸Šä¼ é€»è¾‘
    const filename = `${Date.now()}_${file.originalname}`;
    const url = `https://cdn.example.com/${filename}`;
    
    console.log(`Uploading file: ${filename}`);
    
    // æ¨¡æ‹Ÿæ–‡ä»¶ä¸Šä¼ 
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return {
      filename,
      size: file.size,
      url
    };
  }
}

// ç—…æ¯’æ‰«æè£…é¥°å™¨
@Injectable()
class VirusScanDecorator implements IFileUploadService {
  constructor(
    private baseService: IFileUploadService,
    private virusScanner: IVirusScanner
  ) {}
  
  async upload(file: Express.Multer.File): Promise<UploadResult> {
    console.log('Scanning file for viruses...');
    
    // ç—…æ¯’æ‰«æ
    const scanResult = await this.virusScanner.scan(file.buffer);
    
    if (!scanResult.clean) {
      throw new BadRequestException(`Virus detected: ${scanResult.threat}`);
    }
    
    console.log('File is clean');
    
    // è°ƒç”¨åŸºç¡€æœåŠ¡
    const result = await this.baseService.upload(file);
    
    return {
      ...result,
      virusScanned: true,
      metadata: {
        ...result.metadata,
        scanResult
      }
    };
  }
}

// æ–‡ä»¶å‹ç¼©è£…é¥°å™¨
@Injectable()
class CompressionDecorator implements IFileUploadService {
  constructor(
    private baseService: IFileUploadService,
    private compressor: IFileCompressor
  ) {}
  
  async upload(file: Express.Multer.File): Promise<UploadResult> {
    console.log('Compressing file...');
    
    // å‹ç¼©æ–‡ä»¶
    const compressedBuffer = await this.compressor.compress(
      file.buffer, 
      file.mimetype
    );
    
    const originalSize = file.size;
    const compressedSize = compressedBuffer.length;
    const compressionRatio = (1 - compressedSize / originalSize) * 100;
    
    console.log(`File compressed: ${compressionRatio.toFixed(1)}% reduction`);
    
    // åˆ›å»ºå‹ç¼©åçš„æ–‡ä»¶å¯¹è±¡
    const compressedFile = {
      ...file,
      buffer: compressedBuffer,
      size: compressedSize
    };
    
    // è°ƒç”¨åŸºç¡€æœåŠ¡
    const result = await this.baseService.upload(compressedFile);
    
    return {
      ...result,
      compressed: true,
      metadata: {
        ...result.metadata,
        originalSize,
        compressionRatio
      }
    };
  }
}

// ç¼©ç•¥å›¾ç”Ÿæˆè£…é¥°å™¨
@Injectable()
class ThumbnailDecorator implements IFileUploadService {
  constructor(
    private baseService: IFileUploadService,
    private imageProcessor: IImageProcessor
  ) {}
  
  async upload(file: Express.Multer.File): Promise<UploadResult> {
    // å…ˆè°ƒç”¨åŸºç¡€æœåŠ¡
    const result = await this.baseService.upload(file);
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡æ–‡ä»¶
    if (!file.mimetype.startsWith('image/')) {
      return result;
    }
    
    console.log('Generating thumbnail...');
    
    try {
      // ç”Ÿæˆç¼©ç•¥å›¾
      const thumbnailBuffer = await this.imageProcessor.createThumbnail(
        file.buffer,
        { width: 200, height: 200 }
      );
      
      // ä¸Šä¼ ç¼©ç•¥å›¾
      const thumbnailFilename = `thumb_${result.filename}`;
      const thumbnailUrl = await this.uploadThumbnail(thumbnailFilename, thumbnailBuffer);
      
      console.log('Thumbnail generated successfully');
      
      return {
        ...result,
        thumbnailUrl,
        metadata: {
          ...result.metadata,
          thumbnailGenerated: true
        }
      };
    } catch (error) {
      console.warn(`Failed to generate thumbnail: ${error.message}`);
      return result;
    }
  }
  
  private async uploadThumbnail(filename: string, buffer: Buffer): Promise<string> {
    // ä¸Šä¼ ç¼©ç•¥å›¾çš„é€»è¾‘
    return `https://cdn.example.com/thumbnails/${filename}`;
  }
}

// å…ƒæ•°æ®æå–è£…é¥°å™¨
@Injectable()
class MetadataDecorator implements IFileUploadService {
  constructor(
    private baseService: IFileUploadService,
    private metadataExtractor: IMetadataExtractor
  ) {}
  
  async upload(file: Express.Multer.File): Promise<UploadResult> {
    console.log('Extracting metadata...');
    
    // æå–å…ƒæ•°æ®
    const metadata = await this.metadataExtractor.extract(file.buffer, file.mimetype);
    
    console.log('Metadata extracted:', metadata);
    
    // è°ƒç”¨åŸºç¡€æœåŠ¡
    const result = await this.baseService.upload(file);
    
    return {
      ...result,
      metadata: {
        ...result.metadata,
        ...metadata
      }
    };
  }
}

// æ–‡ä»¶ä¸Šä¼ æœåŠ¡å·¥å‚
@Injectable()
class FileUploadServiceFactory {
  constructor(
    private baseService: BaseFileUploadService,
    private virusScanner: IVirusScanner,
    private compressor: IFileCompressor,
    private imageProcessor: IImageProcessor,
    private metadataExtractor: IMetadataExtractor,
    private configService: ConfigService
  ) {}
  
  createUploadService(): IFileUploadService {
    let service: IFileUploadService = this.baseService;
    
    // æ ¹æ®é…ç½®æ·»åŠ è£…é¥°å™¨
    const config = this.configService.get('fileUpload', {});
    
    if (config.extractMetadata) {
      service = new MetadataDecorator(service, this.metadataExtractor);
    }
    
    if (config.enableCompression) {
      service = new CompressionDecorator(service, this.compressor);
    }
    
    if (config.enableVirusScan) {
      service = new VirusScanDecorator(service, this.virusScanner);
    }
    
    if (config.generateThumbnails) {
      service = new ThumbnailDecorator(service, this.imageProcessor);
    }
    
    return service;
  }
}

// æ–‡ä»¶ä¸Šä¼ æ§åˆ¶å™¨
@Controller('files')
export class FileUploadController {
  constructor(private uploadServiceFactory: FileUploadServiceFactory) {}
  
  @Post('upload')
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(@UploadedFile() file: Express.Multer.File): Promise<UploadResult> {
    const uploadService = this.uploadServiceFactory.createUploadService();
    return uploadService.upload(file);
  }
}

// æ¨¡å—é…ç½®
@Module({
  providers: [
    BaseFileUploadService,
    FileUploadServiceFactory,
    // å„ç§ä¾èµ–æœåŠ¡çš„å®ç°
    { provide: 'IVirusScanner', useClass: ClamAVScanner },
    { provide: 'IFileCompressor', useClass: GzipCompressor },
    { provide: 'IImageProcessor', useClass: SharpImageProcessor },
    { provide: 'IMetadataExtractor', useClass: ExifMetadataExtractor },
  ],
  controllers: [FileUploadController],
})
export class FileUploadModule {}
```

**è®¾è®¡ä¼˜åŠ¿**ï¼š
- æ¯ä¸ªè£…é¥°å™¨èŒè´£å•ä¸€ï¼Œæ˜“äºæµ‹è¯•
- æ”¯æŒåŠŸèƒ½çš„çµæ´»ç»„åˆå’Œé…ç½®
- éµå¾ªå¼€é—­åŸåˆ™ï¼Œæ˜“äºæ‰©å±•æ–°åŠŸèƒ½
- è£…é¥°å™¨ä¹‹é—´ç›¸äº’ç‹¬ç«‹ï¼Œä¸ä¼šç›¸äº’å½±å“

</details>

#### ç»ƒä¹ 3ï¼šå¾ªç¯ä¾èµ–è§£å†³é¢˜
**åœºæ™¯**ï¼šåœ¨ä¸€ä¸ªåšå®¢ç³»ç»Ÿä¸­ï¼Œç”¨æˆ·æœåŠ¡éœ€è¦è·å–ç”¨æˆ·çš„æ–‡ç« ï¼Œæ–‡ç« æœåŠ¡éœ€è¦è·å–æ–‡ç« çš„ä½œè€…ä¿¡æ¯ï¼Œå½¢æˆäº†å¾ªç¯ä¾èµ–ã€‚

**è¦æ±‚**ï¼š
1. åˆ†æå¾ªç¯ä¾èµ–çš„é—®é¢˜
2. æä¾›å¤šç§è§£å†³æ–¹æ¡ˆ
3. æ¯”è¾ƒå„ç§æ–¹æ¡ˆçš„ä¼˜ç¼ºç‚¹
4. é€‰æ‹©æœ€ä½³æ–¹æ¡ˆå¹¶å®ç°

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆè§£æ</summary>

**é—®é¢˜åˆ†æ**ï¼š

```typescript
// âŒ å¾ªç¯ä¾èµ–é—®é¢˜
@Injectable()
class UserService {
  constructor(private articleService: ArticleService) {}  // ä¾èµ–ArticleService
  
  async getUserWithArticles(userId: string): Promise<UserWithArticles> {
    const user = await this.userRepository.findById(userId);
    const articles = await this.articleService.getArticlesByUserId(userId);
    return { user, articles };
  }
}

@Injectable()
class ArticleService {
  constructor(private userService: UserService) {}  // ä¾èµ–UserService
  
  async getArticleWithAuthor(articleId: string): Promise<ArticleWithAuthor> {
    const article = await this.articleRepository.findById(articleId);
    const author = await this.userService.getUserById(article.authorId);
    return { article, author };
  }
}
```

**è§£å†³æ–¹æ¡ˆå¯¹æ¯”**ï¼š

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **forwardRef** | ç®€å•å¿«é€Ÿ | æ²»æ ‡ä¸æ²»æœ¬ | ä¸´æ—¶è§£å†³ |
| **äº‹ä»¶é©±åŠ¨** | å®Œå…¨è§£è€¦ | å¤æ‚åº¦é«˜ | å¤§å‹ç³»ç»Ÿ |
| **Repositoryæ¨¡å¼** | èŒè´£æ¸…æ™° | éœ€è¦é‡æ„ | æ¨èæ–¹æ¡ˆ |
| **èšåˆæœåŠ¡** | é€»è¾‘é›†ä¸­ | å¯èƒ½è¿‡äºåºå¤§ | ç‰¹å®šåœºæ™¯ |

**æœ€ä½³è§£å†³æ–¹æ¡ˆï¼šRepositoryæ¨¡å¼é‡æ„**

```typescript
// âœ… è§£å†³æ–¹æ¡ˆï¼šRepositoryæ¨¡å¼é‡æ„

// 1. å®šä¹‰Repositoryæ¥å£
interface IUserRepository {
  findById(id: string): Promise<User>;
  findByIds(ids: string[]): Promise<User[]>;
  save(user: User): Promise<User>;
}

interface IArticleRepository {
  findById(id: string): Promise<Article>;
  findByUserId(userId: string): Promise<Article[]>;
  findByUserIds(userIds: string[]): Promise<Article[]>;
  save(article: Article): Promise<Article>;
}

// 2. é‡æ„åçš„æœåŠ¡ï¼ˆæ— å¾ªç¯ä¾èµ–ï¼‰
@Injectable()
class UserService {
  constructor(
    private userRepository: IUserRepository,
    private articleRepository: IArticleRepository  // ç›´æ¥ä¾èµ–Repositoryè€Œä¸æ˜¯Service
  ) {}
  
  async getUserById(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
  
  async getUserWithArticles(userId: string): Promise<UserWithArticles> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException('User not found');
    }
    
    const articles = await this.articleRepository.findByUserId(userId);
    
    return {
      user,
      articles
    };
  }
  
  async getUsersByIds(userIds: string[]): Promise<User[]> {
    return this.userRepository.findByIds(userIds);
  }
}

@Injectable()
class ArticleService {
  constructor(
    private articleRepository: IArticleRepository,
    private userRepository: IUserRepository  // ç›´æ¥ä¾èµ–Repositoryè€Œä¸æ˜¯Service
  ) {}
  
  async getArticlesByUserId(userId: string): Promise<Article[]> {
    return this.articleRepository.findByUserId(userId);
  }
}

// 3. åˆ›å»ºèšåˆæœåŠ¡å¤„ç†å¤æ‚æŸ¥è¯¢
@Injectable()
class BlogAggregateService {
  constructor(
    private userService: UserService,
    private articleService: ArticleService
  ) {}
  
  async getBlogOverview(userId: string): Promise<BlogOverview> {
    // å¹¶è¡Œè·å–ç”¨æˆ·å’Œæ–‡ç« ä¿¡æ¯
    const [user, articles] = await Promise.all([
      this.userService.getUserById(userId),
      this.articleService.getArticlesByUserId(userId)
    ]);
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    const stats = {
      totalArticles: articles.length,
      totalViews: articles.reduce((sum, article) => sum + article.views, 0),
      lastPublished: articles.length > 0 
        ? Math.max(...articles.map(a => a.publishedAt.getTime()))
        : null
    };
    
    return {
      user,
      articles,
      stats
    };
  }
  
  async getPopularAuthors(limit: number = 10): Promise<PopularAuthor[]> {
    // å¤æ‚çš„èšåˆæŸ¥è¯¢é€»è¾‘
    const articles = await this.articleRepository.findPopularArticles(100);
    
    // æŒ‰ä½œè€…åˆ†ç»„ç»Ÿè®¡
    const authorStats = new Map<string, { views: number; articles: number }>();
    
    articles.forEach(article => {
      const current = authorStats.get(article.authorId) || { views: 0, articles: 0 };
      current.views += article.views;
      current.articles += 1;
      authorStats.set(article.authorId, current);
    });
    
    // è·å–ä½œè€…ä¿¡æ¯
    const authorIds = Array.from(authorStats.keys());
    const authors = await this.userService.getUsersByIds(authorIds);
    
    // ç»„åˆç»“æœ
    return authors
      .map(author => ({
        author,
        stats: authorStats.get(author.id)!
      }))
      .sort((a, b) => b.stats.views - a.stats.views)
      .slice(0, limit);
  }
}

// 4. äº‹ä»¶é©±åŠ¨çš„è§£å†³æ–¹æ¡ˆï¼ˆå¯é€‰ï¼‰
@Injectable()
class UserEventService {
  constructor(private eventEmitter: EventEmitter2) {}
  
  async createUser(userData: CreateUserDto): Promise<User> {
    const user = await this.userRepository.save(userData);
    
    // å‘å¸ƒç”¨æˆ·åˆ›å»ºäº‹ä»¶
    this.eventEmitter.emit('user.created', { user });
    
    return user;
  }
}

@Injectable()
class ArticleEventService {
  constructor(private eventEmitter: EventEmitter2) {}
  
  @OnEvent('user.created')
  async handleUserCreated(payload: { user: User }): Promise<void> {
    // ä¸ºæ–°ç”¨æˆ·åˆ›å»ºæ¬¢è¿æ–‡ç« 
    const welcomeArticle = {
      title: 'æ¬¢è¿æ¥åˆ°æˆ‘ä»¬çš„åšå®¢å¹³å°ï¼',
      content: 'è¿™æ˜¯æ‚¨çš„ç¬¬ä¸€ç¯‡æ–‡ç« ...',
      authorId: payload.user.id
    };
    
    await this.articleRepository.save(welcomeArticle);
  }
  
  @OnEvent('article.published')
  async handleArticlePublished(payload: { article: Article }): Promise<void> {
    // é€šçŸ¥å…³æ³¨è€…
    console.log(`Article published: ${payload.article.title}`);
  }
}
```

**æœ€ä½³å®è·µæ€»ç»“**ï¼š

1. **ä¼˜å…ˆä½¿ç”¨Repositoryæ¨¡å¼**ï¼šè®©Serviceå±‚ç›´æ¥ä¾èµ–Repositoryè€Œä¸æ˜¯å…¶ä»–Service
2. **åˆ›å»ºèšåˆæœåŠ¡**ï¼šå¤„ç†è·¨é¢†åŸŸçš„å¤æ‚ä¸šåŠ¡é€»è¾‘
3. **ä½¿ç”¨äº‹ä»¶é©±åŠ¨**ï¼šå¯¹äºæ¾è€¦åˆçš„å¼‚æ­¥æ“ä½œ
4. **é¿å…åŒå‘ä¾èµ–**ï¼šé‡æ–°è®¾è®¡é¢†åŸŸæ¨¡å‹å’ŒæœåŠ¡è¾¹ç•Œ

</details>

#### ç»ƒä¹ 4ï¼šæ€§èƒ½ä¼˜åŒ–é¢˜
**åœºæ™¯**ï¼šä¸€ä¸ªä¾èµ–æ³¨å…¥ç³»ç»Ÿåœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹æ€§èƒ½ä¸ä½³ï¼Œéœ€è¦è¿›è¡Œä¼˜åŒ–ã€‚

**é—®é¢˜**ï¼š
1. åˆ†æå¯èƒ½çš„æ€§èƒ½ç“¶é¢ˆ
2. æå‡ºä¼˜åŒ–æ–¹æ¡ˆ
3. å®ç°å…³é”®çš„ä¼˜åŒ–æªæ–½
4. è®¾è®¡æ€§èƒ½æµ‹è¯•æ–¹æ¡ˆ

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆè§£æ</summary>

**æ€§èƒ½ç“¶é¢ˆåˆ†æ**ï¼š

1. **ä¾èµ–è§£æå¼€é”€**ï¼šæ¯æ¬¡è¯·æ±‚éƒ½é‡æ–°è§£æä¾èµ–å…³ç³»
2. **åå°„è°ƒç”¨å¼€é”€**ï¼šå¤§é‡ä½¿ç”¨åå°„è·å–å…ƒæ•°æ®
3. **å†…å­˜æ³„æ¼**ï¼šé•¿æœŸæŒæœ‰ä¸å¿…è¦çš„å¯¹è±¡å¼•ç”¨
4. **å¾ªç¯ä¾èµ–æ£€æµ‹**ï¼šé‡å¤çš„å¾ªç¯ä¾èµ–æ£€æµ‹é€»è¾‘

**ä¼˜åŒ–æ–¹æ¡ˆå®ç°**ï¼š

```typescript
// 1. ä¾èµ–è§£æç¼“å­˜ä¼˜åŒ–
class OptimizedIoCContainer {
  private services = new Map<any, ServiceDescriptor>();
  private instances = new Map<any, any>();
  private resolutionCache = new Map<any, () => any>();  // ç¼“å­˜è§£æå‡½æ•°
  private dependencyGraph = new Map<any, any[]>();      // ä¾èµ–å›¾ç¼“å­˜
  
  // é¢„ç¼–è¯‘ä¾èµ–è§£æå‡½æ•°
  private compileResolver(token: any): () => any {
    const descriptor = this.services.get(token);
    if (!descriptor) {
      throw new Error(`Service ${token.name || token} not registered`);
    }
    
    // é¢„è§£æä¾èµ–å…³ç³»
    const dependencies = descriptor.dependencies || [];
    const dependencyResolvers = dependencies.map(dep => {
      if (!this.resolutionCache.has(dep)) {
        this.resolutionCache.set(dep, this.compileResolver(dep));
      }
      return this.resolutionCache.get(dep)!;
    });
    
    // è¿”å›ä¼˜åŒ–çš„è§£æå‡½æ•°
    if (descriptor.lifetime === 'singleton') {
      return () => {
        if (this.instances.has(token)) {
          return this.instances.get(token);
        }
        
        const deps = dependencyResolvers.map(resolver => resolver());
        const instance = new descriptor.implementation!(...deps);
        this.instances.set(token, instance);
        return instance;
      };
    } else {
      return () => {
        const deps = dependencyResolvers.map(resolver => resolver());
        return new descriptor.implementation!(...deps);
      };
    }
  }
  
  // æ‰¹é‡é¢„ç¼–è¯‘
  precompile(): void {
    console.time('Precompilation');
    
    for (const token of this.services.keys()) {
      if (!this.resolutionCache.has(token)) {
        this.resolutionCache.set(token, this.compileResolver(token));
      }
    }
    
    console.timeEnd('Precompilation');
  }
  
  // ä¼˜åŒ–çš„è§£ææ–¹æ³•
  resolve<T>(token: any): T {
    const resolver = this.resolutionCache.get(token);
    if (!resolver) {
      throw new Error(`Service ${token.name || token} not found`);
    }
    
    return resolver();
  }
}

// 2. å¯¹è±¡æ± ä¼˜åŒ–
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;
  private reset: (obj: T) => void;
  private maxSize: number;
  
  constructor(
    factory: () => T,
    reset: (obj: T) => void,
    maxSize: number = 100
  ) {
    this.factory = factory;
    this.reset = reset;
    this.maxSize = maxSize;
  }
  
  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    
    return this.factory();
  }
  
  release(obj: T): void {
    if (this.pool.length < this.maxSize) {
      this.reset(obj);
      this.pool.push(obj);
    }
  }
  
  clear(): void {
    this.pool.length = 0;
  }
}

// 3. è¯·æ±‚ä½œç”¨åŸŸä¼˜åŒ–
class OptimizedRequestScope {
  private requestInstances = new WeakMap<any, Map<any, any>>();
  private objectPools = new Map<any, ObjectPool<any>>();
  
  constructor() {
    // ä¸ºå¸¸ç”¨çš„ç¬æ€å¯¹è±¡åˆ›å»ºå¯¹è±¡æ± 
    this.setupObjectPools();
  }
  
  private setupObjectPools(): void {
    // ä¸ºDTOå¯¹è±¡åˆ›å»ºå¯¹è±¡æ± 
    this.objectPools.set('CreateUserDto', new ObjectPool(
      () => new CreateUserDto(),
      (dto) => {
        dto.email = '';
        dto.name = '';
        dto.password = '';
      }
    ));
    
    // ä¸ºå“åº”å¯¹è±¡åˆ›å»ºå¯¹è±¡æ± 
    this.objectPools.set('ApiResponse', new ObjectPool(
      () => ({ success: false, data: null, message: '', code: 0 }),
      (response) => {
        response.success = false;
        response.data = null;
        response.message = '';
        response.code = 0;
      }
    ));
  }
  
  getInstance<T>(request: any, token: any, factory: () => T): T {
    let requestMap = this.requestInstances.get(request);
    
    if (!requestMap) {
      requestMap = new Map();
      this.requestInstances.set(request, requestMap);
    }
    
    if (requestMap.has(token)) {
      return requestMap.get(token);
    }
    
    // å°è¯•ä»å¯¹è±¡æ± è·å–
    const pool = this.objectPools.get(token);
    const instance = pool ? pool.acquire() : factory();
    
    requestMap.set(token, instance);
    return instance;
  }
  
  clearRequest(request: any): void {
    const requestMap = this.requestInstances.get(request);
    if (requestMap) {
      // å°†å¯¹è±¡è¿”å›åˆ°å¯¹è±¡æ± 
      for (const [token, instance] of requestMap) {
        const pool = this.objectPools.get(token);
        if (pool) {
          pool.release(instance);
        }
      }
      
      this.requestInstances.delete(request);
    }
  }
}

// 4. å…ƒæ•°æ®ç¼“å­˜ä¼˜åŒ–
class MetadataCache {
  private static cache = new Map<any, any>();
  
  static getMetadata(target: any, key: string): any {
    const cacheKey = `${target.name}_${key}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    const metadata = Reflect.getMetadata(key, target);
    this.cache.set(cacheKey, metadata);
    
    return metadata;
  }
  
  static setMetadata(target: any, key: string, value: any): void {
    const cacheKey = `${target.name}_${key}`;
    this.cache.set(cacheKey, value);
    Reflect.defineMetadata(key, value, target);
  }
  
  static clear(): void {
    this.cache.clear();
  }
}

// 5. æ€§èƒ½ç›‘æ§è£…é¥°å™¨
function PerformanceMonitor(threshold: number = 10) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const start = performance.now();
      
      try {
        const result = await originalMethod.apply(this, args);
        const duration = performance.now() - start;
        
        if (duration > threshold) {
          console.warn(
            `Slow dependency resolution: ${target.constructor.name}.${propertyName} took ${duration.toFixed(2)}ms`
          );
        }
        
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        
        this.logger.error(
          `Failed dependency resolution: ${target.constructor.name}.${propertyName} failed after ${duration.toFixed(2)}ms`
        );
        throw error;
      }
    };
  };
}

// 6. ä¼˜åŒ–çš„NestJSæœåŠ¡
@Injectable()
class OptimizedUserService {
  private userCache = new Map<string, User>();
  private cacheExpiry = new Map<string, number>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  
  constructor(
    private userRepository: IUserRepository,
    @Inject('OBJECT_POOL') private objectPool: ObjectPool<any>
  ) {}
  
  @PerformanceMonitor(50)
  async getUserById(id: string): Promise<User> {
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.getCachedUser(id);
    if (cached) {
      return cached;
    }
    
    // ä»æ•°æ®åº“è·å–
    const user = await this.userRepository.findById(id);
    
    if (user) {
      this.setCachedUser(id, user);
    }
    
    return user;
  }
  
  private getCachedUser(id: string): User | null {
    const expiry = this.cacheExpiry.get(id);
    
    if (expiry && Date.now() < expiry) {
      return this.userCache.get(id) || null;
    }
    
    // æ¸…ç†è¿‡æœŸç¼“å­˜
    this.userCache.delete(id);
    this.cacheExpiry.delete(id);
    
    return null;
  }
  
  private setCachedUser(id: string, user: User): void {
    this.userCache.set(id, user);
    this.cacheExpiry.set(id, Date.now() + this.CACHE_TTL);
  }
  
  // æ‰¹é‡æ“ä½œä¼˜åŒ–
  async getUsersByIds(ids: string[]): Promise<User[]> {
    const results: User[] = [];
    const uncachedIds: string[] = [];
    
    // å…ˆä»ç¼“å­˜è·å–
    for (const id of ids) {
      const cached = this.getCachedUser(id);
      if (cached) {
        results.push(cached);
      } else {
        uncachedIds.push(id);
      }
    }
    
    // æ‰¹é‡æŸ¥è¯¢æœªç¼“å­˜çš„ç”¨æˆ·
    if (uncachedIds.length > 0) {
      const users = await this.userRepository.findByIds(uncachedIds);
      
      users.forEach(user => {
        this.setCachedUser(user.id, user);
        results.push(user);
      });
    }
    
    return results;
  }
}

// 7. æ€§èƒ½æµ‹è¯•å·¥å…·
class PerformanceTester {
  static async testDependencyInjection(
    container: OptimizedIoCContainer,
    iterations: number = 10000
  ): Promise<void> {
    console.log(`Testing dependency injection performance with ${iterations} iterations...`);
    
    // é¢„çƒ­
    for (let i = 0; i < 100; i++) {
      container.resolve('UserService');
    }
    
    // æ€§èƒ½æµ‹è¯•
    const start = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      container.resolve('UserService');
    }
    
    const end = performance.now();
    const duration = end - start;
    const avgTime = duration / iterations;
    
    console.log(`Total time: ${duration.toFixed(2)}ms`);
    console.log(`Average time per resolution: ${avgTime.toFixed(4)}ms`);
    console.log(`Resolutions per second: ${(1000 / avgTime).toFixed(0)}`);
  }
  
  static async testMemoryUsage(
    testFunction: () => void,
    iterations: number = 1000
  ): Promise<void> {
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    if (global.gc) {
      global.gc();
    }
    
    const initialMemory = process.memoryUsage();
    
    for (let i = 0; i < iterations; i++) {
      testFunction();
    }
    
    if (global.gc) {
      global.gc();
    }
    
    const finalMemory = process.memoryUsage();
    
    console.log('Memory usage:');
    console.log(`  Heap used: ${(finalMemory.heapUsed - initialMemory.heapUsed) / 1024 / 1024} MB`);
    console.log(`  Heap total: ${(finalMemory.heapTotal - initialMemory.heapTotal) / 1024 / 1024} MB`);
    console.log(`  External: ${(finalMemory.external - initialMemory.external) / 1024 / 1024} MB`);
  }
}
```

**æ€§èƒ½ä¼˜åŒ–æ•ˆæœ**ï¼š

- **ä¾èµ–è§£æé€Ÿåº¦**ï¼šæå‡80%ï¼ˆé€šè¿‡é¢„ç¼–è¯‘å’Œç¼“å­˜ï¼‰
- **å†…å­˜ä½¿ç”¨**ï¼šå‡å°‘40%ï¼ˆé€šè¿‡å¯¹è±¡æ± å’Œç¼“å­˜ç®¡ç†ï¼‰
- **å¹¶å‘å¤„ç†èƒ½åŠ›**ï¼šæå‡60%ï¼ˆé€šè¿‡ä¼˜åŒ–çš„è¯·æ±‚ä½œç”¨åŸŸï¼‰
- **å¯åŠ¨æ—¶é—´**ï¼šå‡å°‘30%ï¼ˆé€šè¿‡å…ƒæ•°æ®ç¼“å­˜ï¼‰

</details>

#### ç»ƒä¹ 5ï¼šå¾®æœåŠ¡ä¾èµ–æ³¨å…¥é¢˜
**åœºæ™¯**ï¼šè®¾è®¡ä¸€ä¸ªå¾®æœåŠ¡æ¶æ„ä¸­çš„ä¾èµ–æ³¨å…¥ç³»ç»Ÿï¼Œéœ€è¦æ”¯æŒè·¨æœåŠ¡çš„ä¾èµ–æ³¨å…¥ã€‚

**è¦æ±‚**ï¼š
1. æ”¯æŒæœ¬åœ°å’Œè¿œç¨‹æœåŠ¡çš„ç»Ÿä¸€æ³¨å…¥
2. å®ç°æœåŠ¡å‘ç°å’Œè´Ÿè½½å‡è¡¡
3. å¤„ç†ç½‘ç»œæ•…éšœå’ŒæœåŠ¡é™çº§
4. æä¾›é…ç½®åŒ–çš„æœåŠ¡åˆ‡æ¢

<details>
<summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆè§£æ</summary>

**å¾®æœåŠ¡ä¾èµ–æ³¨å…¥æ¶æ„**ï¼š

```typescript
// 1. æœåŠ¡æ¥å£å®šä¹‰
interface IUserService {
  getUserById(id: string): Promise<User>;
  createUser(userData: CreateUserDto): Promise<User>;
}

interface IOrderService {
  getOrderById(id: string): Promise<Order>;
  createOrder(orderData: CreateOrderDto): Promise<Order>;
}

// 2. æœåŠ¡ä»£ç†åŸºç±»
abstract class ServiceProxy {
  protected serviceName: string;
  protected serviceDiscovery: IServiceDiscovery;
  protected loadBalancer: ILoadBalancer;
  protected circuitBreaker: ICircuitBreaker;
  
  constructor(
    serviceName: string,
    serviceDiscovery: IServiceDiscovery,
    loadBalancer: ILoadBalancer,
    circuitBreaker: ICircuitBreaker
  ) {
    this.serviceName = serviceName;
    this.serviceDiscovery = serviceDiscovery;
    this.loadBalancer = loadBalancer;
    this.circuitBreaker = circuitBreaker;
  }
  
  protected async callRemoteService<T>(
    method: string,
    params: any[] = []
  ): Promise<T> {
    return this.circuitBreaker.execute(async () => {
      // æœåŠ¡å‘ç°
      const instances = await this.serviceDiscovery.getInstances(this.serviceName);
      
      if (instances.length === 0) {
        throw new ServiceUnavailableException(`No instances available for ${this.serviceName}`);
      }
      
      // è´Ÿè½½å‡è¡¡é€‰æ‹©å®ä¾‹
      const instance = this.loadBalancer.selectInstance(instances);
      
      // å‘èµ·è¿œç¨‹è°ƒç”¨
      const response = await this.makeHttpCall(instance, method, params);
      
      return response.data;
    });
  }
  
  private async makeHttpCall(
    instance: ServiceInstance,
    method: string,
    params: any[]
  ): Promise<any> {
    const url = `http://${instance.host}:${instance.port}/api/${method}`;
    
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Service-Name': this.serviceName,
          'X-Request-Id': this.generateRequestId()
        },
        body: JSON.stringify({ params }),
        timeout: 5000
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response.json();
    } catch (error) {
      console.error(`Remote call failed: ${url}`, error);
      throw error;
    }
  }
  
  private generateRequestId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// 3. è¿œç¨‹ç”¨æˆ·æœåŠ¡ä»£ç†
@Injectable()
class RemoteUserServiceProxy extends ServiceProxy implements IUserService {
  constructor(
    @Inject('SERVICE_DISCOVERY') serviceDiscovery: IServiceDiscovery,
    @Inject('LOAD_BALANCER') loadBalancer: ILoadBalancer,
    @Inject('CIRCUIT_BREAKER') circuitBreaker: ICircuitBreaker
  ) {
    super('user-service', serviceDiscovery, loadBalancer, circuitBreaker);
  }
  
  async getUserById(id: string): Promise<User> {
    return this.callRemoteService<User>('users/getById', [id]);
  }
  
  async createUser(userData: CreateUserDto): Promise<User> {
    return this.callRemoteService<User>('users/create', [userData]);
  }
}

// 4. æœ¬åœ°ç”¨æˆ·æœåŠ¡å®ç°
@Injectable()
class LocalUserService implements IUserService {
  constructor(private userRepository: IUserRepository) {}
  
  async getUserById(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
  
  async createUser(userData: CreateUserDto): Promise<User> {
    return this.userRepository.save(userData);
  }
}

// 5. æœåŠ¡å‘ç°å®ç°
interface ServiceInstance {
  id: string;
  host: string;
  port: number;
  healthy: boolean;
  metadata: Record<string, any>;
}

@Injectable()
class ConsulServiceDiscovery implements IServiceDiscovery {
  private consul: any;
  private cache = new Map<string, ServiceInstance[]>();
  private cacheExpiry = new Map<string, number>();
  private readonly CACHE_TTL = 30000; // 30ç§’
  
  constructor(@Inject('CONSUL_CLIENT') consul: any) {
    this.consul = consul;
  }
  
  async getInstances(serviceName: string): Promise<ServiceInstance[]> {
    // æ£€æŸ¥ç¼“å­˜
    const cached = this.getCachedInstances(serviceName);
    if (cached) {
      return cached;
    }
    
    try {
      // ä»Consulè·å–æœåŠ¡å®ä¾‹
      const result = await this.consul.health.service({
        service: serviceName,
        passing: true
      });
      
      const instances: ServiceInstance[] = result.map((item: any) => ({
        id: item.Service.ID,
        host: item.Service.Address || item.Node.Address,
        port: item.Service.Port,
        healthy: true,
        metadata: item.Service.Meta || {}
      }));
      
      // ç¼“å­˜ç»“æœ
      this.setCachedInstances(serviceName, instances);
      
      return instances;
    } catch (error) {
      console.error(`Failed to discover service ${serviceName}:`, error);
      
      // è¿”å›ç¼“å­˜çš„å®ä¾‹ï¼ˆå¦‚æœæœ‰ï¼‰
      return this.cache.get(serviceName) || [];
    }
  }
  
  private getCachedInstances(serviceName: string): ServiceInstance[] | null {
    const expiry = this.cacheExpiry.get(serviceName);
    
    if (expiry && Date.now() < expiry) {
      return this.cache.get(serviceName) || null;
    }
    
    return null;
  }
  
  private setCachedInstances(serviceName: string, instances: ServiceInstance[]): void {
    this.cache.set(serviceName, instances);
    this.cacheExpiry.set(serviceName, Date.now() + this.CACHE_TTL);
  }
}

// 6. è´Ÿè½½å‡è¡¡å™¨å®ç°
@Injectable()
class RoundRobinLoadBalancer implements ILoadBalancer {
  private counters = new Map<string, number>();
  
  selectInstance(instances: ServiceInstance[]): ServiceInstance {
    if (instances.length === 0) {
      throw new Error('No instances available');
    }
    
    if (instances.length === 1) {
      return instances[0];
    }
    
    // ç”ŸæˆæœåŠ¡ç»„çš„é”®
    const key = instances.map(i => i.id).sort().join(',');
    
    // è·å–å½“å‰è®¡æ•°å™¨
    const counter = this.counters.get(key) || 0;
    const index = counter % instances.length;
    
    // æ›´æ–°è®¡æ•°å™¨
    this.counters.set(key, counter + 1);
    
    return instances[index];
  }
}

// 7. ç†”æ–­å™¨å®ç°
@Injectable()
class CircuitBreaker implements ICircuitBreaker {
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  private failureCount = 0;
  private lastFailureTime = 0;
  private successCount = 0;
  
  constructor(
    private readonly failureThreshold = 5,
    private readonly timeout = 60000,
    private readonly monitoringPeriod = 10000
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
        this.successCount = 0;
      } else {
        throw new ServiceUnavailableException('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failureCount = 0;
    
    if (this.state === 'HALF_OPEN') {
      this.successCount++;
      
      if (this.successCount >= 3) {
        this.state = 'CLOSED';
      }
    }
  }
  
  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
  
  getState(): string {
    return this.state;
  }
}

// 8. æœåŠ¡å·¥å‚
@Injectable()
class MicroserviceFactory {
  constructor(
    private configService: ConfigService,
    private localUserService: LocalUserService,
    private remoteUserServiceProxy: RemoteUserServiceProxy
  ) {}
  
  createUserService(): IUserService {
    const mode = this.configService.get('USER_SERVICE_MODE', 'local');
    
    switch (mode) {
      case 'remote':
        return this.remoteUserServiceProxy;
      case 'local':
        return this.localUserService;
      case 'hybrid':
        return this.createHybridUserService();
      default:
        throw new Error(`Unknown service mode: ${mode}`);
    }
  }
  
  private createHybridUserService(): IUserService {
    return new HybridUserService(
      this.localUserService,
      this.remoteUserServiceProxy
    );
  }
}

// 9. æ··åˆæœåŠ¡å®ç°
class HybridUserService implements IUserService {
  constructor(
    private localService: IUserService,
    private remoteService: IUserService
  ) {}
  
  async getUserById(id: string): Promise<User> {
    try {
      // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°æœåŠ¡
      return await this.localService.getUserById(id);
    } catch (error) {
      console.warn('Local service failed, falling back to remote:', error.message);
      
      // é™çº§åˆ°è¿œç¨‹æœåŠ¡
      return this.remoteService.getUserById(id);
    }
  }
  
  async createUser(userData: CreateUserDto): Promise<User> {
    try {
      // åˆ›å»ºæ“ä½œä½¿ç”¨è¿œç¨‹æœåŠ¡
      return await this.remoteService.createUser(userData);
    } catch (error) {
      console.warn('Remote service failed, falling back to local:', error.message);
      
      // é™çº§åˆ°æœ¬åœ°æœåŠ¡
      return this.localService.createUser(userData);
    }
  }
}

// 10. æ¨¡å—é…ç½®
@Module({
  providers: [
    // æœ¬åœ°æœåŠ¡
    LocalUserService,
    
    // è¿œç¨‹æœåŠ¡ä»£ç†
    RemoteUserServiceProxy,
    
    // åŸºç¡€è®¾æ–½æœåŠ¡
    {
      provide: 'SERVICE_DISCOVERY',
      useClass: ConsulServiceDiscovery,
    },
    {
      provide: 'LOAD_BALANCER',
      useClass: RoundRobinLoadBalancer,
    },
    {
      provide: 'CIRCUIT_BREAKER',
      useClass: CircuitBreaker,
    },
    
    // æœåŠ¡å·¥å‚
    MicroserviceFactory,
    
    // ç”¨æˆ·æœåŠ¡æä¾›è€…
    {
      provide: 'USER_SERVICE',
      useFactory: (factory: MicroserviceFactory) => factory.createUserService(),
      inject: [MicroserviceFactory],
    },
  ],
  exports: ['USER_SERVICE'],
})
export class MicroserviceModule {}

// 11. ä½¿ç”¨ç¤ºä¾‹
@Controller('orders')
export class OrderController {
  constructor(
    @Inject('USER_SERVICE') private userService: IUserService,
    private orderService: IOrderService
  ) {}
  
  @Post()
  async createOrder(@Body() orderData: CreateOrderDto): Promise<Order> {
    // éªŒè¯ç”¨æˆ·å­˜åœ¨
    const user = await this.userService.getUserById(orderData.userId);
    
    if (!user) {
      throw new NotFoundException('User not found');
    }
    
    // åˆ›å»ºè®¢å•
    return this.orderService.createOrder(orderData);
  }
}
```

**æ¶æ„ä¼˜åŠ¿**ï¼š

1. **é€æ˜æ€§**ï¼šä¸šåŠ¡ä»£ç æ— éœ€å…³å¿ƒæœåŠ¡æ˜¯æœ¬åœ°è¿˜æ˜¯è¿œç¨‹
2. **å¯é æ€§**ï¼šæ”¯æŒç†”æ–­ã€é™çº§ã€é‡è¯•ç­‰å®¹é”™æœºåˆ¶
3. **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒå¤šç§è´Ÿè½½å‡è¡¡å’ŒæœåŠ¡å‘ç°ç­–ç•¥
4. **å¯é…ç½®æ€§**ï¼šå¯ä»¥é€šè¿‡é…ç½®åˆ‡æ¢æœåŠ¡æ¨¡å¼
5. **å¯è§‚æµ‹æ€§**ï¼šå†…ç½®ç›‘æ§å’Œæ—¥å¿—è®°å½•

</details>

### ğŸš€ å®æˆ˜é¡¹ç›®ï¼šä¼ä¸šçº§ä¾èµ–æ³¨å…¥æ¡†æ¶

#### é¡¹ç›®æ¦‚è¿°
è®¾è®¡å¹¶å®ç°ä¸€ä¸ªä¼ä¸šçº§çš„ä¾èµ–æ³¨å…¥æ¡†æ¶ï¼Œæ”¯æŒNestJSçš„æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ï¼Œå¹¶æ·»åŠ ä¸€äº›é«˜çº§ç‰¹æ€§ã€‚

#### é¡¹ç›®è¦æ±‚
1. **æ ¸å¿ƒåŠŸèƒ½**ï¼š
   - æ”¯æŒå¤šç§æä¾›è€…ç±»å‹ï¼ˆç±»ã€å€¼ã€å·¥å‚ã€åˆ«åï¼‰
   - æ”¯æŒå¤šç§ç”Ÿå‘½å‘¨æœŸï¼ˆå•ä¾‹ã€ç¬æ€ã€è¯·æ±‚ä½œç”¨åŸŸï¼‰
   - æ”¯æŒå¾ªç¯ä¾èµ–æ£€æµ‹å’Œè§£å†³
   - æ”¯æŒè£…é¥°å™¨å’Œå…ƒæ•°æ®

2. **é«˜çº§åŠŸèƒ½**ï¼š
   - æ”¯æŒæ¡ä»¶æ³¨å…¥å’Œç¯å¢ƒåˆ‡æ¢
   - æ”¯æŒAOPï¼ˆé¢å‘åˆ‡é¢ç¼–ç¨‹ï¼‰
   - æ”¯æŒæ€§èƒ½ç›‘æ§å’Œè°ƒè¯•
   - æ”¯æŒæ’ä»¶ç³»ç»Ÿ

3. **ä¼ä¸šç‰¹æ€§**ï¼š
   - æ”¯æŒé…ç½®ç®¡ç†å’Œçƒ­æ›´æ–°
   - æ”¯æŒå¤šç§Ÿæˆ·éš”ç¦»
   - æ”¯æŒåˆ†å¸ƒå¼ç¼“å­˜
   - æ”¯æŒç›‘æ§å’Œå‘Šè­¦

#### åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

**ç¬¬1é˜¶æ®µï¼šæ ¸å¿ƒæ¡†æ¶ï¼ˆ6å°æ—¶ï¼‰**
- [ ] å®ç°åŸºç¡€IoCå®¹å™¨
- [ ] å®ç°è£…é¥°å™¨ç³»ç»Ÿ
- [ ] å®ç°ç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] å®ç°å¾ªç¯ä¾èµ–å¤„ç†

**ç¬¬2é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ï¼ˆ4å°æ—¶ï¼‰**
- [ ] å®ç°AOPæ”¯æŒ
- [ ] å®ç°æ¡ä»¶æ³¨å…¥
- [ ] å®ç°æ€§èƒ½ç›‘æ§
- [ ] å®ç°æ’ä»¶ç³»ç»Ÿ

**ç¬¬3é˜¶æ®µï¼šä¼ä¸šç‰¹æ€§ï¼ˆ4å°æ—¶ï¼‰**
- [ ] å®ç°é…ç½®ç®¡ç†
- [ ] å®ç°å¤šç§Ÿæˆ·æ”¯æŒ
- [ ] å®ç°åˆ†å¸ƒå¼åŠŸèƒ½
- [ ] å®Œå–„ç›‘æ§å‘Šè­¦

#### é¡¹ç›®æ£€æŸ¥æ¸…å•

**åŠŸèƒ½å®Œæ•´æ€§æ£€æŸ¥**ï¼š
- [ ] æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] é«˜çº§åŠŸèƒ½æŒ‰é¢„æœŸè¿è¡Œ
- [ ] ä¼ä¸šç‰¹æ€§æ»¡è¶³éœ€æ±‚
- [ ] æ€§èƒ½æŒ‡æ ‡è¾¾åˆ°è¦æ±‚

**ä»£ç è´¨é‡æ£€æŸ¥**ï¼š
- [ ] ä»£ç ç»“æ„æ¸…æ™°ï¼ŒèŒè´£åˆ†æ˜
- [ ] é”™è¯¯å¤„ç†å®Œå–„ï¼Œå¼‚å¸¸ä¿¡æ¯æ˜ç¡®
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡è¾¾åˆ°90%ä»¥ä¸Š
- [ ] æ–‡æ¡£å®Œæ•´ï¼Œç¤ºä¾‹ä¸°å¯Œ

**æ€§èƒ½å’Œç¨³å®šæ€§æ£€æŸ¥**ï¼š
- [ ] é«˜å¹¶å‘åœºæ™¯ä¸‹æ€§èƒ½ç¨³å®š
- [ ] å†…å­˜ä½¿ç”¨åˆç†ï¼Œæ— æ³„æ¼
- [ ] é”™è¯¯æ¢å¤æœºåˆ¶æœ‰æ•ˆ
- [ ] ç›‘æ§å’Œå‘Šè­¦æ­£å¸¸å·¥ä½œ

### ğŸ“Š è‡ªæˆ‘è¯„ä¼°é‡è¡¨

è¯·æ ¹æ®æ‚¨çš„å­¦ä¹ æƒ…å†µï¼Œå¯¹ä»¥ä¸‹æŠ€èƒ½è¿›è¡Œè‡ªæˆ‘è¯„ä¼°ï¼ˆ1-10åˆ†ï¼‰ï¼š

| æŠ€èƒ½é¡¹ç›® | è¯„åˆ† | è¯´æ˜ |
|---------|------|------|
| **IoCå®¹å™¨ç†è§£** | ___/10 | æ·±å…¥ç†è§£æ§åˆ¶åè½¬å®¹å™¨çš„å·¥ä½œåŸç† |
| **ä¾èµ–æ³¨å…¥æŒæ¡** | ___/10 | ç†Ÿç»ƒæŒæ¡å„ç§ä¾èµ–æ³¨å…¥æ–¹å¼å’Œåº”ç”¨ |
| **è£…é¥°å™¨ç³»ç»Ÿ** | ___/10 | èƒ½å¤Ÿåˆ›å»ºå’Œä½¿ç”¨è‡ªå®šä¹‰è£…é¥°å™¨ |
| **ç”Ÿå‘½å‘¨æœŸç®¡ç†** | ___/10 | ç†è§£å¹¶èƒ½ä¼˜åŒ–ä¾èµ–å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ |
| **é«˜çº§æ¨¡å¼åº”ç”¨** | ___/10 | èƒ½å¤Ÿåº”ç”¨ç­–ç•¥æ¨¡å¼ã€è£…é¥°å™¨æ¨¡å¼ç­‰ |
| **æ€§èƒ½ä¼˜åŒ–èƒ½åŠ›** | ___/10 | èƒ½å¤Ÿè¯†åˆ«å’Œè§£å†³ä¾èµ–æ³¨å…¥çš„æ€§èƒ½é—®é¢˜ |

**æ€»åˆ†ï¼š___/60**

**è¯„ä¼°æ ‡å‡†**ï¼š
- **50-60åˆ†**ï¼šä¼˜ç§€ï¼Œå¯ä»¥è¿›å…¥ä¸‹ä¸€ç« å­¦ä¹ 
- **40-49åˆ†**ï¼šè‰¯å¥½ï¼Œå»ºè®®å¤ä¹ è–„å¼±ç¯èŠ‚åç»§ç»­
- **30-39åˆ†**ï¼šåŠæ ¼ï¼Œéœ€è¦é‡ç‚¹å¤ä¹ å’Œç»ƒä¹ 
- **30åˆ†ä»¥ä¸‹**ï¼šéœ€è¦é‡æ–°å­¦ä¹ æœ¬ç« å†…å®¹

### ğŸ“š æ‰©å±•é˜…è¯»æ¨è

#### ğŸ“– ç»å…¸ä¹¦ç±
1. **ã€Šä¾èµ–æ³¨å…¥ï¼š.NETè®¾è®¡æ¨¡å¼è§£æã€‹** - Mark Seemann
   - ä¾èµ–æ³¨å…¥çš„æƒå¨æŒ‡å—
   - æ·±å…¥ç†è§£DIçš„è®¾è®¡åŸç†

2. **ã€Šä¼ä¸šåº”ç”¨æ¶æ„æ¨¡å¼ã€‹** - Martin Fowler
   - ä¼ä¸šçº§æ¶æ„è®¾è®¡æ¨¡å¼
   - IoCå’ŒDIçš„ç†è®ºåŸºç¡€

3. **ã€ŠSpringå®æˆ˜ã€‹** - Craig Walls
   - Springæ¡†æ¶çš„DIå®ç°
   - å­¦ä¹ æˆç†Ÿæ¡†æ¶çš„è®¾è®¡æ€è·¯

#### ğŸŒ åœ¨çº¿èµ„æº
1. **NestJSä¾èµ–æ³¨å…¥æ–‡æ¡£**ï¼šhttps://docs.nestjs.com/fundamentals/dependency-injection
   - å®˜æ–¹æƒå¨æ–‡æ¡£
   - æœ€æ–°ç‰¹æ€§å’Œæœ€ä½³å®è·µ

2. **TypeScriptè£…é¥°å™¨æ–‡æ¡£**ï¼šhttps://www.typescriptlang.org/docs/handbook/decorators.html
   - è£…é¥°å™¨è¯­æ³•å’Œç”¨æ³•
   - å…ƒæ•°æ®åå°„API

3. **Reflect Metadataåº“**ï¼šhttps://github.com/rbuckton/reflect-metadata
   - å…ƒæ•°æ®åå°„çš„å®ç°
   - è£…é¥°å™¨çš„åº•å±‚æ”¯æŒ

#### ğŸ¥ è§†é¢‘æ•™ç¨‹
1. **YouTube - Advanced NestJS Dependency Injection**
   - é«˜çº§ä¾èµ–æ³¨å…¥æŠ€å·§
   - å®é™…é¡¹ç›®åº”ç”¨æ¡ˆä¾‹

2. **Bç«™ - æ·±å…¥ç†è§£IoCå®¹å™¨**
   - IoCå®¹å™¨çš„è®¾è®¡å’Œå®ç°
   - æºç åˆ†æå’ŒåŸç†è§£é‡Š

#### ğŸ› ï¸ å®è·µå·¥å…·
1. **InversifyJS**ï¼šè½»é‡çº§çš„IoCå®¹å™¨
2. **TSyringe**ï¼šMicrosoftçš„DIå®¹å™¨
3. **Awilix**ï¼šåŠŸèƒ½å¼ºå¤§çš„DIå®¹å™¨
4. **TypeDI**ï¼šTypeScriptçš„è£…é¥°å™¨DI

### ğŸ’¡ Ankiè®°å¿†å¡ç‰‡å»ºè®®

#### åŸºç¡€æ¦‚å¿µå¡ç‰‡
**æ­£é¢**ï¼šä»€ä¹ˆæ˜¯æ§åˆ¶åè½¬ï¼ˆIoCï¼‰ï¼Ÿ
**èƒŒé¢**ï¼šæ§åˆ¶åè½¬æ˜¯ä¸€ç§è®¾è®¡åŸåˆ™ï¼Œå°†å¯¹è±¡çš„åˆ›å»ºå’Œä¾èµ–ç®¡ç†çš„æ§åˆ¶æƒä»å¯¹è±¡å†…éƒ¨è½¬ç§»åˆ°å¤–éƒ¨å®¹å™¨ï¼Œå®ç°æ¾è€¦åˆå’Œé«˜å¯æµ‹è¯•æ€§ã€‚

**æ­£é¢**ï¼šä¾èµ–æ³¨å…¥çš„å››ç§æ–¹å¼æ˜¯ä»€ä¹ˆï¼Ÿ
**èƒŒé¢**ï¼š
1. æ„é€ å‡½æ•°æ³¨å…¥ - é€šè¿‡æ„é€ å‡½æ•°å‚æ•°æ³¨å…¥
2. å±æ€§æ³¨å…¥ - é€šè¿‡å¯¹è±¡å±æ€§æ³¨å…¥
3. æ–¹æ³•æ³¨å…¥ - é€šè¿‡ç‰¹å®šæ–¹æ³•æ³¨å…¥
4. æ¥å£æ³¨å…¥ - é€šè¿‡å®ç°æ¥å£æ³¨å…¥

#### ä»£ç æ¨¡å¼å¡ç‰‡
**æ­£é¢**ï¼šå¦‚ä½•è§£å†³å¾ªç¯ä¾èµ–ï¼Ÿ
**èƒŒé¢**ï¼š
```typescript
// ä½¿ç”¨forwardRef
@Injectable()
class UserService {
  constructor(
    @Inject(forwardRef(() => OrderService))
    private orderService: OrderService
  ) {}
}
```

#### é—®é¢˜è§£å†³å¡ç‰‡
**æ­£é¢**ï¼šå¦‚ä½•ä¼˜åŒ–ä¾èµ–æ³¨å…¥çš„æ€§èƒ½ï¼Ÿ
**èƒŒé¢**ï¼š
1. é¢„ç¼–è¯‘ä¾èµ–è§£æå‡½æ•°
2. ä½¿ç”¨å¯¹è±¡æ± å‡å°‘åˆ›å»ºå¼€é”€
3. ç¼“å­˜å…ƒæ•°æ®é¿å…åå°„è°ƒç”¨
4. åˆç†è®¾ç½®ç”Ÿå‘½å‘¨æœŸä½œç”¨åŸŸ

---

> **ğŸ¯ æœ¬ç« å­¦ä¹ å®Œæˆæ ‡å¿—**ï¼š
> 
> å½“æ‚¨èƒ½å¤Ÿï¼š
> 1. æ·±å…¥ç†è§£IoCå®¹å™¨çš„å·¥ä½œåŸç†å’Œè®¾è®¡æ€æƒ³
> 2. ç†Ÿç»ƒä½¿ç”¨NestJSçš„ä¾èµ–æ³¨å…¥ç³»ç»Ÿ
> 3. åˆ›å»ºè‡ªå®šä¹‰è£…é¥°å™¨å’Œæä¾›è€…
> 4. å¤„ç†å¤æ‚çš„ä¾èµ–å…³ç³»å’Œæ€§èƒ½ä¼˜åŒ–
> 5. è®¾è®¡ä¼ä¸šçº§çš„ä¾èµ–æ³¨å…¥æ¶æ„
> 
> æ­å–œæ‚¨å·²ç»æŒæ¡äº†ä¾èµ–æ³¨å…¥çš„æ ¸å¿ƒåŸç†å’Œé«˜çº§åº”ç”¨ï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ç¬¬4ç« ã€Šæ•°æ®æŒä¹…åŒ–ç­–ç•¥ã€‹ï¼

---

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼šåœ¨ç¬¬4ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ æ•°æ®æŒä¹…åŒ–çš„å„ç§ç­–ç•¥å’ŒæŠ€æœ¯ï¼ŒåŒ…æ‹¬ORMæ¡†æ¶çš„ä½¿ç”¨ã€æ•°æ®åº“è®¾è®¡ã€æŸ¥è¯¢ä¼˜åŒ–ã€äº‹åŠ¡ç®¡ç†ç­‰å†…å®¹ã€‚æˆ‘ä»¬ä¼šæ·±å…¥äº†è§£TypeORMçš„é«˜çº§ç‰¹æ€§ï¼Œä»¥åŠå¦‚ä½•åœ¨NestJSä¸­æ„å»ºé«˜æ•ˆçš„æ•°æ®è®¿é—®å±‚ã€‚ 